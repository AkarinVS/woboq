<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>flag.h source code [halide/build-apps/abseil-cpp/absl/flags/flag.h] - Woboq Code Browser</title>
<link rel="stylesheet" href="../../../../.././data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../.././data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../.././data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../.././data/jquery/jquery-ui.min.js"></script>
<script>var file = 'halide/build-apps/abseil-cpp/absl/flags/flag.h'; var root_path = '../../../../..'; var data_path = '../../../../.././data'; var ecma_script_api_version = 2;</script>
<script src='../../../../.././data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../..'>halide</a>/<a href='../../..'>build-apps</a>/<a href='../..'>abseil-cpp</a>/<a href='..'>absl</a>/<a href='./'>flags</a>/<a href='flag.h.html'>flag.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>//</i></td></tr>
<tr><th id="2">2</th><td><i>//  Copyright 2019 The Abseil Authors.</i></td></tr>
<tr><th id="3">3</th><td><i>//</i></td></tr>
<tr><th id="4">4</th><td><i>// Licensed under the Apache License, Version 2.0 (the "License");</i></td></tr>
<tr><th id="5">5</th><td><i>// you may not use this file except in compliance with the License.</i></td></tr>
<tr><th id="6">6</th><td><i>// You may obtain a copy of the License at</i></td></tr>
<tr><th id="7">7</th><td><i>//</i></td></tr>
<tr><th id="8">8</th><td><i>//      <a href="https://www.apache.org/licenses/LICENSE-2.0">https://www.apache.org/licenses/LICENSE-2.0</a></i></td></tr>
<tr><th id="9">9</th><td><i>//</i></td></tr>
<tr><th id="10">10</th><td><i>// Unless required by applicable law or agreed to in writing, software</i></td></tr>
<tr><th id="11">11</th><td><i>// distributed under the License is distributed on an "AS IS" BASIS,</i></td></tr>
<tr><th id="12">12</th><td><i>// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i></td></tr>
<tr><th id="13">13</th><td><i>// See the License for the specific language governing permissions and</i></td></tr>
<tr><th id="14">14</th><td><i>// limitations under the License.</i></td></tr>
<tr><th id="15">15</th><td><i>//</i></td></tr>
<tr><th id="16">16</th><td><i>// -----------------------------------------------------------------------------</i></td></tr>
<tr><th id="17">17</th><td><i>// File: flag.h</i></td></tr>
<tr><th id="18">18</th><td><i>// -----------------------------------------------------------------------------</i></td></tr>
<tr><th id="19">19</th><td><i>//</i></td></tr>
<tr><th id="20">20</th><td><i>// This header file defines the `absl::Flag&lt;T&gt;` type for holding command-line</i></td></tr>
<tr><th id="21">21</th><td><i>// flag data, and abstractions to create, get and set such flag data.</i></td></tr>
<tr><th id="22">22</th><td><i>//</i></td></tr>
<tr><th id="23">23</th><td><i>// It is important to note that this type is **unspecified** (an implementation</i></td></tr>
<tr><th id="24">24</th><td><i>// detail) and you do not construct or manipulate actual `absl::Flag&lt;T&gt;`</i></td></tr>
<tr><th id="25">25</th><td><i>// instances. Instead, you define and declare flags using the</i></td></tr>
<tr><th id="26">26</th><td><i>// `ABSL_FLAG()` and `ABSL_DECLARE_FLAG()` macros, and get and set flag values</i></td></tr>
<tr><th id="27">27</th><td><i>// using the `absl::GetFlag()` and `absl::SetFlag()` functions.</i></td></tr>
<tr><th id="28">28</th><td></td></tr>
<tr><th id="29">29</th><td><u>#<span data-ppcond="29">ifndef</span> <span class="macro" data-ref="_M/ABSL_FLAGS_FLAG_H_">ABSL_FLAGS_FLAG_H_</span></u></td></tr>
<tr><th id="30">30</th><td><u>#define <dfn class="macro" id="_M/ABSL_FLAGS_FLAG_H_" data-ref="_M/ABSL_FLAGS_FLAG_H_">ABSL_FLAGS_FLAG_H_</dfn></u></td></tr>
<tr><th id="31">31</th><td></td></tr>
<tr><th id="32">32</th><td><u>#include &lt;string&gt;</u></td></tr>
<tr><th id="33">33</th><td><u>#include &lt;type_traits&gt;</u></td></tr>
<tr><th id="34">34</th><td></td></tr>
<tr><th id="35">35</th><td><u>#include <a href="../base/attributes.h.html">"absl/base/attributes.h"</a></u></td></tr>
<tr><th id="36">36</th><td><u>#include <a href="../base/casts.h.html">"absl/base/casts.h"</a></u></td></tr>
<tr><th id="37">37</th><td><u>#include <a href="../base/config.h.html">"absl/base/config.h"</a></u></td></tr>
<tr><th id="38">38</th><td><u>#include <a href="config.h.html">"absl/flags/config.h"</a></u></td></tr>
<tr><th id="39">39</th><td><u>#include <a href="declare.h.html">"absl/flags/declare.h"</a></u></td></tr>
<tr><th id="40">40</th><td><u>#include <a href="internal/commandlineflag.h.html">"absl/flags/internal/commandlineflag.h"</a></u></td></tr>
<tr><th id="41">41</th><td><u>#include <a href="internal/flag.h.html">"absl/flags/internal/flag.h"</a></u></td></tr>
<tr><th id="42">42</th><td><u>#include <a href="internal/registry.h.html">"absl/flags/internal/registry.h"</a></u></td></tr>
<tr><th id="43">43</th><td><u>#include <a href="marshalling.h.html">"absl/flags/marshalling.h"</a></u></td></tr>
<tr><th id="44">44</th><td></td></tr>
<tr><th id="45">45</th><td><b>namespace</b> <span class="namespace">absl</span> {</td></tr>
<tr><th id="46">46</th><td><a class="macro" href="../base/config.h.html#125" title="inline namespace lts_2020_02_25 {" data-ref="_M/ABSL_NAMESPACE_BEGIN">ABSL_NAMESPACE_BEGIN</a></td></tr>
<tr><th id="47">47</th><td></td></tr>
<tr><th id="48">48</th><td><i>// Flag</i></td></tr>
<tr><th id="49">49</th><td><i>//</i></td></tr>
<tr><th id="50">50</th><td><i>// An `absl::Flag` holds a command-line flag value, providing a runtime</i></td></tr>
<tr><th id="51">51</th><td><i>// parameter to a binary. Such flags should be defined in the global namespace</i></td></tr>
<tr><th id="52">52</th><td><i>// and (preferably) in the module containing the binary's `main()` function.</i></td></tr>
<tr><th id="53">53</th><td><i>//</i></td></tr>
<tr><th id="54">54</th><td><i>// You should not construct and cannot use the `absl::Flag` type directly;</i></td></tr>
<tr><th id="55">55</th><td><i>// instead, you should declare flags using the `ABSL_DECLARE_FLAG()` macro</i></td></tr>
<tr><th id="56">56</th><td><i>// within a header file, and define your flag using `ABSL_FLAG()` within your</i></td></tr>
<tr><th id="57">57</th><td><i>// header's associated `.cc` file. Such flags will be named `FLAGS_name`.</i></td></tr>
<tr><th id="58">58</th><td><i>//</i></td></tr>
<tr><th id="59">59</th><td><i>// Example:</i></td></tr>
<tr><th id="60">60</th><td><i>//</i></td></tr>
<tr><th id="61">61</th><td><i>//    .h file</i></td></tr>
<tr><th id="62">62</th><td><i>//</i></td></tr>
<tr><th id="63">63</th><td><i>//      // Declares usage of a flag named "FLAGS_count"</i></td></tr>
<tr><th id="64">64</th><td><i>//      ABSL_DECLARE_FLAG(int, count);</i></td></tr>
<tr><th id="65">65</th><td><i>//</i></td></tr>
<tr><th id="66">66</th><td><i>//    .cc file</i></td></tr>
<tr><th id="67">67</th><td><i>//</i></td></tr>
<tr><th id="68">68</th><td><i>//      // Defines a flag named "FLAGS_count" with a default `int` value of 0.</i></td></tr>
<tr><th id="69">69</th><td><i>//      ABSL_FLAG(int, count, 0, "Count of items to process");</i></td></tr>
<tr><th id="70">70</th><td><i>//</i></td></tr>
<tr><th id="71">71</th><td><i>// No public methods of `absl::Flag&lt;T&gt;` are part of the Abseil Flags API.</i></td></tr>
<tr><th id="72">72</th><td><u>#<span data-ppcond="72">if</span> !defined(<span class="macro" data-ref="_M/_MSC_VER">_MSC_VER</span>) || defined(<span class="macro" data-ref="_M/__clang__">__clang__</span>)</u></td></tr>
<tr><th id="73">73</th><td><b>template</b> &lt;<b>typename</b> T&gt;</td></tr>
<tr><th id="74">74</th><td><b>using</b> <dfn class="typedef" id="absl::lts_2020_02_25::Flag" title='absl::lts_2020_02_25::Flag' data-type='flags_internal::Flag&lt;T&gt;' data-ref="absl::lts_2020_02_25::Flag" data-ref-filename="absl..lts_2020_02_25..Flag">Flag</dfn> = <span class="namespace">flags_internal::</span><a class="type" href="declare.h.html#absl::lts_2020_02_25::flags_internal::Flag" title='absl::lts_2020_02_25::flags_internal::Flag' data-ref="absl::lts_2020_02_25::flags_internal::Flag" data-ref-filename="absl..lts_2020_02_25..flags_internal..Flag">Flag</a>&lt;T&gt;;</td></tr>
<tr><th id="75">75</th><td><u>#<span data-ppcond="72">else</span></u></td></tr>
<tr><th id="76">76</th><td><i>// MSVC debug builds do not implement initialization with constexpr constructors</i></td></tr>
<tr><th id="77">77</th><td><i>// correctly. To work around this we add a level of indirection, so that the</i></td></tr>
<tr><th id="78">78</th><td><i>// class `absl::Flag` contains an `internal::Flag*` (instead of being an alias</i></td></tr>
<tr><th id="79">79</th><td><i>// to that class) and dynamically allocates an instance when necessary. We also</i></td></tr>
<tr><th id="80">80</th><td><i>// forward all calls to internal::Flag methods via trampoline methods. In this</i></td></tr>
<tr><th id="81">81</th><td><i>// setup the `absl::Flag` class does not have constructor and virtual methods,</i></td></tr>
<tr><th id="82">82</th><td><i>// all the data members are public and thus MSVC is able to initialize it at</i></td></tr>
<tr><th id="83">83</th><td><i>// link time. To deal with multiple threads accessing the flag for the first</i></td></tr>
<tr><th id="84">84</th><td><i>// time concurrently we use an atomic boolean indicating if flag object is</i></td></tr>
<tr><th id="85">85</th><td><i>// initialized. We also employ the double-checked locking pattern where the</i></td></tr>
<tr><th id="86">86</th><td><i>// second level of protection is a global Mutex, so if two threads attempt to</i></td></tr>
<tr><th id="87">87</th><td><i>// construct the flag concurrently only one wins.</i></td></tr>
<tr><th id="88">88</th><td><i>// This solution is based on a recomendation here:</i></td></tr>
<tr><th id="89">89</th><td><i>// <a href="https://developercommunity.visualstudio.com/content/problem/336946/class-with-constexpr-constructor-not-using-static.html?childToView=648454#comment-648454">https://developercommunity.visualstudio.com/content/problem/336946/class-with-constexpr-constructor-not-using-static.html?childToView=648454#comment-648454</a></i></td></tr>
<tr><th id="90">90</th><td></td></tr>
<tr><th id="91">91</th><td><b>namespace</b> flags_internal {</td></tr>
<tr><th id="92">92</th><td>absl::Mutex* GetGlobalConstructionGuard();</td></tr>
<tr><th id="93">93</th><td>}  <i>// namespace flags_internal</i></td></tr>
<tr><th id="94">94</th><td></td></tr>
<tr><th id="95">95</th><td><b>template</b> &lt;<b>typename</b> T&gt;</td></tr>
<tr><th id="96">96</th><td><b>class</b> Flag {</td></tr>
<tr><th id="97">97</th><td> <b>public</b>:</td></tr>
<tr><th id="98">98</th><td>  <i>// No constructor and destructor to ensure this is an aggregate type.</i></td></tr>
<tr><th id="99">99</th><td><i>  // Visual Studio 2015 still requires the constructor for class to be</i></td></tr>
<tr><th id="100">100</th><td><i>  // constexpr initializable.</i></td></tr>
<tr><th id="101">101</th><td><u>#if _MSC_VER &lt;= 1900</u></td></tr>
<tr><th id="102">102</th><td>  <b>constexpr</b> Flag(<em>const</em> <em>char</em>* name, <em>const</em> <em>char</em>* filename,</td></tr>
<tr><th id="103">103</th><td>                 <em>const</em> flags_internal::HelpGenFunc help_gen,</td></tr>
<tr><th id="104">104</th><td>                 <em>const</em> flags_internal::FlagDfltGenFunc default_value_gen)</td></tr>
<tr><th id="105">105</th><td>      : name_(name),</td></tr>
<tr><th id="106">106</th><td>        filename_(filename),</td></tr>
<tr><th id="107">107</th><td>        help_gen_(help_gen),</td></tr>
<tr><th id="108">108</th><td>        default_value_gen_(default_value_gen),</td></tr>
<tr><th id="109">109</th><td>        inited_(<b>false</b>),</td></tr>
<tr><th id="110">110</th><td>        impl_(<b>nullptr</b>) {}</td></tr>
<tr><th id="111">111</th><td><u>#endif</u></td></tr>
<tr><th id="112">112</th><td></td></tr>
<tr><th id="113">113</th><td>  flags_internal::Flag&lt;T&gt;* GetImpl() <em>const</em> {</td></tr>
<tr><th id="114">114</th><td>    <b>if</b> (!inited_.load(std::memory_order_acquire)) {</td></tr>
<tr><th id="115">115</th><td>      absl::MutexLock l(flags_internal::GetGlobalConstructionGuard());</td></tr>
<tr><th id="116">116</th><td></td></tr>
<tr><th id="117">117</th><td>      <b>if</b> (inited_.load(std::memory_order_acquire)) {</td></tr>
<tr><th id="118">118</th><td>        <b>return</b> impl_;</td></tr>
<tr><th id="119">119</th><td>      }</td></tr>
<tr><th id="120">120</th><td></td></tr>
<tr><th id="121">121</th><td>      impl_ =</td></tr>
<tr><th id="122">122</th><td>          <b>new</b> flags_internal::Flag&lt;T&gt;(name_, filename_,</td></tr>
<tr><th id="123">123</th><td>                                      {flags_internal::FlagHelpMsg(help_gen_),</td></tr>
<tr><th id="124">124</th><td>                                       flags_internal::FlagHelpKind::kGenFunc},</td></tr>
<tr><th id="125">125</th><td>                                      default_value_gen_);</td></tr>
<tr><th id="126">126</th><td>      inited_.store(<b>true</b>, std::memory_order_release);</td></tr>
<tr><th id="127">127</th><td>    }</td></tr>
<tr><th id="128">128</th><td></td></tr>
<tr><th id="129">129</th><td>    <b>return</b> impl_;</td></tr>
<tr><th id="130">130</th><td>  }</td></tr>
<tr><th id="131">131</th><td></td></tr>
<tr><th id="132">132</th><td>  <i>// Public methods of `absl::Flag&lt;T&gt;` are NOT part of the Abseil Flags API.</i></td></tr>
<tr><th id="133">133</th><td><i>  // See <a href="https://abseil.io/docs/cpp/guides/flags">https://abseil.io/docs/cpp/guides/flags</a></i></td></tr>
<tr><th id="134">134</th><td>  <em>bool</em> IsRetired() <em>const</em> { <b>return</b> GetImpl()-&gt;IsRetired(); }</td></tr>
<tr><th id="135">135</th><td>  <em>bool</em> IsAbseilFlag() <em>const</em> { <b>return</b> GetImpl()-&gt;IsAbseilFlag(); }</td></tr>
<tr><th id="136">136</th><td>  absl::string_view Name() <em>const</em> { <b>return</b> GetImpl()-&gt;Name(); }</td></tr>
<tr><th id="137">137</th><td>  std::string Help() <em>const</em> { <b>return</b> GetImpl()-&gt;Help(); }</td></tr>
<tr><th id="138">138</th><td>  <em>bool</em> IsModified() <em>const</em> { <b>return</b> GetImpl()-&gt;IsModified(); }</td></tr>
<tr><th id="139">139</th><td>  <em>bool</em> IsSpecifiedOnCommandLine() <em>const</em> {</td></tr>
<tr><th id="140">140</th><td>    <b>return</b> GetImpl()-&gt;IsSpecifiedOnCommandLine();</td></tr>
<tr><th id="141">141</th><td>  }</td></tr>
<tr><th id="142">142</th><td>  absl::string_view Typename() <em>const</em> { <b>return</b> GetImpl()-&gt;Typename(); }</td></tr>
<tr><th id="143">143</th><td>  std::string Filename() <em>const</em> { <b>return</b> GetImpl()-&gt;Filename(); }</td></tr>
<tr><th id="144">144</th><td>  std::string DefaultValue() <em>const</em> { <b>return</b> GetImpl()-&gt;DefaultValue(); }</td></tr>
<tr><th id="145">145</th><td>  std::string CurrentValue() <em>const</em> { <b>return</b> GetImpl()-&gt;CurrentValue(); }</td></tr>
<tr><th id="146">146</th><td>  <b>template</b> &lt;<b>typename</b> U&gt;</td></tr>
<tr><th id="147">147</th><td>  <b>inline</b> <em>bool</em> IsOfType() <em>const</em> {</td></tr>
<tr><th id="148">148</th><td>    <b>return</b> GetImpl()-&gt;<b>template</b> IsOfType&lt;U&gt;();</td></tr>
<tr><th id="149">149</th><td>  }</td></tr>
<tr><th id="150">150</th><td>  T Get() <em>const</em> { <b>return</b> GetImpl()-&gt;Get(); }</td></tr>
<tr><th id="151">151</th><td>  <em>bool</em> AtomicGet(T* v) <em>const</em> { <b>return</b> GetImpl()-&gt;AtomicGet(v); }</td></tr>
<tr><th id="152">152</th><td>  <em>void</em> Set(<em>const</em> T&amp; v) { GetImpl()-&gt;Set(v); }</td></tr>
<tr><th id="153">153</th><td>  <em>void</em> SetCallback(<em>const</em> flags_internal::FlagCallbackFunc mutation_callback) {</td></tr>
<tr><th id="154">154</th><td>    GetImpl()-&gt;SetCallback(mutation_callback);</td></tr>
<tr><th id="155">155</th><td>  }</td></tr>
<tr><th id="156">156</th><td>  <em>void</em> InvokeCallback() { GetImpl()-&gt;InvokeCallback(); }</td></tr>
<tr><th id="157">157</th><td></td></tr>
<tr><th id="158">158</th><td>  <i>// The data members are logically private, but they need to be public for</i></td></tr>
<tr><th id="159">159</th><td><i>  // this to be an aggregate type.</i></td></tr>
<tr><th id="160">160</th><td>  <em>const</em> <em>char</em>* name_;</td></tr>
<tr><th id="161">161</th><td>  <em>const</em> <em>char</em>* filename_;</td></tr>
<tr><th id="162">162</th><td>  <em>const</em> flags_internal::HelpGenFunc help_gen_;</td></tr>
<tr><th id="163">163</th><td>  <em>const</em> flags_internal::FlagDfltGenFunc default_value_gen_;</td></tr>
<tr><th id="164">164</th><td></td></tr>
<tr><th id="165">165</th><td>  <em>mutable</em> std::atomic&lt;<em>bool</em>&gt; inited_;</td></tr>
<tr><th id="166">166</th><td>  <em>mutable</em> flags_internal::Flag&lt;T&gt;* impl_;</td></tr>
<tr><th id="167">167</th><td>};</td></tr>
<tr><th id="168">168</th><td><u>#<span data-ppcond="72">endif</span></u></td></tr>
<tr><th id="169">169</th><td></td></tr>
<tr><th id="170">170</th><td><i>// GetFlag()</i></td></tr>
<tr><th id="171">171</th><td><i>//</i></td></tr>
<tr><th id="172">172</th><td><i>// Returns the value (of type `T`) of an `absl::Flag&lt;T&gt;` instance, by value. Do</i></td></tr>
<tr><th id="173">173</th><td><i>// not construct an `absl::Flag&lt;T&gt;` directly and call `absl::GetFlag()`;</i></td></tr>
<tr><th id="174">174</th><td><i>// instead, refer to flag's constructed variable name (e.g. `FLAGS_name`).</i></td></tr>
<tr><th id="175">175</th><td><i>// Because this function returns by value and not by reference, it is</i></td></tr>
<tr><th id="176">176</th><td><i>// thread-safe, but note that the operation may be expensive; as a result, avoid</i></td></tr>
<tr><th id="177">177</th><td><i>// `absl::GetFlag()` within any tight loops.</i></td></tr>
<tr><th id="178">178</th><td><i>//</i></td></tr>
<tr><th id="179">179</th><td><i>// Example:</i></td></tr>
<tr><th id="180">180</th><td><i>//</i></td></tr>
<tr><th id="181">181</th><td><i>//   // FLAGS_count is a Flag of type `int`</i></td></tr>
<tr><th id="182">182</th><td><i>//   int my_count = absl::GetFlag(FLAGS_count);</i></td></tr>
<tr><th id="183">183</th><td><i>//</i></td></tr>
<tr><th id="184">184</th><td><i>//   // FLAGS_firstname is a Flag of type `std::string`</i></td></tr>
<tr><th id="185">185</th><td><i>//   std::string first_name = absl::GetFlag(FLAGS_firstname);</i></td></tr>
<tr><th id="186">186</th><td><b>template</b> &lt;<b>typename</b> T&gt;</td></tr>
<tr><th id="187">187</th><td><a class="macro" href="../base/attributes.h.html#449" title="__attribute__((warn_unused_result))" data-ref="_M/ABSL_MUST_USE_RESULT">ABSL_MUST_USE_RESULT</a> T <dfn class="decl def fn" id="_ZN4absl14lts_2020_02_257GetFlagERKNS0_14flags_internal4FlagIT_EE" title='absl::lts_2020_02_25::GetFlag' data-ref="_ZN4absl14lts_2020_02_257GetFlagERKNS0_14flags_internal4FlagIT_EE" data-ref-filename="_ZN4absl14lts_2020_02_257GetFlagERKNS0_14flags_internal4FlagIT_EE">GetFlag</dfn>(<em>const</em> <span class="namespace">absl::</span><a class="type" href="declare.h.html#absl::lts_2020_02_25::Flag" title='absl::lts_2020_02_25::Flag' data-ref="absl::lts_2020_02_25::Flag" data-ref-filename="absl..lts_2020_02_25..Flag">Flag</a>&lt;T&gt;&amp; <dfn class="local col7 decl" id="127flag" title='flag' data-type='const absl::Flag&lt;T&gt; &amp;' data-ref="127flag" data-ref-filename="127flag">flag</dfn>) {</td></tr>
<tr><th id="188">188</th><td>  <b>return</b> <a class="local col7 ref" href="#127flag" title='flag' data-ref="127flag" data-ref-filename="127flag">flag</a>.Get();</td></tr>
<tr><th id="189">189</th><td>}</td></tr>
<tr><th id="190">190</th><td></td></tr>
<tr><th id="191">191</th><td><i>// SetFlag()</i></td></tr>
<tr><th id="192">192</th><td><i>//</i></td></tr>
<tr><th id="193">193</th><td><i>// Sets the value of an `absl::Flag` to the value `v`. Do not construct an</i></td></tr>
<tr><th id="194">194</th><td><i>// `absl::Flag&lt;T&gt;` directly and call `absl::SetFlag()`; instead, use the</i></td></tr>
<tr><th id="195">195</th><td><i>// flag's variable name (e.g. `FLAGS_name`). This function is</i></td></tr>
<tr><th id="196">196</th><td><i>// thread-safe, but is potentially expensive. Avoid setting flags in general,</i></td></tr>
<tr><th id="197">197</th><td><i>// but especially within performance-critical code.</i></td></tr>
<tr><th id="198">198</th><td><b>template</b> &lt;<b>typename</b> T&gt;</td></tr>
<tr><th id="199">199</th><td><em>void</em> <dfn class="decl def fn" id="_ZN4absl14lts_2020_02_257SetFlagEPNS0_14flags_internal4FlagIT_EERKS3_" title='absl::lts_2020_02_25::SetFlag' data-ref="_ZN4absl14lts_2020_02_257SetFlagEPNS0_14flags_internal4FlagIT_EERKS3_" data-ref-filename="_ZN4absl14lts_2020_02_257SetFlagEPNS0_14flags_internal4FlagIT_EERKS3_">SetFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="declare.h.html#absl::lts_2020_02_25::Flag" title='absl::lts_2020_02_25::Flag' data-ref="absl::lts_2020_02_25::Flag" data-ref-filename="absl..lts_2020_02_25..Flag">Flag</a>&lt;T&gt;* <dfn class="local col8 decl" id="128flag" title='flag' data-type='absl::Flag&lt;T&gt; *' data-ref="128flag" data-ref-filename="128flag">flag</dfn>, <em>const</em> T&amp; <dfn class="local col9 decl" id="129v" title='v' data-type='const T &amp;' data-ref="129v" data-ref-filename="129v">v</dfn>) {</td></tr>
<tr><th id="200">200</th><td>  <a class="local col8 ref" href="#128flag" title='flag' data-ref="128flag" data-ref-filename="128flag">flag</a>-&gt;Set(<a class="local col9 ref" href="#129v" title='v' data-ref="129v" data-ref-filename="129v">v</a>);</td></tr>
<tr><th id="201">201</th><td>}</td></tr>
<tr><th id="202">202</th><td></td></tr>
<tr><th id="203">203</th><td><i>// Overload of `SetFlag()` to allow callers to pass in a value that is</i></td></tr>
<tr><th id="204">204</th><td><i>// convertible to `T`. E.g., use this overload to pass a "const char*" when `T`</i></td></tr>
<tr><th id="205">205</th><td><i>// is `std::string`.</i></td></tr>
<tr><th id="206">206</th><td><b>template</b> &lt;<b>typename</b> T, <b>typename</b> V&gt;</td></tr>
<tr><th id="207">207</th><td><em>void</em> <dfn class="decl def fn" id="_ZN4absl14lts_2020_02_257SetFlagEPNS0_14flags_internal4FlagIT_EERKT0_" title='absl::lts_2020_02_25::SetFlag' data-ref="_ZN4absl14lts_2020_02_257SetFlagEPNS0_14flags_internal4FlagIT_EERKT0_" data-ref-filename="_ZN4absl14lts_2020_02_257SetFlagEPNS0_14flags_internal4FlagIT_EERKT0_">SetFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="declare.h.html#absl::lts_2020_02_25::Flag" title='absl::lts_2020_02_25::Flag' data-ref="absl::lts_2020_02_25::Flag" data-ref-filename="absl..lts_2020_02_25..Flag">Flag</a>&lt;T&gt;* <dfn class="local col0 decl" id="130flag" title='flag' data-type='absl::Flag&lt;T&gt; *' data-ref="130flag" data-ref-filename="130flag">flag</dfn>, <em>const</em> V&amp; <dfn class="local col1 decl" id="131v" title='v' data-type='const V &amp;' data-ref="131v" data-ref-filename="131v">v</dfn>) {</td></tr>
<tr><th id="208">208</th><td>  T <dfn class="local col2 decl" id="132value" title='value' data-type='T' data-ref="132value" data-ref-filename="132value">value</dfn>(<a class="local col1 ref" href="#131v" title='v' data-ref="131v" data-ref-filename="131v">v</a>);</td></tr>
<tr><th id="209">209</th><td>  <a class="local col0 ref" href="#130flag" title='flag' data-ref="130flag" data-ref-filename="130flag">flag</a>-&gt;Set(<a class="local col2 ref" href="#132value" title='value' data-ref="132value" data-ref-filename="132value">value</a>);</td></tr>
<tr><th id="210">210</th><td>}</td></tr>
<tr><th id="211">211</th><td></td></tr>
<tr><th id="212">212</th><td><a class="macro" href="../base/config.h.html#127" title="}" data-ref="_M/ABSL_NAMESPACE_END">ABSL_NAMESPACE_END</a></td></tr>
<tr><th id="213">213</th><td>}  <i>// namespace absl</i></td></tr>
<tr><th id="214">214</th><td></td></tr>
<tr><th id="215">215</th><td></td></tr>
<tr><th id="216">216</th><td><i>// ABSL_FLAG()</i></td></tr>
<tr><th id="217">217</th><td><i>//</i></td></tr>
<tr><th id="218">218</th><td><i>// This macro defines an `absl::Flag&lt;T&gt;` instance of a specified type `T`:</i></td></tr>
<tr><th id="219">219</th><td><i>//</i></td></tr>
<tr><th id="220">220</th><td><i>//   ABSL_FLAG(T, name, default_value, help);</i></td></tr>
<tr><th id="221">221</th><td><i>//</i></td></tr>
<tr><th id="222">222</th><td><i>// where:</i></td></tr>
<tr><th id="223">223</th><td><i>//</i></td></tr>
<tr><th id="224">224</th><td><i>//   * `T` is a supported flag type (see the list of types in `marshalling.h`),</i></td></tr>
<tr><th id="225">225</th><td><i>//   * `name` designates the name of the flag (as a global variable</i></td></tr>
<tr><th id="226">226</th><td><i>//     `FLAGS_name`),</i></td></tr>
<tr><th id="227">227</th><td><i>//   * `default_value` is an expression holding the default value for this flag</i></td></tr>
<tr><th id="228">228</th><td><i>//     (which must be implicitly convertible to `T`),</i></td></tr>
<tr><th id="229">229</th><td><i>//   * `help` is the help text, which can also be an expression.</i></td></tr>
<tr><th id="230">230</th><td><i>//</i></td></tr>
<tr><th id="231">231</th><td><i>// This macro expands to a flag named 'FLAGS_name' of type 'T':</i></td></tr>
<tr><th id="232">232</th><td><i>//</i></td></tr>
<tr><th id="233">233</th><td><i>//   absl::Flag&lt;T&gt; FLAGS_name = ...;</i></td></tr>
<tr><th id="234">234</th><td><i>//</i></td></tr>
<tr><th id="235">235</th><td><i>// Note that all such instances are created as global variables.</i></td></tr>
<tr><th id="236">236</th><td><i>//</i></td></tr>
<tr><th id="237">237</th><td><i>// For `ABSL_FLAG()` values that you wish to expose to other translation units,</i></td></tr>
<tr><th id="238">238</th><td><i>// it is recommended to define those flags within the `.cc` file associated with</i></td></tr>
<tr><th id="239">239</th><td><i>// the header where the flag is declared.</i></td></tr>
<tr><th id="240">240</th><td><i>//</i></td></tr>
<tr><th id="241">241</th><td><i>// Note: do not construct objects of type `absl::Flag&lt;T&gt;` directly. Only use the</i></td></tr>
<tr><th id="242">242</th><td><i>// `ABSL_FLAG()` macro for such construction.</i></td></tr>
<tr><th id="243">243</th><td><u>#define <dfn class="macro" id="_M/ABSL_FLAG" data-ref="_M/ABSL_FLAG">ABSL_FLAG</dfn>(Type, name, default_value, help) \</u></td></tr>
<tr><th id="244">244</th><td><u>  ABSL_FLAG_IMPL(Type, name, default_value, help)</u></td></tr>
<tr><th id="245">245</th><td></td></tr>
<tr><th id="246">246</th><td><i>// ABSL_FLAG().OnUpdate()</i></td></tr>
<tr><th id="247">247</th><td><i>//</i></td></tr>
<tr><th id="248">248</th><td><i>// Defines a flag of type `T` with a callback attached:</i></td></tr>
<tr><th id="249">249</th><td><i>//</i></td></tr>
<tr><th id="250">250</th><td><i>//   ABSL_FLAG(T, name, default_value, help).OnUpdate(callback);</i></td></tr>
<tr><th id="251">251</th><td><i>//</i></td></tr>
<tr><th id="252">252</th><td><i>// After any setting of the flag value, the callback will be called at least</i></td></tr>
<tr><th id="253">253</th><td><i>// once. A rapid sequence of changes may be merged together into the same</i></td></tr>
<tr><th id="254">254</th><td><i>// callback. No concurrent calls to the callback will be made for the same</i></td></tr>
<tr><th id="255">255</th><td><i>// flag. Callbacks are allowed to read the current value of the flag but must</i></td></tr>
<tr><th id="256">256</th><td><i>// not mutate that flag.</i></td></tr>
<tr><th id="257">257</th><td><i>//</i></td></tr>
<tr><th id="258">258</th><td><i>// The update mechanism guarantees "eventual consistency"; if the callback</i></td></tr>
<tr><th id="259">259</th><td><i>// derives an auxiliary data structure from the flag value, it is guaranteed</i></td></tr>
<tr><th id="260">260</th><td><i>// that eventually the flag value and the derived data structure will be</i></td></tr>
<tr><th id="261">261</th><td><i>// consistent.</i></td></tr>
<tr><th id="262">262</th><td><i>//</i></td></tr>
<tr><th id="263">263</th><td><i>// Note: ABSL_FLAG.OnUpdate() does not have a public definition. Hence, this</i></td></tr>
<tr><th id="264">264</th><td><i>// comment serves as its API documentation.</i></td></tr>
<tr><th id="265">265</th><td><i></i></td></tr>
<tr><th id="266">266</th><td><i></i></td></tr>
<tr><th id="267">267</th><td><i>// -----------------------------------------------------------------------------</i></td></tr>
<tr><th id="268">268</th><td><i>// Implementation details below this section</i></td></tr>
<tr><th id="269">269</th><td><i>// -----------------------------------------------------------------------------</i></td></tr>
<tr><th id="270">270</th><td><i></i></td></tr>
<tr><th id="271">271</th><td><i>// ABSL_FLAG_IMPL macro definition conditional on ABSL_FLAGS_STRIP_NAMES</i></td></tr>
<tr><th id="272">272</th><td></td></tr>
<tr><th id="273">273</th><td><u>#<span data-ppcond="273">if</span> <a class="macro" href="config.h.html#40" title="0" data-ref="_M/ABSL_FLAGS_STRIP_NAMES">ABSL_FLAGS_STRIP_NAMES</a></u></td></tr>
<tr><th id="274">274</th><td><u>#define ABSL_FLAG_IMPL_FLAGNAME(txt) ""</u></td></tr>
<tr><th id="275">275</th><td><u>#define ABSL_FLAG_IMPL_FILENAME() ""</u></td></tr>
<tr><th id="276">276</th><td><u>#if !defined(_MSC_VER) || defined(__clang__)</u></td></tr>
<tr><th id="277">277</th><td><u>#define ABSL_FLAG_IMPL_REGISTRAR(T, flag) \</u></td></tr>
<tr><th id="278">278</th><td><u>  absl::flags_internal::FlagRegistrar&lt;T, false&gt;(&amp;flag)</u></td></tr>
<tr><th id="279">279</th><td><u>#else</u></td></tr>
<tr><th id="280">280</th><td><u>#define ABSL_FLAG_IMPL_REGISTRAR(T, flag) \</u></td></tr>
<tr><th id="281">281</th><td><u>  absl::flags_internal::FlagRegistrar&lt;T, false&gt;(flag.GetImpl())</u></td></tr>
<tr><th id="282">282</th><td><u>#endif</u></td></tr>
<tr><th id="283">283</th><td><u>#<span data-ppcond="273">else</span></u></td></tr>
<tr><th id="284">284</th><td><u>#define <dfn class="macro" id="_M/ABSL_FLAG_IMPL_FLAGNAME" data-ref="_M/ABSL_FLAG_IMPL_FLAGNAME">ABSL_FLAG_IMPL_FLAGNAME</dfn>(txt) txt</u></td></tr>
<tr><th id="285">285</th><td><u>#define <dfn class="macro" id="_M/ABSL_FLAG_IMPL_FILENAME" data-ref="_M/ABSL_FLAG_IMPL_FILENAME">ABSL_FLAG_IMPL_FILENAME</dfn>() __FILE__</u></td></tr>
<tr><th id="286">286</th><td><u>#<span data-ppcond="286">if</span> !defined(<span class="macro" data-ref="_M/_MSC_VER">_MSC_VER</span>) || defined(<span class="macro" data-ref="_M/__clang__">__clang__</span>)</u></td></tr>
<tr><th id="287">287</th><td><u>#define <dfn class="macro" id="_M/ABSL_FLAG_IMPL_REGISTRAR" data-ref="_M/ABSL_FLAG_IMPL_REGISTRAR">ABSL_FLAG_IMPL_REGISTRAR</dfn>(T, flag) \</u></td></tr>
<tr><th id="288">288</th><td><u>  absl::flags_internal::FlagRegistrar&lt;T, true&gt;(&amp;flag)</u></td></tr>
<tr><th id="289">289</th><td><u>#<span data-ppcond="286">else</span></u></td></tr>
<tr><th id="290">290</th><td><u>#define ABSL_FLAG_IMPL_REGISTRAR(T, flag) \</u></td></tr>
<tr><th id="291">291</th><td><u>  absl::flags_internal::FlagRegistrar&lt;T, true&gt;(flag.GetImpl())</u></td></tr>
<tr><th id="292">292</th><td><u>#<span data-ppcond="286">endif</span></u></td></tr>
<tr><th id="293">293</th><td><u>#<span data-ppcond="273">endif</span></u></td></tr>
<tr><th id="294">294</th><td></td></tr>
<tr><th id="295">295</th><td><i>// ABSL_FLAG_IMPL macro definition conditional on ABSL_FLAGS_STRIP_HELP</i></td></tr>
<tr><th id="296">296</th><td></td></tr>
<tr><th id="297">297</th><td><u>#<span data-ppcond="297">if</span> <a class="macro" href="config.h.html#45" title="0" data-ref="_M/ABSL_FLAGS_STRIP_HELP">ABSL_FLAGS_STRIP_HELP</a></u></td></tr>
<tr><th id="298">298</th><td><u>#define ABSL_FLAG_IMPL_FLAGHELP(txt) absl::flags_internal::kStrippedFlagHelp</u></td></tr>
<tr><th id="299">299</th><td><u>#<span data-ppcond="297">else</span></u></td></tr>
<tr><th id="300">300</th><td><u>#define <dfn class="macro" id="_M/ABSL_FLAG_IMPL_FLAGHELP" data-ref="_M/ABSL_FLAG_IMPL_FLAGHELP">ABSL_FLAG_IMPL_FLAGHELP</dfn>(txt) txt</u></td></tr>
<tr><th id="301">301</th><td><u>#<span data-ppcond="297">endif</span></u></td></tr>
<tr><th id="302">302</th><td></td></tr>
<tr><th id="303">303</th><td><i>// AbslFlagHelpGenFor##name is used to encapsulate both immediate (method Const)</i></td></tr>
<tr><th id="304">304</th><td><i>// and lazy (method NonConst) evaluation of help message expression. We choose</i></td></tr>
<tr><th id="305">305</th><td><i>// between the two via the call to HelpArg in absl::Flag instantiation below.</i></td></tr>
<tr><th id="306">306</th><td><i>// If help message expression is constexpr evaluable compiler will optimize</i></td></tr>
<tr><th id="307">307</th><td><i>// away this whole struct.</i></td></tr>
<tr><th id="308">308</th><td><u>#define <dfn class="macro" id="_M/ABSL_FLAG_IMPL_DECLARE_HELP_WRAPPER" data-ref="_M/ABSL_FLAG_IMPL_DECLARE_HELP_WRAPPER">ABSL_FLAG_IMPL_DECLARE_HELP_WRAPPER</dfn>(name, txt)                     \</u></td></tr>
<tr><th id="309">309</th><td><u>  struct AbslFlagHelpGenFor##name {                                        \</u></td></tr>
<tr><th id="310">310</th><td><u>    template &lt;typename T = void&gt;                                           \</u></td></tr>
<tr><th id="311">311</th><td><u>    static constexpr const char* Const() {                                 \</u></td></tr>
<tr><th id="312">312</th><td><u>      return absl::flags_internal::HelpConstexprWrap(                      \</u></td></tr>
<tr><th id="313">313</th><td><u>          ABSL_FLAG_IMPL_FLAGHELP(txt));                                   \</u></td></tr>
<tr><th id="314">314</th><td><u>    }                                                                      \</u></td></tr>
<tr><th id="315">315</th><td><u>    static std::string NonConst() { return ABSL_FLAG_IMPL_FLAGHELP(txt); } \</u></td></tr>
<tr><th id="316">316</th><td><u>  }</u></td></tr>
<tr><th id="317">317</th><td></td></tr>
<tr><th id="318">318</th><td><u>#define <dfn class="macro" id="_M/ABSL_FLAG_IMPL_DECLARE_DEF_VAL_WRAPPER" data-ref="_M/ABSL_FLAG_IMPL_DECLARE_DEF_VAL_WRAPPER">ABSL_FLAG_IMPL_DECLARE_DEF_VAL_WRAPPER</dfn>(name, Type, default_value)   \</u></td></tr>
<tr><th id="319">319</th><td><u>  static void* AbslFlagsInitFlag##name() {                                  \</u></td></tr>
<tr><th id="320">320</th><td><u>    return absl::flags_internal::MakeFromDefaultValue&lt;Type&gt;(default_value); \</u></td></tr>
<tr><th id="321">321</th><td><u>  }</u></td></tr>
<tr><th id="322">322</th><td></td></tr>
<tr><th id="323">323</th><td><i>// ABSL_FLAG_IMPL</i></td></tr>
<tr><th id="324">324</th><td><i>//</i></td></tr>
<tr><th id="325">325</th><td><i>// Note: Name of registrar object is not arbitrary. It is used to "grab"</i></td></tr>
<tr><th id="326">326</th><td><i>// global name for FLAGS_no&lt;flag_name&gt; symbol, thus preventing the possibility</i></td></tr>
<tr><th id="327">327</th><td><i>// of defining two flags with names foo and nofoo.</i></td></tr>
<tr><th id="328">328</th><td><u>#<span data-ppcond="328">if</span> !defined(<span class="macro" data-ref="_M/_MSC_VER">_MSC_VER</span>) || defined(<span class="macro" data-ref="_M/__clang__">__clang__</span>)</u></td></tr>
<tr><th id="329">329</th><td><u>#define <dfn class="macro" id="_M/ABSL_FLAG_IMPL" data-ref="_M/ABSL_FLAG_IMPL">ABSL_FLAG_IMPL</dfn>(Type, name, default_value, help)             \</u></td></tr>
<tr><th id="330">330</th><td><u>  namespace absl /* block flags in namespaces */ {}                 \</u></td></tr>
<tr><th id="331">331</th><td><u>  ABSL_FLAG_IMPL_DECLARE_DEF_VAL_WRAPPER(name, Type, default_value) \</u></td></tr>
<tr><th id="332">332</th><td><u>  ABSL_FLAG_IMPL_DECLARE_HELP_WRAPPER(name, help);                  \</u></td></tr>
<tr><th id="333">333</th><td><u>  ABSL_CONST_INIT absl::Flag&lt;Type&gt; FLAGS_##name{                    \</u></td></tr>
<tr><th id="334">334</th><td><u>      ABSL_FLAG_IMPL_FLAGNAME(#name), ABSL_FLAG_IMPL_FILENAME(),    \</u></td></tr>
<tr><th id="335">335</th><td><u>      absl::flags_internal::HelpArg&lt;AbslFlagHelpGenFor##name&gt;(0),   \</u></td></tr>
<tr><th id="336">336</th><td><u>      &amp;AbslFlagsInitFlag##name};                                    \</u></td></tr>
<tr><th id="337">337</th><td><u>  extern bool FLAGS_no##name;                                       \</u></td></tr>
<tr><th id="338">338</th><td><u>  bool FLAGS_no##name = ABSL_FLAG_IMPL_REGISTRAR(Type, FLAGS_##name)</u></td></tr>
<tr><th id="339">339</th><td><u>#<span data-ppcond="328">else</span></u></td></tr>
<tr><th id="340">340</th><td><i>// MSVC version uses aggregate initialization. We also do not try to</i></td></tr>
<tr><th id="341">341</th><td><i>// optimize away help wrapper.</i></td></tr>
<tr><th id="342">342</th><td><u>#define ABSL_FLAG_IMPL(Type, name, default_value, help)               \</u></td></tr>
<tr><th id="343">343</th><td><u>  namespace absl /* block flags in namespaces */ {}                   \</u></td></tr>
<tr><th id="344">344</th><td><u>  ABSL_FLAG_IMPL_DECLARE_DEF_VAL_WRAPPER(name, Type, default_value)   \</u></td></tr>
<tr><th id="345">345</th><td><u>  ABSL_FLAG_IMPL_DECLARE_HELP_WRAPPER(name, help);                    \</u></td></tr>
<tr><th id="346">346</th><td><u>  ABSL_CONST_INIT absl::Flag&lt;Type&gt; FLAGS_##name{                      \</u></td></tr>
<tr><th id="347">347</th><td><u>      ABSL_FLAG_IMPL_FLAGNAME(#name), ABSL_FLAG_IMPL_FILENAME(),      \</u></td></tr>
<tr><th id="348">348</th><td><u>      &amp;AbslFlagHelpGenFor##name::NonConst, &amp;AbslFlagsInitFlag##name}; \</u></td></tr>
<tr><th id="349">349</th><td><u>  extern bool FLAGS_no##name;                                         \</u></td></tr>
<tr><th id="350">350</th><td><u>  bool FLAGS_no##name = ABSL_FLAG_IMPL_REGISTRAR(Type, FLAGS_##name)</u></td></tr>
<tr><th id="351">351</th><td><u>#<span data-ppcond="328">endif</span></u></td></tr>
<tr><th id="352">352</th><td></td></tr>
<tr><th id="353">353</th><td><i>// ABSL_RETIRED_FLAG</i></td></tr>
<tr><th id="354">354</th><td><i>//</i></td></tr>
<tr><th id="355">355</th><td><i>// Designates the flag (which is usually pre-existing) as "retired." A retired</i></td></tr>
<tr><th id="356">356</th><td><i>// flag is a flag that is now unused by the program, but may still be passed on</i></td></tr>
<tr><th id="357">357</th><td><i>// the command line, usually by production scripts. A retired flag is ignored</i></td></tr>
<tr><th id="358">358</th><td><i>// and code can't access it at runtime.</i></td></tr>
<tr><th id="359">359</th><td><i>//</i></td></tr>
<tr><th id="360">360</th><td><i>// This macro registers a retired flag with given name and type, with a name</i></td></tr>
<tr><th id="361">361</th><td><i>// identical to the name of the original flag you are retiring. The retired</i></td></tr>
<tr><th id="362">362</th><td><i>// flag's type can change over time, so that you can retire code to support a</i></td></tr>
<tr><th id="363">363</th><td><i>// custom flag type.</i></td></tr>
<tr><th id="364">364</th><td><i>//</i></td></tr>
<tr><th id="365">365</th><td><i>// This macro has the same signature as `ABSL_FLAG`. To retire a flag, simply</i></td></tr>
<tr><th id="366">366</th><td><i>// replace an `ABSL_FLAG` definition with `ABSL_RETIRED_FLAG`, leaving the</i></td></tr>
<tr><th id="367">367</th><td><i>// arguments unchanged (unless of course you actually want to retire the flag</i></td></tr>
<tr><th id="368">368</th><td><i>// type at this time as well).</i></td></tr>
<tr><th id="369">369</th><td><i>//</i></td></tr>
<tr><th id="370">370</th><td><i>// `default_value` is only used as a double check on the type. `explanation` is</i></td></tr>
<tr><th id="371">371</th><td><i>// unused.</i></td></tr>
<tr><th id="372">372</th><td><i>// TODO(rogeeff): Return an anonymous struct instead of bool, and place it into</i></td></tr>
<tr><th id="373">373</th><td><i>// the unnamed namespace.</i></td></tr>
<tr><th id="374">374</th><td><u>#define <dfn class="macro" id="_M/ABSL_RETIRED_FLAG" data-ref="_M/ABSL_RETIRED_FLAG">ABSL_RETIRED_FLAG</dfn>(type, flagname, default_value, explanation) \</u></td></tr>
<tr><th id="375">375</th><td><u>  ABSL_ATTRIBUTE_UNUSED static const bool ignored_##flagname =        \</u></td></tr>
<tr><th id="376">376</th><td><u>      ([] { return type(default_value); },                            \</u></td></tr>
<tr><th id="377">377</th><td><u>       absl::flags_internal::RetiredFlag&lt;type&gt;(#flagname))</u></td></tr>
<tr><th id="378">378</th><td></td></tr>
<tr><th id="379">379</th><td><u>#<span data-ppcond="29">endif</span>  // ABSL_FLAGS_FLAG_H_</u></td></tr>
<tr><th id="380">380</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='flag.cc.html'>halide/build-apps/abseil-cpp/absl/flags/flag.cc</a><br/>Generated on <em>2021-Aug-05</em> from project halide revision <em>v12.0.1</em>