<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>block_map.h source code [halide/build-apps/ruy/ruy/block_map.h] - Woboq Code Browser</title>
<meta name="woboq:interestingDefinitions" content="ruy::BlockMap,ruy::BlockMapTraversalOrder "/>
<link rel="stylesheet" href="../../../.././data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../.././data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../.././data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../.././data/jquery/jquery-ui.min.js"></script>
<script>var file = 'halide/build-apps/ruy/ruy/block_map.h'; var root_path = '../../../..'; var data_path = '../../../.././data'; var ecma_script_api_version = 2;</script>
<script src='../../../.././data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../..'>halide</a>/<a href='../..'>build-apps</a>/<a href='..'>ruy</a>/<a href='./'>ruy</a>/<a href='block_map.h.html'>block_map.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/* Copyright 2019 Google LLC. All Rights Reserved.</i></td></tr>
<tr><th id="2">2</th><td><i></i></td></tr>
<tr><th id="3">3</th><td><i>Licensed under the Apache License, Version 2.0 (the "License");</i></td></tr>
<tr><th id="4">4</th><td><i>you may not use this file except in compliance with the License.</i></td></tr>
<tr><th id="5">5</th><td><i>You may obtain a copy of the License at</i></td></tr>
<tr><th id="6">6</th><td><i></i></td></tr>
<tr><th id="7">7</th><td><i>    <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></i></td></tr>
<tr><th id="8">8</th><td><i></i></td></tr>
<tr><th id="9">9</th><td><i>Unless required by applicable law or agreed to in writing, software</i></td></tr>
<tr><th id="10">10</th><td><i>distributed under the License is distributed on an "AS IS" BASIS,</i></td></tr>
<tr><th id="11">11</th><td><i>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i></td></tr>
<tr><th id="12">12</th><td><i>See the License for the specific language governing permissions and</i></td></tr>
<tr><th id="13">13</th><td><i>limitations under the License.</i></td></tr>
<tr><th id="14">14</th><td><i>==============================================================================*/</i></td></tr>
<tr><th id="15">15</th><td></td></tr>
<tr><th id="16">16</th><td><u>#<span data-ppcond="16">ifndef</span> <span class="macro" data-ref="_M/RUY_RUY_BLOCK_MAP_H_">RUY_RUY_BLOCK_MAP_H_</span></u></td></tr>
<tr><th id="17">17</th><td><u>#define <dfn class="macro" id="_M/RUY_RUY_BLOCK_MAP_H_" data-ref="_M/RUY_RUY_BLOCK_MAP_H_">RUY_RUY_BLOCK_MAP_H_</dfn></u></td></tr>
<tr><th id="18">18</th><td></td></tr>
<tr><th id="19">19</th><td><u>#include <a href="cpu_cache_params.h.html">"ruy/cpu_cache_params.h"</a></u></td></tr>
<tr><th id="20">20</th><td><u>#include <a href="side_pair.h.html">"ruy/side_pair.h"</a></u></td></tr>
<tr><th id="21">21</th><td></td></tr>
<tr><th id="22">22</th><td><b>namespace</b> <span class="namespace">ruy</span> {</td></tr>
<tr><th id="23">23</th><td></td></tr>
<tr><th id="24">24</th><td><b>enum</b> <b>class</b> <dfn class="type def" id="ruy::BlockMapTraversalOrder" title='ruy::BlockMapTraversalOrder' data-ref="ruy::BlockMapTraversalOrder" data-ref-filename="ruy..BlockMapTraversalOrder">BlockMapTraversalOrder</dfn> {</td></tr>
<tr><th id="25">25</th><td>  <i>// Plain old row-by-row or column-by-column traversal.</i></td></tr>
<tr><th id="26">26</th><td>  <dfn class="enum" id="ruy::BlockMapTraversalOrder::kLinear" title='ruy::BlockMapTraversalOrder::kLinear' data-ref="ruy::BlockMapTraversalOrder::kLinear" data-ref-filename="ruy..BlockMapTraversalOrder..kLinear">kLinear</dfn>,</td></tr>
<tr><th id="27">27</th><td>  <i>// Fractal Z-order curve, <a href="https://en.wikipedia.org/wiki/Z-order_curve">https://en.wikipedia.org/wiki/Z-order_curve</a></i></td></tr>
<tr><th id="28">28</th><td>  <dfn class="enum" id="ruy::BlockMapTraversalOrder::kFractalZ" title='ruy::BlockMapTraversalOrder::kFractalZ' data-ref="ruy::BlockMapTraversalOrder::kFractalZ" data-ref-filename="ruy..BlockMapTraversalOrder..kFractalZ">kFractalZ</dfn>,</td></tr>
<tr><th id="29">29</th><td>  <i>// Variant of Z-order doing a U instead of a Z.</i></td></tr>
<tr><th id="30">30</th><td>  <dfn class="enum" id="ruy::BlockMapTraversalOrder::kFractalU" title='ruy::BlockMapTraversalOrder::kFractalU' data-ref="ruy::BlockMapTraversalOrder::kFractalU" data-ref-filename="ruy..BlockMapTraversalOrder..kFractalU">kFractalU</dfn>,</td></tr>
<tr><th id="31">31</th><td>  <i>// Hilbert curve, <a href="https://en.wikipedia.org/wiki/Hilbert_curve">https://en.wikipedia.org/wiki/Hilbert_curve</a></i></td></tr>
<tr><th id="32">32</th><td>  <dfn class="enum" id="ruy::BlockMapTraversalOrder::kFractalHilbert" title='ruy::BlockMapTraversalOrder::kFractalHilbert' data-ref="ruy::BlockMapTraversalOrder::kFractalHilbert" data-ref-filename="ruy..BlockMapTraversalOrder..kFractalHilbert">kFractalHilbert</dfn></td></tr>
<tr><th id="33">33</th><td>};</td></tr>
<tr><th id="34">34</th><td></td></tr>
<tr><th id="35">35</th><td><i>// A BlockMap describes a tiling of a matrix, typically the destination matrix</i></td></tr>
<tr><th id="36">36</th><td><i>// of a matrix multiplication computation. As is standard in matrix</i></td></tr>
<tr><th id="37">37</th><td><i>// multiplication, a tile is called a "block".</i></td></tr>
<tr><th id="38">38</th><td><i>//</i></td></tr>
<tr><th id="39">39</th><td><i>// Ruy subdivides work by blocks of the destination matrix: each thread fully</i></td></tr>
<tr><th id="40">40</th><td><i>// computes a block at once, then moves on to another block; each block is</i></td></tr>
<tr><th id="41">41</th><td><i>// produced by a single thread.</i></td></tr>
<tr><th id="42">42</th><td><i>//</i></td></tr>
<tr><th id="43">43</th><td><i>// This ensures that the workloads for each block are mutually independent,</i></td></tr>
<tr><th id="44">44</th><td><i>// which reduces synchronization requirements.</i></td></tr>
<tr><th id="45">45</th><td><i>//</i></td></tr>
<tr><th id="46">46</th><td><i>// Typically, a matrix multiplication will early on create a BlockMap by</i></td></tr>
<tr><th id="47">47</th><td><i>// calling MakeBlockMap. It will then query the number of blocks in that</i></td></tr>
<tr><th id="48">48</th><td><i>// BlockMap by calling NumBlocks. It will then create a single atomic integer</i></td></tr>
<tr><th id="49">49</th><td><i>// counter indexing these blocks, called the 'index', and will distribute</i></td></tr>
<tr><th id="50">50</th><td><i>// work to its N threads by ensuring that each thread works on disjoint sets</i></td></tr>
<tr><th id="51">51</th><td><i>// of index values. For a given index value, the thread will call</i></td></tr>
<tr><th id="52">52</th><td><i>// GetBlockByIndex to get the corresponding block, then GetBlockMatrixCoords</i></td></tr>
<tr><th id="53">53</th><td><i>// to find the actual row and column numbers of this block.</i></td></tr>
<tr><th id="54">54</th><td><i>//</i></td></tr>
<tr><th id="55">55</th><td><i>// There are two nested levels of subdivision. On a local level, the matrix is</i></td></tr>
<tr><th id="56">56</th><td><i>// tiled into a square NxN grid where N is a power of two, specifically:</i></td></tr>
<tr><th id="57">57</th><td><i>//   N = 2^num_blocks_base_log2.</i></td></tr>
<tr><th id="58">58</th><td><i>//</i></td></tr>
<tr><th id="59">59</th><td><i>// At a larger scale, around these blocks, there may be one further</i></td></tr>
<tr><th id="60">60</th><td><i>// level of subdivision, in only one dimension: either along rows or along</i></td></tr>
<tr><th id="61">61</th><td><i>// columns. That is used to handle arbitrarily rectangular matrices. The</i></td></tr>
<tr><th id="62">62</th><td><i>// aforementioned high-level block grid is square, so it does not readily fit</i></td></tr>
<tr><th id="63">63</th><td><i>// well very rectangular matrices.</i></td></tr>
<tr><th id="64">64</th><td><i>//</i></td></tr>
<tr><th id="65">65</th><td><i>// Taking together these two nested levels of subdivision, the effective</i></td></tr>
<tr><th id="66">66</th><td><i>// tiling is by</i></td></tr>
<tr><th id="67">67</th><td><i>//   2^(num_blocks_base_log2 + rows_rectangularness_log2)</i></td></tr>
<tr><th id="68">68</th><td><i>// blocks in the row dimension, and by</i></td></tr>
<tr><th id="69">69</th><td><i>//   2^(num_blocks_base_log2 + cols_rectangularness_log2)</i></td></tr>
<tr><th id="70">70</th><td><i>// blocks in the column dimension. See NumBlocksOfRows, NumBlocksOfCols.</i></td></tr>
<tr><th id="71">71</th><td><i>//</i></td></tr>
<tr><th id="72">72</th><td><i>// Either rows_rectangularness_log2 or cols_rectangularness_log2 must be zero.</i></td></tr>
<tr><th id="73">73</th><td><i>//</i></td></tr>
<tr><th id="74">74</th><td><i>// Finally, this BlockMap is designed to operate under alignment constraints:</i></td></tr>
<tr><th id="75">75</th><td><i>// two fields, kernel_rows and kernel_cols, describe the requested alignment</i></td></tr>
<tr><th id="76">76</th><td><i>// of the effective grid in both dimensions. The idea is to feed matrix</i></td></tr>
<tr><th id="77">77</th><td><i>// multiplication kernels with tiles that fit their width as much as possible.</i></td></tr>
<tr><th id="78">78</th><td><i>// Of course, if rows (resp. cols) is not a multiple of kernel_rows (resp.</i></td></tr>
<tr><th id="79">79</th><td><i>// kernel_cols) then some tile will have to have unaligned size. BlockMap</i></td></tr>
<tr><th id="80">80</th><td><i>// will only allow that to happen in the last position along each axis, so</i></td></tr>
<tr><th id="81">81</th><td><i>// as to minimize the overhead incurred onto the matrix multiplication kernels.</i></td></tr>
<tr><th id="82">82</th><td><b>struct</b> <dfn class="type def" id="ruy::BlockMap" title='ruy::BlockMap' data-ref="ruy::BlockMap" data-ref-filename="ruy..BlockMap">BlockMap</dfn> {</td></tr>
<tr><th id="83">83</th><td>  <i>// The number of threads to use (to distribute the blocks to).</i></td></tr>
<tr><th id="84">84</th><td>  <em>int</em> <dfn class="decl field" id="ruy::BlockMap::thread_count" title='ruy::BlockMap::thread_count' data-ref="ruy::BlockMap::thread_count" data-ref-filename="ruy..BlockMap..thread_count">thread_count</dfn>;</td></tr>
<tr><th id="85">85</th><td>  <i>// The order in which to traverse the matrix of which this BlockMap represents</i></td></tr>
<tr><th id="86">86</th><td><i>  // a tiling (hereafter "the matrix").</i></td></tr>
<tr><th id="87">87</th><td>  <a class="type" href="#ruy::BlockMapTraversalOrder" title='ruy::BlockMapTraversalOrder' data-ref="ruy::BlockMapTraversalOrder" data-ref-filename="ruy..BlockMapTraversalOrder">BlockMapTraversalOrder</a> <dfn class="decl field" id="ruy::BlockMap::traversal_order" title='ruy::BlockMap::traversal_order' data-ref="ruy::BlockMap::traversal_order" data-ref-filename="ruy..BlockMap..traversal_order">traversal_order</dfn>;</td></tr>
<tr><th id="88">88</th><td>  <i>// The dimensions of the block_map, that is, of the destination</i></td></tr>
<tr><th id="89">89</th><td><i>  // matrix rounded up to next multiples of kernel_dims.</i></td></tr>
<tr><th id="90">90</th><td>  <a class="type" href="side_pair.h.html#ruy::SidePair" title='ruy::SidePair' data-ref="ruy::SidePair" data-ref-filename="ruy..SidePair">SidePair</a>&lt;<em>int</em>&gt; <dfn class="decl field" id="ruy::BlockMap::dims" title='ruy::BlockMap::dims' data-ref="ruy::BlockMap::dims" data-ref-filename="ruy..BlockMap..dims">dims</dfn>;</td></tr>
<tr><th id="91">91</th><td>  <i>// Log2 of the minimum number of subdivisions of the grid along either axis.</i></td></tr>
<tr><th id="92">92</th><td>  <em>int</em> <dfn class="decl field" id="ruy::BlockMap::num_blocks_base_log2" title='ruy::BlockMap::num_blocks_base_log2' data-ref="ruy::BlockMap::num_blocks_base_log2" data-ref-filename="ruy..BlockMap..num_blocks_base_log2">num_blocks_base_log2</dfn>;</td></tr>
<tr><th id="93">93</th><td>  <i>// Log2 of the additional subdivision of the rows/columns axis.</i></td></tr>
<tr><th id="94">94</th><td>  <a class="type" href="side_pair.h.html#ruy::SidePair" title='ruy::SidePair' data-ref="ruy::SidePair" data-ref-filename="ruy..SidePair">SidePair</a>&lt;<em>int</em>&gt; <dfn class="decl field" id="ruy::BlockMap::rectangularness_log2" title='ruy::BlockMap::rectangularness_log2' data-ref="ruy::BlockMap::rectangularness_log2" data-ref-filename="ruy..BlockMap..rectangularness_log2">rectangularness_log2</dfn>;</td></tr>
<tr><th id="95">95</th><td>  <i>// Requested alignment of the subdivisions of the grid along the rows/columns</i></td></tr>
<tr><th id="96">96</th><td><i>  // axis.</i></td></tr>
<tr><th id="97">97</th><td>  <a class="type" href="side_pair.h.html#ruy::SidePair" title='ruy::SidePair' data-ref="ruy::SidePair" data-ref-filename="ruy..SidePair">SidePair</a>&lt;<em>int</em>&gt; <dfn class="decl field" id="ruy::BlockMap::kernel_dims" title='ruy::BlockMap::kernel_dims' data-ref="ruy::BlockMap::kernel_dims" data-ref-filename="ruy..BlockMap..kernel_dims">kernel_dims</dfn>;</td></tr>
<tr><th id="98">98</th><td>  <i>// Internal helper. Minimum number of rows/columns in each block.</i></td></tr>
<tr><th id="99">99</th><td>  <a class="type" href="side_pair.h.html#ruy::SidePair" title='ruy::SidePair' data-ref="ruy::SidePair" data-ref-filename="ruy..SidePair">SidePair</a>&lt;<em>int</em>&gt; <dfn class="decl field" id="ruy::BlockMap::small_block_dims" title='ruy::BlockMap::small_block_dims' data-ref="ruy::BlockMap::small_block_dims" data-ref-filename="ruy..BlockMap..small_block_dims">small_block_dims</dfn>;</td></tr>
<tr><th id="100">100</th><td>  <i>// Internal helper. Number of blocks along each dimension that need to have</i></td></tr>
<tr><th id="101">101</th><td><i>  // their size in that dimension be given by (small_block_dims + kernel_dims)</i></td></tr>
<tr><th id="102">102</th><td><i>  // instead of just small_block_dims.</i></td></tr>
<tr><th id="103">103</th><td>  <a class="type" href="side_pair.h.html#ruy::SidePair" title='ruy::SidePair' data-ref="ruy::SidePair" data-ref-filename="ruy..SidePair">SidePair</a>&lt;<em>int</em>&gt; <dfn class="decl field" id="ruy::BlockMap::large_blocks" title='ruy::BlockMap::large_blocks' data-ref="ruy::BlockMap::large_blocks" data-ref-filename="ruy..BlockMap..large_blocks">large_blocks</dfn>;</td></tr>
<tr><th id="104">104</th><td>};</td></tr>
<tr><th id="105">105</th><td></td></tr>
<tr><th id="106">106</th><td><i>// This function produces a coarse estimate of whether linear traversal will</i></td></tr>
<tr><th id="107">107</th><td><i>// be used for this matmul. It offers a one-way guarantee: if this function</i></td></tr>
<tr><th id="108">108</th><td><i>// returns true then linear traversal will be used.</i></td></tr>
<tr><th id="109">109</th><td><i>//</i></td></tr>
<tr><th id="110">110</th><td><i>// The purpose of this function is to allow TrMul to make a cheap, early</i></td></tr>
<tr><th id="111">111</th><td><i>// decision to enter a "simple loop" code path for simple cases.</i></td></tr>
<tr><th id="112">112</th><td><em>bool</em> <a class="decl fn" href="block_map.cc.html#_ZN3ruy26IsObviouslyLinearTraversalEiiiiiRKNS_14CpuCacheParamsE" title='ruy::IsObviouslyLinearTraversal' data-ref="_ZN3ruy26IsObviouslyLinearTraversalEiiiiiRKNS_14CpuCacheParamsE" data-ref-filename="_ZN3ruy26IsObviouslyLinearTraversalEiiiiiRKNS_14CpuCacheParamsE" id="_ZN3ruy26IsObviouslyLinearTraversalEiiiiiRKNS_14CpuCacheParamsE">IsObviouslyLinearTraversal</a>(<em>int</em> <dfn class="local col1 decl" id="1rows" title='rows' data-type='int' data-ref="1rows" data-ref-filename="1rows">rows</dfn>, <em>int</em> <dfn class="local col2 decl" id="2cols" title='cols' data-type='int' data-ref="2cols" data-ref-filename="2cols">cols</dfn>, <em>int</em> <dfn class="local col3 decl" id="3depth" title='depth' data-type='int' data-ref="3depth" data-ref-filename="3depth">depth</dfn>,</td></tr>
<tr><th id="113">113</th><td>                                <em>int</em> <dfn class="local col4 decl" id="4lhs_scalar_size" title='lhs_scalar_size' data-type='int' data-ref="4lhs_scalar_size" data-ref-filename="4lhs_scalar_size">lhs_scalar_size</dfn>, <em>int</em> <dfn class="local col5 decl" id="5rhs_scalar_size" title='rhs_scalar_size' data-type='int' data-ref="5rhs_scalar_size" data-ref-filename="5rhs_scalar_size">rhs_scalar_size</dfn>,</td></tr>
<tr><th id="114">114</th><td>                                <em>const</em> <a class="type" href="cpu_cache_params.h.html#ruy::CpuCacheParams" title='ruy::CpuCacheParams' data-ref="ruy::CpuCacheParams" data-ref-filename="ruy..CpuCacheParams">CpuCacheParams</a>&amp; <dfn class="local col6 decl" id="6cpu_cache_params" title='cpu_cache_params' data-type='const ruy::CpuCacheParams &amp;' data-ref="6cpu_cache_params" data-ref-filename="6cpu_cache_params">cpu_cache_params</dfn>);</td></tr>
<tr><th id="115">115</th><td></td></tr>
<tr><th id="116">116</th><td><i>// Create a BlockMap suitable for tiling the destination matrix in a</i></td></tr>
<tr><th id="117">117</th><td><i>// matrix multiplication with the given parameters.</i></td></tr>
<tr><th id="118">118</th><td><em>void</em> <a class="decl fn" href="block_map.cc.html#_ZN3ruy12MakeBlockMapEiiiiiiiiRKNS_14CpuCacheParamsEPNS_8BlockMapE" title='ruy::MakeBlockMap' data-ref="_ZN3ruy12MakeBlockMapEiiiiiiiiRKNS_14CpuCacheParamsEPNS_8BlockMapE" data-ref-filename="_ZN3ruy12MakeBlockMapEiiiiiiiiRKNS_14CpuCacheParamsEPNS_8BlockMapE" id="_ZN3ruy12MakeBlockMapEiiiiiiiiRKNS_14CpuCacheParamsEPNS_8BlockMapE">MakeBlockMap</a>(<em>int</em> <dfn class="local col7 decl" id="7rows" title='rows' data-type='int' data-ref="7rows" data-ref-filename="7rows">rows</dfn>, <em>int</em> <dfn class="local col8 decl" id="8cols" title='cols' data-type='int' data-ref="8cols" data-ref-filename="8cols">cols</dfn>, <em>int</em> <dfn class="local col9 decl" id="9depth" title='depth' data-type='int' data-ref="9depth" data-ref-filename="9depth">depth</dfn>, <em>int</em> <dfn class="local col0 decl" id="10kernel_rows" title='kernel_rows' data-type='int' data-ref="10kernel_rows" data-ref-filename="10kernel_rows">kernel_rows</dfn>,</td></tr>
<tr><th id="119">119</th><td>                  <em>int</em> <dfn class="local col1 decl" id="11kernel_cols" title='kernel_cols' data-type='int' data-ref="11kernel_cols" data-ref-filename="11kernel_cols">kernel_cols</dfn>, <em>int</em> <dfn class="local col2 decl" id="12lhs_scalar_size" title='lhs_scalar_size' data-type='int' data-ref="12lhs_scalar_size" data-ref-filename="12lhs_scalar_size">lhs_scalar_size</dfn>, <em>int</em> <dfn class="local col3 decl" id="13rhs_scalar_size" title='rhs_scalar_size' data-type='int' data-ref="13rhs_scalar_size" data-ref-filename="13rhs_scalar_size">rhs_scalar_size</dfn>,</td></tr>
<tr><th id="120">120</th><td>                  <em>int</em> <dfn class="local col4 decl" id="14tentative_thread_count" title='tentative_thread_count' data-type='int' data-ref="14tentative_thread_count" data-ref-filename="14tentative_thread_count">tentative_thread_count</dfn>,</td></tr>
<tr><th id="121">121</th><td>                  <em>const</em> <a class="type" href="cpu_cache_params.h.html#ruy::CpuCacheParams" title='ruy::CpuCacheParams' data-ref="ruy::CpuCacheParams" data-ref-filename="ruy..CpuCacheParams">CpuCacheParams</a>&amp; <dfn class="local col5 decl" id="15cpu_cache_params" title='cpu_cache_params' data-type='const ruy::CpuCacheParams &amp;' data-ref="15cpu_cache_params" data-ref-filename="15cpu_cache_params">cpu_cache_params</dfn>, <a class="type" href="#ruy::BlockMap" title='ruy::BlockMap' data-ref="ruy::BlockMap" data-ref-filename="ruy..BlockMap">BlockMap</a>* <dfn class="local col6 decl" id="16block_map" title='block_map' data-type='ruy::BlockMap *' data-ref="16block_map" data-ref-filename="16block_map">block_map</dfn>);</td></tr>
<tr><th id="122">122</th><td></td></tr>
<tr><th id="123">123</th><td><i>// Maps an integer index to a block position in the grid.</i></td></tr>
<tr><th id="124">124</th><td><em>void</em> <a class="decl fn" href="block_map.cc.html#_ZN3ruy15GetBlockByIndexERKNS_8BlockMapEiPNS_8SidePairIiEE" title='ruy::GetBlockByIndex' data-ref="_ZN3ruy15GetBlockByIndexERKNS_8BlockMapEiPNS_8SidePairIiEE" data-ref-filename="_ZN3ruy15GetBlockByIndexERKNS_8BlockMapEiPNS_8SidePairIiEE" id="_ZN3ruy15GetBlockByIndexERKNS_8BlockMapEiPNS_8SidePairIiEE">GetBlockByIndex</a>(<em>const</em> <a class="type" href="#ruy::BlockMap" title='ruy::BlockMap' data-ref="ruy::BlockMap" data-ref-filename="ruy..BlockMap">BlockMap</a>&amp; <dfn class="local col7 decl" id="17block_map" title='block_map' data-type='const ruy::BlockMap &amp;' data-ref="17block_map" data-ref-filename="17block_map">block_map</dfn>, <em>int</em> <dfn class="local col8 decl" id="18index" title='index' data-type='int' data-ref="18index" data-ref-filename="18index">index</dfn>,</td></tr>
<tr><th id="125">125</th><td>                     <a class="type" href="side_pair.h.html#ruy::SidePair" title='ruy::SidePair' data-ref="ruy::SidePair" data-ref-filename="ruy..SidePair">SidePair</a>&lt;<em>int</em>&gt;* <dfn class="local col9 decl" id="19block" title='block' data-type='SidePair&lt;int&gt; *' data-ref="19block" data-ref-filename="19block">block</dfn>);</td></tr>
<tr><th id="126">126</th><td></td></tr>
<tr><th id="127">127</th><td><i>// Given a block position in the grid, returns its actual</i></td></tr>
<tr><th id="128">128</th><td><i>// position in the matrix that the BlockMap refers to in the dimension</i></td></tr>
<tr><th id="129">129</th><td><i>// referred to by `side`: along rows if side==kLhs, along columns if</i></td></tr>
<tr><th id="130">130</th><td><i>// side==kRhs.</i></td></tr>
<tr><th id="131">131</th><td><em>void</em> <a class="decl fn" href="block_map.cc.html#_ZN3ruy20GetBlockMatrixCoordsENS_4SideERKNS_8BlockMapEiPiS4_" title='ruy::GetBlockMatrixCoords' data-ref="_ZN3ruy20GetBlockMatrixCoordsENS_4SideERKNS_8BlockMapEiPiS4_" data-ref-filename="_ZN3ruy20GetBlockMatrixCoordsENS_4SideERKNS_8BlockMapEiPiS4_" id="_ZN3ruy20GetBlockMatrixCoordsENS_4SideERKNS_8BlockMapEiPiS4_">GetBlockMatrixCoords</a>(<a class="type" href="side_pair.h.html#ruy::Side" title='ruy::Side' data-ref="ruy::Side" data-ref-filename="ruy..Side">Side</a> <dfn class="local col0 decl" id="20side" title='side' data-type='ruy::Side' data-ref="20side" data-ref-filename="20side">side</dfn>, <em>const</em> <a class="type" href="#ruy::BlockMap" title='ruy::BlockMap' data-ref="ruy::BlockMap" data-ref-filename="ruy..BlockMap">BlockMap</a>&amp; <dfn class="local col1 decl" id="21block_map" title='block_map' data-type='const ruy::BlockMap &amp;' data-ref="21block_map" data-ref-filename="21block_map">block_map</dfn>, <em>int</em> <dfn class="local col2 decl" id="22block" title='block' data-type='int' data-ref="22block" data-ref-filename="22block">block</dfn>,</td></tr>
<tr><th id="132">132</th><td>                          <em>int</em>* <dfn class="local col3 decl" id="23start" title='start' data-type='int *' data-ref="23start" data-ref-filename="23start">start</dfn>, <em>int</em>* <dfn class="local col4 decl" id="24end" title='end' data-type='int *' data-ref="24end" data-ref-filename="24end">end</dfn>);</td></tr>
<tr><th id="133">133</th><td></td></tr>
<tr><th id="134">134</th><td><i>// Given a block position in the grid, returns its actual</i></td></tr>
<tr><th id="135">135</th><td><i>// position in the matrix that the BlockMap refers to in terms of</i></td></tr>
<tr><th id="136">136</th><td><i>// actual row/column indices.</i></td></tr>
<tr><th id="137">137</th><td><em>void</em> <a class="decl fn" href="block_map.cc.html#_ZN3ruy20GetBlockMatrixCoordsERKNS_8BlockMapERKNS_8SidePairIiEEPS4_S7_" title='ruy::GetBlockMatrixCoords' data-ref="_ZN3ruy20GetBlockMatrixCoordsERKNS_8BlockMapERKNS_8SidePairIiEEPS4_S7_" data-ref-filename="_ZN3ruy20GetBlockMatrixCoordsERKNS_8BlockMapERKNS_8SidePairIiEEPS4_S7_" id="_ZN3ruy20GetBlockMatrixCoordsERKNS_8BlockMapERKNS_8SidePairIiEEPS4_S7_">GetBlockMatrixCoords</a>(<em>const</em> <a class="type" href="#ruy::BlockMap" title='ruy::BlockMap' data-ref="ruy::BlockMap" data-ref-filename="ruy..BlockMap">BlockMap</a>&amp; <dfn class="local col5 decl" id="25block_map" title='block_map' data-type='const ruy::BlockMap &amp;' data-ref="25block_map" data-ref-filename="25block_map">block_map</dfn>, <em>const</em> <a class="type" href="side_pair.h.html#ruy::SidePair" title='ruy::SidePair' data-ref="ruy::SidePair" data-ref-filename="ruy..SidePair">SidePair</a>&lt;<em>int</em>&gt;&amp; <dfn class="local col6 decl" id="26block" title='block' data-type='const SidePair&lt;int&gt; &amp;' data-ref="26block" data-ref-filename="26block">block</dfn>,</td></tr>
<tr><th id="138">138</th><td>                          <a class="type" href="side_pair.h.html#ruy::SidePair" title='ruy::SidePair' data-ref="ruy::SidePair" data-ref-filename="ruy..SidePair">SidePair</a>&lt;<em>int</em>&gt;* <dfn class="local col7 decl" id="27start" title='start' data-type='SidePair&lt;int&gt; *' data-ref="27start" data-ref-filename="27start">start</dfn>, <a class="type" href="side_pair.h.html#ruy::SidePair" title='ruy::SidePair' data-ref="ruy::SidePair" data-ref-filename="ruy..SidePair">SidePair</a>&lt;<em>int</em>&gt;* <dfn class="local col8 decl" id="28end" title='end' data-type='SidePair&lt;int&gt; *' data-ref="28end" data-ref-filename="28end">end</dfn>);</td></tr>
<tr><th id="139">139</th><td></td></tr>
<tr><th id="140">140</th><td><i>// Returns the number of grid subdivisions along the rows dimension (if</i></td></tr>
<tr><th id="141">141</th><td><i>// side == kLhs) or columns dimension (if side == kRhs).</i></td></tr>
<tr><th id="142">142</th><td><b>inline</b> <em>int</em> <dfn class="decl def fn" id="_ZN3ruy16NumBlocksPerSideENS_4SideERKNS_8BlockMapE" title='ruy::NumBlocksPerSide' data-ref="_ZN3ruy16NumBlocksPerSideENS_4SideERKNS_8BlockMapE" data-ref-filename="_ZN3ruy16NumBlocksPerSideENS_4SideERKNS_8BlockMapE">NumBlocksPerSide</dfn>(<a class="type" href="side_pair.h.html#ruy::Side" title='ruy::Side' data-ref="ruy::Side" data-ref-filename="ruy..Side">Side</a> <dfn class="local col9 decl" id="29side" title='side' data-type='ruy::Side' data-ref="29side" data-ref-filename="29side">side</dfn>, <em>const</em> <a class="type" href="#ruy::BlockMap" title='ruy::BlockMap' data-ref="ruy::BlockMap" data-ref-filename="ruy..BlockMap">BlockMap</a>&amp; <dfn class="local col0 decl" id="30block_map" title='block_map' data-type='const ruy::BlockMap &amp;' data-ref="30block_map" data-ref-filename="30block_map">block_map</dfn>) {</td></tr>
<tr><th id="143">143</th><td>  <b>return</b> <var>1</var> &lt;&lt; (<a class="local col0 ref" href="#30block_map" title='block_map' data-ref="30block_map" data-ref-filename="30block_map">block_map</a>.<a class="ref field" href="#ruy::BlockMap::num_blocks_base_log2" title='ruy::BlockMap::num_blocks_base_log2' data-ref="ruy::BlockMap::num_blocks_base_log2" data-ref-filename="ruy..BlockMap..num_blocks_base_log2">num_blocks_base_log2</a> +</td></tr>
<tr><th id="144">144</th><td>               <a class="local col0 ref" href="#30block_map" title='block_map' data-ref="30block_map" data-ref-filename="30block_map">block_map</a>.<a class="ref field" href="#ruy::BlockMap::rectangularness_log2" title='ruy::BlockMap::rectangularness_log2' data-ref="ruy::BlockMap::rectangularness_log2" data-ref-filename="ruy..BlockMap..rectangularness_log2">rectangularness_log2</a><a class="ref fn" href="side_pair.h.html#_ZNK3ruy8SidePairixENS_4SideE" title='ruy::SidePair::operator[]' data-ref="_ZNK3ruy8SidePairixENS_4SideE" data-ref-filename="_ZNK3ruy8SidePairixENS_4SideE">[<a class="local col9 ref" href="#29side" title='side' data-ref="29side" data-ref-filename="29side">side</a>]</a>);</td></tr>
<tr><th id="145">145</th><td>}</td></tr>
<tr><th id="146">146</th><td></td></tr>
<tr><th id="147">147</th><td><i>// Returns the overall number of blocks in</i></td></tr>
<tr><th id="148">148</th><td><i>// the BlockMap. The valid index values to pass to GetBlockByIndex are the</i></td></tr>
<tr><th id="149">149</th><td><i>// integers from 0 to N-1 where N is the value returned here.</i></td></tr>
<tr><th id="150">150</th><td><i>//</i></td></tr>
<tr><th id="151">151</th><td><i>// Note that it is always true that</i></td></tr>
<tr><th id="152">152</th><td><i>//   NumBlocks == NumBlocksOfRows * NumBlocksOfCols</i></td></tr>
<tr><th id="153">153</th><td><i>// because either rows_rectangularness_log2 or cols_rectangularness_log2 is 0.</i></td></tr>
<tr><th id="154">154</th><td><b>inline</b> <em>int</em> <dfn class="decl def fn" id="_ZN3ruy9NumBlocksERKNS_8BlockMapE" title='ruy::NumBlocks' data-ref="_ZN3ruy9NumBlocksERKNS_8BlockMapE" data-ref-filename="_ZN3ruy9NumBlocksERKNS_8BlockMapE">NumBlocks</dfn>(<em>const</em> <a class="type" href="#ruy::BlockMap" title='ruy::BlockMap' data-ref="ruy::BlockMap" data-ref-filename="ruy..BlockMap">BlockMap</a>&amp; <dfn class="local col1 decl" id="31block_map" title='block_map' data-type='const ruy::BlockMap &amp;' data-ref="31block_map" data-ref-filename="31block_map">block_map</dfn>) {</td></tr>
<tr><th id="155">155</th><td>  <b>return</b> <var>1</var> &lt;&lt; (<var>2</var> * <a class="local col1 ref" href="#31block_map" title='block_map' data-ref="31block_map" data-ref-filename="31block_map">block_map</a>.<a class="ref field" href="#ruy::BlockMap::num_blocks_base_log2" title='ruy::BlockMap::num_blocks_base_log2' data-ref="ruy::BlockMap::num_blocks_base_log2" data-ref-filename="ruy..BlockMap..num_blocks_base_log2">num_blocks_base_log2</a> +</td></tr>
<tr><th id="156">156</th><td>               <a class="local col1 ref" href="#31block_map" title='block_map' data-ref="31block_map" data-ref-filename="31block_map">block_map</a>.<a class="ref field" href="#ruy::BlockMap::rectangularness_log2" title='ruy::BlockMap::rectangularness_log2' data-ref="ruy::BlockMap::rectangularness_log2" data-ref-filename="ruy..BlockMap..rectangularness_log2">rectangularness_log2</a><a class="ref fn" href="side_pair.h.html#_ZNK3ruy8SidePairixENS_4SideE" title='ruy::SidePair::operator[]' data-ref="_ZNK3ruy8SidePairixENS_4SideE" data-ref-filename="_ZNK3ruy8SidePairixENS_4SideE">[<a class="type" href="side_pair.h.html#ruy::Side" title='ruy::Side' data-ref="ruy::Side" data-ref-filename="ruy..Side">Side</a>::<a class="enum" href="side_pair.h.html#ruy::Side::kLhs" title='ruy::Side::kLhs' data-ref="ruy::Side::kLhs" data-ref-filename="ruy..Side..kLhs">kLhs</a>]</a> +</td></tr>
<tr><th id="157">157</th><td>               <a class="local col1 ref" href="#31block_map" title='block_map' data-ref="31block_map" data-ref-filename="31block_map">block_map</a>.<a class="ref field" href="#ruy::BlockMap::rectangularness_log2" title='ruy::BlockMap::rectangularness_log2' data-ref="ruy::BlockMap::rectangularness_log2" data-ref-filename="ruy..BlockMap..rectangularness_log2">rectangularness_log2</a><a class="ref fn" href="side_pair.h.html#_ZNK3ruy8SidePairixENS_4SideE" title='ruy::SidePair::operator[]' data-ref="_ZNK3ruy8SidePairixENS_4SideE" data-ref-filename="_ZNK3ruy8SidePairixENS_4SideE">[<a class="type" href="side_pair.h.html#ruy::Side" title='ruy::Side' data-ref="ruy::Side" data-ref-filename="ruy..Side">Side</a>::<a class="enum" href="side_pair.h.html#ruy::Side::kRhs" title='ruy::Side::kRhs' data-ref="ruy::Side::kRhs" data-ref-filename="ruy..Side..kRhs">kRhs</a>]</a>);</td></tr>
<tr><th id="158">158</th><td>}</td></tr>
<tr><th id="159">159</th><td></td></tr>
<tr><th id="160">160</th><td>}  <i>// namespace ruy</i></td></tr>
<tr><th id="161">161</th><td></td></tr>
<tr><th id="162">162</th><td><u>#<span data-ppcond="16">endif</span>  // RUY_RUY_BLOCK_MAP_H_</u></td></tr>
<tr><th id="163">163</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='block_map.cc.html'>halide/build-apps/ruy/ruy/block_map.cc</a><br/>Generated on <em>2021-Aug-05</em> from project halide revision <em>v12.0.1</em>