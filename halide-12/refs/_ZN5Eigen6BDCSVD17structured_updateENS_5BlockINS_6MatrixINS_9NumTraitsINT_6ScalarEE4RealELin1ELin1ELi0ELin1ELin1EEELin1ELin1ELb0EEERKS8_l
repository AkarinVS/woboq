<dec f='halide/build-apps/eigen/Eigen/src/SVD/BDCSVD.h' l='191' type='void Eigen::BDCSVD::structured_update(Block&lt;Eigen::BDCSVD::MatrixXr, Dynamic, Dynamic&gt; A, const Eigen::BDCSVD::MatrixXr &amp; B, Eigen::Index n1)'/>
<def f='halide/build-apps/eigen/Eigen/src/SVD/BDCSVD.h' l='345' ll='384' type='void Eigen::BDCSVD::structured_update(Block&lt;Eigen::BDCSVD::MatrixXr, Dynamic, Dynamic&gt; A, const Eigen::BDCSVD::MatrixXr &amp; B, Eigen::Index n1)'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/BDCSVD.h' l='548' u='c' c='_ZN5Eigen6BDCSVD6divideElllll'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/BDCSVD.h' l='556' u='c' c='_ZN5Eigen6BDCSVD6divideElllll'/>
<doc f='halide/build-apps/eigen/Eigen/src/SVD/BDCSVD.h' l='337'>/** \internal
  * Performs A = A * B exploiting the special structure of the matrix A. Splitting A as:
  *  A = [A1]
  *      [A2]
  * such that A1.rows()==n1, then we assume that at least half of the columns of A1 and A2 are zeros.
  * We can thus pack them prior to the the matrix product. However, this is only worth the effort if the matrix is large
  * enough.
  */</doc>
