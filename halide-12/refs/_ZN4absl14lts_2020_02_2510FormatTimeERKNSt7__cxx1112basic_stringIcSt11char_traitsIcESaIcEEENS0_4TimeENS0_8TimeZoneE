<dec f='halide/build-apps/abseil-cpp/absl/time/time.h' l='1255' type='std::string absl::lts_2020_02_25::FormatTime(const std::string &amp; format, absl::lts_2020_02_25::Time t, absl::lts_2020_02_25::TimeZone tz)'/>
<doc f='halide/build-apps/abseil-cpp/absl/time/time.h' l='1219'>// FormatTime()
//
// Formats the given `absl::Time` in the `absl::TimeZone` according to the
// provided format string. Uses strftime()-like formatting options, with
// the following extensions:
//
//   - %Ez  - RFC3339-compatible numeric UTC offset (+hh:mm or -hh:mm)
//   - %E*z - Full-resolution numeric UTC offset (+hh:mm:ss or -hh:mm:ss)
//   - %E#S - Seconds with # digits of fractional precision
//   - %E*S - Seconds with full fractional precision (a literal &apos;*&apos;)
//   - %E#f - Fractional seconds with # digits of precision
//   - %E*f - Fractional seconds with full precision (a literal &apos;*&apos;)
//   - %E4Y - Four-character years (-999 ... -001, 0000, 0001 ... 9999)
//
// Note that %E0S behaves like %S, and %E0f produces no characters.  In
// contrast %E*f always produces at least one digit, which may be &apos;0&apos;.
//
// Note that %Y produces as many characters as it takes to fully render the
// year.  A year outside of [-999:9999] when formatted with %E4Y will produce
// more than four characters, just like %Y.
//
// We recommend that format strings include the UTC offset (%z, %Ez, or %E*z)
// so that the result uniquely identifies a time instant.
//
// Example:
//
//   absl::CivilSecond cs(2013, 1, 2, 3, 4, 5);
//   absl::Time t = absl::FromCivil(cs, lax);
//   std::string f = absl::FormatTime(&quot;%H:%M:%S&quot;, t, lax);  // &quot;03:04:05&quot;
//   f = absl::FormatTime(&quot;%H:%M:%E3S&quot;, t, lax);  // &quot;03:04:05.000&quot;
//
// Note: If the given `absl::Time` is `absl::InfiniteFuture()`, the returned
// string will be exactly &quot;infinite-future&quot;. If the given `absl::Time` is
// `absl::InfinitePast()`, the returned string will be exactly &quot;infinite-past&quot;.
// In both cases the given format string and `absl::TimeZone` are ignored.
//</doc>
<use f='halide/build-apps/abseil-cpp/absl/time/civil_time.cc' l='43' u='c' c='_ZN4absl14lts_2020_02_2512_GLOBAL__N_113FormatYearAndB5cxx11ENS0_11string_viewENS0_13time_internal4cctz6detail10civil_timeINS3_10second_tagEEE'/>
<def f='halide/build-apps/abseil-cpp/absl/time/format.cc' l='74' ll='81' type='std::string absl::lts_2020_02_25::FormatTime(const std::string &amp; format, absl::Time t, absl::TimeZone tz)'/>
<use f='halide/build-apps/abseil-cpp/absl/time/format.cc' l='84' u='c' c='_ZN4absl14lts_2020_02_2510FormatTimeB5cxx11ENS0_4TimeENS0_8TimeZoneE'/>
<use f='halide/build-apps/abseil-cpp/absl/time/format.cc' l='88' u='c' c='_ZN4absl14lts_2020_02_2510FormatTimeB5cxx11ENS0_4TimeE'/>
<use f='halide/build-apps/abseil-cpp/absl/time/format.cc' l='142' u='c' c='_ZN4absl14lts_2020_02_2515AbslUnparseFlagB5cxx11ENS0_4TimeE'/>
<use f='halide/build-apps/abseil-cpp/absl/time/format.cc' l='149' u='c' c='_ZN4absl14lts_2020_02_2511UnparseFlagB5cxx11ENS0_4TimeE'/>
