<def f='halide/build-apps/eigen/unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h' l='49' ll='245'/>
<use f='halide/build-apps/eigen/unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h' l='168'/>
<use f='halide/build-apps/eigen/unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h' l='243' c='_ZN14EigenForTFLite10EventCountC1ERKS0_'/>
<use f='halide/build-apps/eigen/unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h' l='244' c='_ZN14EigenForTFLite10EventCountaSERKS0_'/>
<use f='halide/build-apps/eigen/unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h' l='246'/>
<size>16</size>
<doc f='halide/build-apps/eigen/unsupported/Eigen/CXX11/src/ThreadPool/EventCount.h' l='15'>// EventCount allows to wait for arbitrary predicates in non-blocking
// algorithms. Think of condition variable, but wait predicate does not need to
// be protected by a mutex. Usage:
// Waiting thread does:
//
//   if (predicate)
//     return act();
//   EventCount::Waiter&amp; w = waiters[my_index];
//   ec.Prewait(&amp;w);
//   if (predicate) {
//     ec.CancelWait(&amp;w);
//     return act();
//   }
//   ec.CommitWait(&amp;w);
//
// Notifying thread does:
//
//   predicate = true;
//   ec.Notify(true);
//
// Notify is cheap if there are no waiting threads. Prewait/CommitWait are not
// cheap, but they are executed only if the preceding predicate check has
// failed.
//
// Algorithm outline:
// There are two main variables: predicate (managed by user) and state_.
// Operation closely resembles Dekker mutual algorithm:
// https://en.wikipedia.org/wiki/Dekker%27s_algorithm
// Waiting thread sets state_ then checks predicate, Notifying thread sets
// predicate then checks state_. Due to seq_cst fences in between these
// operations it is guaranteed than either waiter will see predicate change
// and won&apos;t block, or notifying thread will see state_ change and will unblock
// the waiter, or both. But it can&apos;t happen that both threads don&apos;t see each
// other changes, which would lead to deadlock.</doc>
<fun r='_ZN14EigenForTFLite10EventCountC1ERNS_13MaxSizeVectorINS0_6WaiterEEE'/>
<fun r='_ZN14EigenForTFLite10EventCountD1Ev'/>
<fun r='_ZN14EigenForTFLite10EventCount7PrewaitEv'/>
<fun r='_ZN14EigenForTFLite10EventCount10CommitWaitEPNS0_6WaiterE'/>
<fun r='_ZN14EigenForTFLite10EventCount10CancelWaitEv'/>
<fun r='_ZN14EigenForTFLite10EventCount6NotifyEb'/>
<smbr r='EigenForTFLite::EventCount::kWaiterBits' t='const uint64_t'/>
<smbr r='EigenForTFLite::EventCount::kStackMask' t='const uint64_t'/>
<smbr r='EigenForTFLite::EventCount::kWaiterShift' t='const uint64_t'/>
<smbr r='EigenForTFLite::EventCount::kWaiterMask' t='const uint64_t'/>
<smbr r='EigenForTFLite::EventCount::kWaiterInc' t='const uint64_t'/>
<smbr r='EigenForTFLite::EventCount::kSignalShift' t='const uint64_t'/>
<smbr r='EigenForTFLite::EventCount::kSignalMask' t='const uint64_t'/>
<smbr r='EigenForTFLite::EventCount::kSignalInc' t='const uint64_t'/>
<smbr r='EigenForTFLite::EventCount::kEpochShift' t='const uint64_t'/>
<smbr r='EigenForTFLite::EventCount::kEpochBits' t='const uint64_t'/>
<smbr r='EigenForTFLite::EventCount::kEpochMask' t='const uint64_t'/>
<smbr r='EigenForTFLite::EventCount::kEpochInc' t='const uint64_t'/>
<mbr r='EigenForTFLite::EventCount::state_' o='0' t='std::atomic&lt;uint64_t&gt;'/>
<mbr r='EigenForTFLite::EventCount::waiters_' o='64' t='MaxSizeVector&lt;EigenForTFLite::EventCount::Waiter&gt; &amp;'/>
<fun r='_ZN14EigenForTFLite10EventCount10CheckStateEmb'/>
<fun r='_ZN14EigenForTFLite10EventCount4ParkEPNS0_6WaiterE'/>
<fun r='_ZN14EigenForTFLite10EventCount6UnparkEPNS0_6WaiterE'/>
<fun r='_ZN14EigenForTFLite10EventCountC1ERKS0_'/>
<fun r='_ZN14EigenForTFLite10EventCountaSERKS0_'/>
