<dec f='include/python3.8/ceval.h' l='187' type='PyThreadState * PyEval_SaveThread()'/>
<doc f='include/python3.8/ceval.h' l='142'>/* Interface for threads.

   A module that plans to do a blocking system call (or something else
   that lasts a long time and doesn&apos;t touch Python data) can allow other
   threads to run as follows:

    ...preparations here...
    Py_BEGIN_ALLOW_THREADS
    ...blocking system call here...
    Py_END_ALLOW_THREADS
    ...interpret result here...

   The Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS pair expands to a
   {}-surrounded block.
   To leave the block in the middle (e.g., with return), you must insert
   a line containing Py_BLOCK_THREADS before the return, e.g.

    if (...premature_exit...) {
        Py_BLOCK_THREADS
        PyErr_SetFromErrno(PyExc_OSError);
        return NULL;
    }

   An alternative is:

    Py_BLOCK_THREADS
    if (...premature_exit...) {
        PyErr_SetFromErrno(PyExc_OSError);
        return NULL;
    }
    Py_UNBLOCK_THREADS

   For convenience, that the value of &apos;errno&apos; is restored across
   Py_END_ALLOW_THREADS and Py_BLOCK_THREADS.

   WARNING: NEVER NEST CALLS TO Py_BEGIN_ALLOW_THREADS AND
   Py_END_ALLOW_THREADS!!!

   The function PyEval_InitThreads() should be called only from
   init_thread() in &quot;_threadmodule.c&quot;.

   Note that not yet all candidates have been converted to use this
   mechanism!
*/</doc>
<use f='halide/build/_deps/pybind11-src/include/pybind11/pybind11.h' l='2186' u='c' c='_ZN8pybind1118gil_scoped_acquireD1Ev'/>
<use f='halide/build/_deps/pybind11-src/include/pybind11/pybind11.h' l='2201' u='c' c='_ZN8pybind1118gil_scoped_releaseC1Eb'/>
