<dec f='halide/build-apps/eigen/unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h' l='172' type='const int'/>
<use f='halide/build-apps/eigen/unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h' l='173' u='r'/>
<use f='halide/build-apps/eigen/unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h' l='176' u='r' c='_ZN14EigenForTFLite15ThreadPoolTempl15EncodePartitionEjj'/>
<use f='halide/build-apps/eigen/unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h' l='181' u='r' c='_ZN14EigenForTFLite15ThreadPoolTempl15DecodePartitionEjPjS1_'/>
<doc f='halide/build-apps/eigen/unsupported/Eigen/CXX11/src/ThreadPool/NonBlockingThreadPool.h' l='165'>// Create a single atomic&lt;int&gt; that encodes start and limit information for
  // each thread.
  // We expect num_threads_ &lt; 65536, so we can store them in a single
  // std::atomic&lt;unsigned&gt;.
  // Exposed publicly as static functions so that external callers can reuse
  // this encode/decode logic for maintaining their own thread-safe copies of
  // scheduling and steal domain(s).</doc>
