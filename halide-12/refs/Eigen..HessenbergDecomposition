<def f='halide/build-apps/eigen/Eigen/src/Eigenvalues/HessenbergDecomposition.h' l='57' ll='279'/>
<use f='halide/build-apps/eigen/Eigen/src/Eigenvalues/HessenbergDecomposition.h' l='294' c='_ZN5Eigen23HessenbergDecomposition8_computeERT_RNS_6MatrixINS1_6ScalarEXLNS0_Ut_E0EELi1EXanLS5_0EcoLNS_14StorageOptionsE1EEXLS5_0EELi1EEERNS3_IS4_Li1E9058549'/>
<use f='halide/build-apps/eigen/Eigen/src/Eigenvalues/HessenbergDecomposition.h' l='347' c='_ZN5Eigen8internal40HessenbergDecompositionMatrixHReturnTypeC1ERKNS_23HessenbergDecompositionIT_EE'/>
<use f='halide/build-apps/eigen/Eigen/src/Eigenvalues/HessenbergDecomposition.h' l='367'/>
<use f='halide/build-apps/eigen/Eigen/src/Eigenvalues/RealSchur.h' l='230'/>
<use f='halide/build-apps/eigen/Eigen/src/Eigenvalues/ComplexSchur.h' l='249'/>
<doc f='halide/build-apps/eigen/Eigen/src/Eigenvalues/HessenbergDecomposition.h' l='27'>/** \eigenvalues_module \ingroup Eigenvalues_Module
  *
  *
  * \class HessenbergDecomposition
  *
  * \brief Reduces a square matrix to Hessenberg form by an orthogonal similarity transformation
  *
  * \tparam _MatrixType the type of the matrix of which we are computing the Hessenberg decomposition
  *
  * This class performs an Hessenberg decomposition of a matrix \f$ A \f$. In
  * the real case, the Hessenberg decomposition consists of an orthogonal
  * matrix \f$ Q \f$ and a Hessenberg matrix \f$ H \f$ such that \f$ A = Q H
  * Q^T \f$. An orthogonal matrix is a matrix whose inverse equals its
  * transpose (\f$ Q^{-1} = Q^T \f$). A Hessenberg matrix has zeros below the
  * subdiagonal, so it is almost upper triangular. The Hessenberg decomposition
  * of a complex matrix is \f$ A = Q H Q^* \f$ with \f$ Q \f$ unitary (that is,
  * \f$ Q^{-1} = Q^* \f$).
  *
  * Call the function compute() to compute the Hessenberg decomposition of a
  * given matrix. Alternatively, you can use the
  * HessenbergDecomposition(const MatrixType&amp;) constructor which computes the
  * Hessenberg decomposition at construction time. Once the decomposition is
  * computed, you can use the matrixH() and matrixQ() functions to construct
  * the matrices H and Q in the decomposition.
  *
  * The documentation for matrixH() contains an example of the typical use of
  * this class.
  *
  * \sa class ComplexSchur, class Tridiagonalization, \ref QR_Module &quot;QR Module&quot;
  */</doc>
<fun r='_ZN5Eigen23HessenbergDecompositionC1El'/>
<fun r='_ZN5Eigen23HessenbergDecompositionC1ERKNS_9EigenBaseITL0__EE'/>
<fun r='_ZN5Eigen23HessenbergDecomposition7computeERKNS_9EigenBaseITL0__EE'/>
<fun r='_ZNK5Eigen23HessenbergDecomposition23householderCoefficientsEv'/>
<fun r='_ZNK5Eigen23HessenbergDecomposition12packedMatrixEv'/>
<fun r='_ZNK5Eigen23HessenbergDecomposition7matrixQEv'/>
<fun r='_ZNK5Eigen23HessenbergDecomposition7matrixHEv'/>
<fun r='_ZN5Eigen23HessenbergDecomposition8_computeERT_RNS_6MatrixINS1_6ScalarEXLNS0_Ut_E0EELi1EXanLS5_0EcoLNS_14StorageOptionsE1EEXLS5_0EELi1EEERNS3_IS4_Li1E9058549'/>
<mbr r='Eigen::HessenbergDecomposition::m_matrix' t='Eigen::HessenbergDecomposition::MatrixType'/>
<mbr r='Eigen::HessenbergDecomposition::m_hCoeffs' t='Eigen::HessenbergDecomposition::CoeffVectorType'/>
<mbr r='Eigen::HessenbergDecomposition::m_temp' t='Eigen::HessenbergDecomposition::VectorType'/>
<mbr r='Eigen::HessenbergDecomposition::m_isInitialized' t='bool'/>
<fun r='_ZN5Eigen23HessenbergDecomposition8_computeERT_RNS_6MatrixINS1_6ScalarEXLNS0_Ut_E0EELi1EXanLS5_0EcoLNS_14StorageOptionsE1EEXLS5_0EELi1EEERNS3_IS4_Li1E9058549'/>
