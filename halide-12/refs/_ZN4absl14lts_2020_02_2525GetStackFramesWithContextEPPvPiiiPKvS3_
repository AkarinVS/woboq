<dec f='halide/build-apps/abseil-cpp/absl/debugging/stacktrace.h' l='105' type='int absl::lts_2020_02_25::GetStackFramesWithContext(void ** result, int * sizes, int max_depth, int skip_count, const void * uc, int * min_dropped_frames)'/>
<doc f='halide/build-apps/abseil-cpp/absl/debugging/stacktrace.h' l='84'>// GetStackFramesWithContext()
//
// Records program counter values obtained from a signal handler. Records
// program counter values for up to `max_depth` frames, skipping the most recent
// `skip_count` stack frames, stores their corresponding values and sizes in
// `results` and `sizes` buffers, and returns the number of frames stored. (Note
// that the frame generated for the `absl::GetStackFramesWithContext()` routine
// itself is also skipped.)
//
// The `uc` parameter, if non-null, should be a pointer to a `ucontext_t` value
// passed to a signal handler registered via the `sa_sigaction` field of a
// `sigaction` struct. (See
// http://man7.org/linux/man-pages/man2/sigaction.2.html.) The `uc` value may
// help a stack unwinder to provide a better stack trace under certain
// conditions. `uc` may safely be null.
//
// The `min_dropped_frames` output parameter, if non-null, points to the
// location to note any dropped stack frames, if any, due to buffer limitations
// or other reasons. (This value will be set to `0` if no frames were dropped.)
// The number of total stack frames is guaranteed to be &gt;= skip_count +
// max_depth + *min_dropped_frames.</doc>
<use f='halide/build-apps/abseil-cpp/absl/debugging/failure_signal_handler.cc' l='260' u='c' c='_ZN4absl14lts_2020_02_25L15WriteStackTraceEPvbPFvPKcS1_ES1_'/>
<def f='halide/build-apps/abseil-cpp/absl/debugging/stacktrace.cc' l='91' ll='97' macro='1' type='int absl::lts_2020_02_25::GetStackFramesWithContext(void ** result, int * sizes, int max_depth, int skip_count, const void * uc, int * min_dropped_frames)'/>
