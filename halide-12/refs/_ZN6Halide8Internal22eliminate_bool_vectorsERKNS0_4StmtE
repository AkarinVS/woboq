<dec f='halide/halide-install/include/Halide.h' l='21934' type='Halide::Internal::Stmt Halide::Internal::eliminate_bool_vectors(const Halide::Internal::Stmt &amp; s)'/>
<doc f='halide/halide-install/include/Halide.h' l='21921'>/** Some targets treat vectors of bools as integers of the same type that the
 * boolean operation is being used to operate on. For example, instead of
 * select(i1x8, u16x8, u16x8), the target would prefer to see select(u16x8,
 * u16x8, u16x8), where the first argument is a vector of integers representing
 * a mask. This pass converts vectors of bools to vectors of integers to meet
 * this requirement. This is done by injecting intrinsics to convert bools to
 * architecture-specific masks, and using a select_mask intrinsic instead of a
 * Select node. This also converts any intrinsics that operate on vectorized
 * conditions to a *_mask equivalent (if_then_else, require). Because the masks
 * are architecture specific, they may not be stored or loaded. On Stores, the
 * masks are converted to UInt(8) with a value of 0 or 1, which is our canonical
 * in-memory representation of a bool. */
///@{</doc>
<dec f='halide/build/include/Halide.h' l='21934' type='Halide::Internal::Stmt Halide::Internal::eliminate_bool_vectors(const Halide::Internal::Stmt &amp; s)'/>
<doc f='halide/build/include/Halide.h' l='21921'>/** Some targets treat vectors of bools as integers of the same type that the
 * boolean operation is being used to operate on. For example, instead of
 * select(i1x8, u16x8, u16x8), the target would prefer to see select(u16x8,
 * u16x8, u16x8), where the first argument is a vector of integers representing
 * a mask. This pass converts vectors of bools to vectors of integers to meet
 * this requirement. This is done by injecting intrinsics to convert bools to
 * architecture-specific masks, and using a select_mask intrinsic instead of a
 * Select node. This also converts any intrinsics that operate on vectorized
 * conditions to a *_mask equivalent (if_then_else, require). Because the masks
 * are architecture specific, they may not be stored or loaded. On Stores, the
 * masks are converted to UInt(8) with a value of 0 or 1, which is our canonical
 * in-memory representation of a bool. */
///@{</doc>
<dec f='halide/src/EliminateBoolVectors.h' l='26' type='Halide::Internal::Stmt Halide::Internal::eliminate_bool_vectors(const Halide::Internal::Stmt &amp; s)'/>
<use f='halide/src/CodeGen_OpenCL_Dev.cpp' l='910' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_118CodeGen_OpenCL_Dev16CodeGen_OpenCL_C10add_kernelENS0_4StmtERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERK15661578'/>
<doc f='halide/src/EliminateBoolVectors.h' l='13'>/** Some targets treat vectors of bools as integers of the same type that the
 * boolean operation is being used to operate on. For example, instead of
 * select(i1x8, u16x8, u16x8), the target would prefer to see select(u16x8,
 * u16x8, u16x8), where the first argument is a vector of integers representing
 * a mask. This pass converts vectors of bools to vectors of integers to meet
 * this requirement. This is done by injecting intrinsics to convert bools to
 * architecture-specific masks, and using a select_mask intrinsic instead of a
 * Select node. This also converts any intrinsics that operate on vectorized
 * conditions to a *_mask equivalent (if_then_else, require). Because the masks
 * are architecture specific, they may not be stored or loaded. On Stores, the
 * masks are converted to UInt(8) with a value of 0 or 1, which is our canonical
 * in-memory representation of a bool. */
///@{</doc>
<def f='halide/src/EliminateBoolVectors.cpp' l='321' ll='323' type='Halide::Internal::Stmt Halide::Internal::eliminate_bool_vectors(const Halide::Internal::Stmt &amp; s)'/>
