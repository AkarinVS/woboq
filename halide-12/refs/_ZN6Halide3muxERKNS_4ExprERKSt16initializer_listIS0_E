<dec f='halide/halide-install/include/Halide.h' l='7663' type='Halide::Expr Halide::mux(const Halide::Expr &amp; id, const std::initializer_list&lt;Expr&gt; &amp; values)'/>
<doc f='halide/halide-install/include/Halide.h' l='7650'>/** Oftentimes we want to pack a list of expressions with the same type
 * into a channel dimension, e.g.,
 * img(x, y, c) = select(c == 0, 100, // Red
 *                       c == 1, 50,  // Green
 *                               25); // Blue
 * This is tedious when the list is long. The following function
 * provide convinent syntax that allow one to write:
 * img(x, y, c) = mux(c, {100, 50, 25});
 *
 * As with the select equivalent, if the first argument (the index) is
 * out of range, the expression evaluates to the last value.
 */
// @{</doc>
<use f='halide/apps/bilateral_grid/bilateral_grid_generator.cpp' l='30' u='c' c='_ZN12_GLOBAL__N_113BilateralGrid8generateEv'/>
<use f='halide/apps/camera_pipe/camera_pipe_generator.cpp' l='143' u='c' c='_ZN12_GLOBAL__N_18Demosaic8generateEv'/>
<use f='halide/apps/camera_pipe/camera_pipe_generator.cpp' l='253' u='c' c='_ZN12_GLOBAL__N_110CameraPipe12deinterleaveEN6Halide4FuncE'/>
<use f='halide/apps/camera_pipe/camera_pipe_generator.cpp' l='290' u='c' c='_ZN12_GLOBAL__N_110CameraPipe13color_correctEN6Halide4FuncE'/>
<use f='halide/apps/fft/fft_generator.cpp' l='136' u='c' c='_ZN12_GLOBAL__N_112FFTGenerator8generateEv'/>
<use f='halide/apps/hist/hist_generator.cpp' l='54' u='c' c='_ZN12_GLOBAL__N_14Hist8generateEv'/>
<use f='halide/apps/lens_blur/lens_blur_generator.cpp' l='56' u='c' c='_ZN12_GLOBAL__N_18LensBlur8generateEv'/>
<use f='halide/apps/lens_blur/lens_blur_generator.cpp' l='103' u='c' c='_ZN12_GLOBAL__N_18LensBlur8generateEv'/>
<use f='halide/apps/nl_means/nl_means_generator.cpp' l='53' u='c' c='_ZN12_GLOBAL__N_113NonLocalMeans8generateEv'/>
<use f='halide/apps/wavelet/daubechies_x_generator.cpp' l='17' u='c' c='_ZN12_GLOBAL__N_112daubechies_x8generateEv'/>
<use f='halide/apps/wavelet/haar_x_generator.cpp' l='17' u='c' c='_ZN12_GLOBAL__N_16haar_x8generateEv'/>
<dec f='halide/build/include/Halide.h' l='7663' type='Halide::Expr Halide::mux(const Halide::Expr &amp; id, const std::initializer_list&lt;Expr&gt; &amp; values)'/>
<doc f='halide/build/include/Halide.h' l='7650'>/** Oftentimes we want to pack a list of expressions with the same type
 * into a channel dimension, e.g.,
 * img(x, y, c) = select(c == 0, 100, // Red
 *                       c == 1, 50,  // Green
 *                               25); // Blue
 * This is tedious when the list is long. The following function
 * provide convinent syntax that allow one to write:
 * img(x, y, c) = mux(c, {100, 50, 25});
 *
 * As with the select equivalent, if the first argument (the index) is
 * out of range, the expression evaluates to the last value.
 */
// @{</doc>
<dec f='halide/src/IROperator.h' l='858' type='Halide::Expr Halide::mux(const Halide::Expr &amp; id, const std::initializer_list&lt;Expr&gt; &amp; values)'/>
<doc f='halide/src/IROperator.h' l='845'>/** Oftentimes we want to pack a list of expressions with the same type
 * into a channel dimension, e.g.,
 * img(x, y, c) = select(c == 0, 100, // Red
 *                       c == 1, 50,  // Green
 *                               25); // Blue
 * This is tedious when the list is long. The following function
 * provide convinent syntax that allow one to write:
 * img(x, y, c) = mux(c, {100, 50, 25});
 *
 * As with the select equivalent, if the first argument (the index) is
 * out of range, the expression evaluates to the last value.
 */
// @{</doc>
<def f='halide/src/IROperator.cpp' l='1504' ll='1506' type='Halide::Expr Halide::mux(const Halide::Expr &amp; id, const std::initializer_list&lt;Expr&gt; &amp; values)'/>
