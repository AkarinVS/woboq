<dec f='halide/halide-install/include/Halide.h' l='17769' type='void Halide::Func::specialize_fail(const std::string &amp; message)'/>
<use f='halide/halide-install/include/Halide.h' l='25208' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase15specialize_failEDpOT_'/>
<use f='halide/halide-install/include/Halide.h' l='25208' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase15specialize_failEDpOT_'/>
<doc f='halide/halide-install/include/Halide.h' l='17729'>/** Add a specialization to a Func that always terminates execution
     * with a call to halide_error(). By itself, this is of limited use,
     * but can be useful to terminate chains of specialize() calls where
     * no &quot;default&quot; case is expected (thus avoiding unnecessary code generation).
     *
     * For instance, say we want to optimize a pipeline to process images
     * in planar and interleaved format; we might typically do something like:
     \code
     ImageParam im(UInt(8), 3);
     Func f = do_something_with(im);
     f.specialize(im.dim(0).stride() == 1).vectorize(x, 8);  // planar
     f.specialize(im.dim(2).stride() == 1).reorder(c, x, y).vectorize(c);  // interleaved
     \endcode
     * This code will vectorize along rows for the planar case, and across pixel
     * components for the interleaved case... but there is an implicit &quot;else&quot;
     * for the unhandled cases, which generates unoptimized code. If we never
     * anticipate passing any other sort of images to this, we code streamline
     * our code by adding specialize_fail():
     \code
     ImageParam im(UInt(8), 3);
     Func f = do_something(im);
     f.specialize(im.dim(0).stride() == 1).vectorize(x, 8);  // planar
     f.specialize(im.dim(2).stride() == 1).reorder(c, x, y).vectorize(c);  // interleaved
     f.specialize_fail(&quot;Unhandled image format&quot;);
     \endcode
     * Conceptually, this produces codes like:
     \code
     if (im.dim(0).stride() == 1) {
        do_something_planar();
     } else if (im.dim(2).stride() == 1) {
        do_something_interleaved();
     } else {
        halide_error(&quot;Unhandled image format&quot;);
     }
     \endcode
     *
     * Note that calling specialize_fail() terminates the specialization chain
     * for a given Func; you cannot create new specializations for the Func
     * afterwards (though you can retrieve handles to previous specializations).
     */</doc>
<dec f='halide/build/include/Halide.h' l='17769' type='void Halide::Func::specialize_fail(const std::string &amp; message)'/>
<use f='halide/build/include/Halide.h' l='25208' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase15specialize_failEDpOT_'/>
<use f='halide/build/include/Halide.h' l='25208' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase15specialize_failEDpOT_'/>
<doc f='halide/build/include/Halide.h' l='17729'>/** Add a specialization to a Func that always terminates execution
     * with a call to halide_error(). By itself, this is of limited use,
     * but can be useful to terminate chains of specialize() calls where
     * no &quot;default&quot; case is expected (thus avoiding unnecessary code generation).
     *
     * For instance, say we want to optimize a pipeline to process images
     * in planar and interleaved format; we might typically do something like:
     \code
     ImageParam im(UInt(8), 3);
     Func f = do_something_with(im);
     f.specialize(im.dim(0).stride() == 1).vectorize(x, 8);  // planar
     f.specialize(im.dim(2).stride() == 1).reorder(c, x, y).vectorize(c);  // interleaved
     \endcode
     * This code will vectorize along rows for the planar case, and across pixel
     * components for the interleaved case... but there is an implicit &quot;else&quot;
     * for the unhandled cases, which generates unoptimized code. If we never
     * anticipate passing any other sort of images to this, we code streamline
     * our code by adding specialize_fail():
     \code
     ImageParam im(UInt(8), 3);
     Func f = do_something(im);
     f.specialize(im.dim(0).stride() == 1).vectorize(x, 8);  // planar
     f.specialize(im.dim(2).stride() == 1).reorder(c, x, y).vectorize(c);  // interleaved
     f.specialize_fail(&quot;Unhandled image format&quot;);
     \endcode
     * Conceptually, this produces codes like:
     \code
     if (im.dim(0).stride() == 1) {
        do_something_planar();
     } else if (im.dim(2).stride() == 1) {
        do_something_interleaved();
     } else {
        halide_error(&quot;Unhandled image format&quot;);
     }
     \endcode
     *
     * Note that calling specialize_fail() terminates the specialization chain
     * for a given Func; you cannot create new specializations for the Func
     * afterwards (though you can retrieve handles to previous specializations).
     */</doc>
<dec f='halide/src/Func.h' l='1889' type='void Halide::Func::specialize_fail(const std::string &amp; message)'/>
<doc f='halide/src/Func.h' l='1849'>/** Add a specialization to a Func that always terminates execution
     * with a call to halide_error(). By itself, this is of limited use,
     * but can be useful to terminate chains of specialize() calls where
     * no &quot;default&quot; case is expected (thus avoiding unnecessary code generation).
     *
     * For instance, say we want to optimize a pipeline to process images
     * in planar and interleaved format; we might typically do something like:
     \code
     ImageParam im(UInt(8), 3);
     Func f = do_something_with(im);
     f.specialize(im.dim(0).stride() == 1).vectorize(x, 8);  // planar
     f.specialize(im.dim(2).stride() == 1).reorder(c, x, y).vectorize(c);  // interleaved
     \endcode
     * This code will vectorize along rows for the planar case, and across pixel
     * components for the interleaved case... but there is an implicit &quot;else&quot;
     * for the unhandled cases, which generates unoptimized code. If we never
     * anticipate passing any other sort of images to this, we code streamline
     * our code by adding specialize_fail():
     \code
     ImageParam im(UInt(8), 3);
     Func f = do_something(im);
     f.specialize(im.dim(0).stride() == 1).vectorize(x, 8);  // planar
     f.specialize(im.dim(2).stride() == 1).reorder(c, x, y).vectorize(c);  // interleaved
     f.specialize_fail(&quot;Unhandled image format&quot;);
     \endcode
     * Conceptually, this produces codes like:
     \code
     if (im.dim(0).stride() == 1) {
        do_something_planar();
     } else if (im.dim(2).stride() == 1) {
        do_something_interleaved();
     } else {
        halide_error(&quot;Unhandled image format&quot;);
     }
     \endcode
     *
     * Note that calling specialize_fail() terminates the specialization chain
     * for a given Func; you cannot create new specializations for the Func
     * afterwards (though you can retrieve handles to previous specializations).
     */</doc>
<def f='halide/src/Func.cpp' l='2175' ll='2178' type='void Halide::Func::specialize_fail(const std::string &amp; message)'/>
<use f='halide/src/Generator.h' l='2274' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase15specialize_failEDpOT_'/>
<use f='halide/src/Generator.h' l='2274' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase15specialize_failEDpOT_'/>
