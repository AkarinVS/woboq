<dec f='halide/build-apps/abseil-cpp/absl/base/internal/spinlock.h' l='165' type='void absl::lts_2020_02_25::base_internal::SpinLock::InitLinkerInitializedAndCooperative()'/>
<use f='halide/build-apps/abseil-cpp/absl/base/internal/spinlock.cc' l='79' u='c' c='_ZN4absl14lts_2020_02_2513base_internal8SpinLockC1ENS1_17LinkerInitializedENS1_14SchedulingModeE'/>
<def f='halide/build-apps/abseil-cpp/absl/base/internal/spinlock.cc' l='92' ll='96' type='void absl::lts_2020_02_25::base_internal::SpinLock::InitLinkerInitializedAndCooperative()'/>
<doc f='halide/build-apps/abseil-cpp/absl/base/internal/spinlock.cc' l='84'>// Static (linker initialized) spinlocks always start life as functional
// non-cooperative locks.  When their static constructor does run, it will call
// this initializer to augment the lockword with the cooperative bit.  By
// actually taking the lock when we do this we avoid the need for an atomic
// operation in the regular unlock path.
//
// SlowLock() must be careful to re-test for this bit so that any outstanding
// waiters may be upgraded to cooperative status.</doc>
