<def f='halide/build-apps/ruy/ruy/mat.h' l='207' ll='227'/>
<use f='halide/build-apps/ruy/ruy/mat.h' l='209' c='_ZN3ruy4Type6CreateEv'/>
<use f='halide/build-apps/ruy/ruy/mat.h' l='210' c='_ZN3ruy4Type6CreateEv'/>
<use f='halide/build-apps/ruy/ruy/mat.h' l='229' c='_ZN3ruyeqERKNS_4TypeES2_'/>
<use f='halide/build-apps/ruy/ruy/mat.h' l='229' c='_ZN3ruyeqERKNS_4TypeES2_'/>
<use f='halide/build-apps/ruy/ruy/mat.h' l='237'/>
<use f='halide/build-apps/ruy/ruy/mat.h' l='246'/>
<use f='halide/build-apps/ruy/ruy/mat.h' l='248'/>
<size>3</size>
<doc f='halide/build-apps/ruy/ruy/mat.h' l='196'>// Dynamic representation for a type.
//
// The most important field in this struct is the size, which Ruy uses to know
// how much memory to allocate without having to be templated on a type.
// Signed-ness and floating-point-ness are mainly present as debugging checks.
//
// Note: Ruy does not use this struct to to dynamically dispatch between
// different typed implementations. As described in the comment at the top of
// this file, Ruy&apos;s &quot;front-end&quot;, which is templated, instantiates all the
// necessary &quot;back-end&quot; routines with complete static knowledge of all the
// types.</doc>
<fun r='_ZN3ruy4Type6CreateEv'/>
<fun r='_ZNK3ruy4Type8AssertIsEv'/>
<mbr r='ruy::Type::is_signed' o='0' t='bool'/>
<mbr r='ruy::Type::is_floating_point' o='8' t='bool'/>
<mbr r='ruy::Type::size' o='16' t='std::uint8_t'/>
