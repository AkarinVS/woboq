<dec f='halide/halide-install/include/Halide.h' l='7750' type='Halide::Expr Halide::exp(Halide::Expr x)'/>
<doc f='halide/halide-install/include/Halide.h' l='7743'>/** Return the exponential of a floating-point expression. If the
 * argument is not floating-point, it is cast to Float(32). For
 * Float(64) arguments, this calls the system exp function, and does
 * not vectorize well. For Float(32) arguments, this function is
 * vectorizable, does the right thing for extremely small or extremely
 * large inputs, and is accurate up to the last bit of the
 * mantissa. Vectorizes cleanly. */</doc>
<use f='halide/apps/local_laplacian/local_laplacian_generator.cpp' l='26' u='c' c='_ZN12_GLOBAL__N_114LocalLaplacian8generateEv'/>
<use f='halide/apps/unsharp/unsharp_generator.cpp' l='18' u='c' c='_ZN12_GLOBAL__N_17Unsharp8generateEv'/>
<dec f='halide/build/include/Halide.h' l='7750' type='Halide::Expr Halide::exp(Halide::Expr x)'/>
<doc f='halide/build/include/Halide.h' l='7743'>/** Return the exponential of a floating-point expression. If the
 * argument is not floating-point, it is cast to Float(32). For
 * Float(64) arguments, this calls the system exp function, and does
 * not vectorize well. For Float(32) arguments, this function is
 * vectorizable, does the right thing for extremely small or extremely
 * large inputs, and is accurate up to the last bit of the
 * mantissa. Vectorizes cleanly. */</doc>
<use f='halide/python_bindings/src/PyIROperator.cpp' l='132' u='a' c='_ZN6Halide14PythonBindings16define_operatorsERN8pybind117module_E'/>
<dec f='halide/src/IROperator.h' l='945' type='Halide::Expr Halide::exp(Halide::Expr x)'/>
<doc f='halide/src/IROperator.h' l='938'>/** Return the exponential of a floating-point expression. If the
 * argument is not floating-point, it is cast to Float(32). For
 * Float(64) arguments, this calls the system exp function, and does
 * not vectorize well. For Float(32) arguments, this function is
 * vectorizable, does the right thing for extremely small or extremely
 * large inputs, and is accurate up to the last bit of the
 * mantissa. Vectorizes cleanly. */</doc>
<use f='halide/src/Derivative.cpp' l='1065' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_126ReverseAccumulationVisitor5visitEPKNS0_4CallE'/>
<def f='halide/src/IROperator.cpp' l='2118' ll='2127' type='Halide::Expr Halide::exp(Halide::Expr x)'/>
<use f='halide/src/autoschedulers/adams2019/cost_model_generator.cpp' l='187' u='c' c='_ZN9CostModel7sigmoidERKN6Halide4ExprE'/>
