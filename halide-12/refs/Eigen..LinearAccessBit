<def f='halide/build-apps/eigen/Eigen/src/Core/util/Constants.h' l='129' type='const unsigned int'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/DenseCoeffsBase.h' l='142' u='r' c='_ZNK5Eigen15DenseCoeffsBaseIT_Li0EE5coeffEl'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/DenseCoeffsBase.h' l='261' u='r' c='_ZNK5Eigen15DenseCoeffsBaseIT_Li0EE6packetEl'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/DenseCoeffsBase.h' l='391' u='r' c='_ZN5Eigen15DenseCoeffsBaseIT_Li1EE8coeffRefEl'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/CoreEvaluators.h' l='508' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/CoreEvaluators.h' l='567' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/CoreEvaluators.h' l='652' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/CoreEvaluators.h' l='747' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/CoreEvaluators.h' l='820' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/CoreEvaluators.h' l='991' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/CoreEvaluators.h' l='1057' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/CoreEvaluators.h' l='1057'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/CoreEvaluators.h' l='1110' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/CoreEvaluators.h' l='1295'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/CoreEvaluators.h' l='1498'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/CoreEvaluators.h' l='1608' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/AssignEvaluator.h' l='87' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/Matrix.h' l='49' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/MapBase.h' l='15' u='r' c='_ZNK5Eigen7MapBaseIT_Li0EE5coeffEl'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/MapBase.h' l='15' u='r' c='_ZNK5Eigen7MapBaseIT_Li0EE8coeffRefEl'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/MapBase.h' l='15' u='r' c='_ZNK5Eigen7MapBaseIT_Li0EE6packetEl'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/MapBase.h' l='15' u='r' c='_ZN5Eigen7MapBaseIT_Li1EE8coeffRefEl'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/MapBase.h' l='15' u='r' c='_ZN5Eigen7MapBaseIT_Li1EE11writePacketElRKNS0_IS1_Li0EE12PacketScalarE'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/IndexedView.h' l='57'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/IndexedView.h' l='172'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/Reshaped.h' l='73' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/Reshaped.h' l='73' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/Reshaped.h' l='79'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/Reshaped.h' l='286'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/Redux.h' l='47' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/TriangularMatrix.h' l='180' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/SelfAdjointView.h' l='43' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/ProductEvaluators.h' l='578' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/ProductEvaluators.h' l='846' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/ProductEvaluators.h' l='846' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/ProductEvaluators.h' l='848'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/PartialReduxEvaluator.h' l='160' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/LU/arch/Inverse_SSE.h' l='42' u='r'/>
<use f='halide/build-apps/eigen/Eigen/src/LU/arch/Inverse_SSE.h' l='174' u='r'/>
<doc f='halide/build-apps/eigen/Eigen/src/Core/util/Constants.h' l='109'>/** \ingroup flags
  *
  * Short version: means the expression can be seen as 1D vector.
  *
  * Long version: means that one can access the coefficients
  * of this expression by coeff(int), and coeffRef(int) in the case of a lvalue expression. These
  * index-based access methods are guaranteed
  * to not have to do any runtime computation of a (row, col)-pair from the index, so that it
  * is guaranteed that whenever it is available, index-based access is at least as fast as
  * (row,col)-based access. Expressions for which that isn&apos;t possible don&apos;t have the LinearAccessBit.
  *
  * If both PacketAccessBit and LinearAccessBit are set, then the
  * packets of this expression can be accessed by packet(int), and writePacket(int) in the case of a
  * lvalue expression.
  *
  * Typically, all vector expressions have the LinearAccessBit, but there is one exception:
  * Product expressions don&apos;t have it, because it would be troublesome for vectorization, even when the
  * Product is a vector expression. Thus, vector Product expressions allow index-based coefficient access but
  * not index-based packet access, so they don&apos;t have the LinearAccessBit.
  */</doc>
