<dec f='halide/build-apps/abseil-cpp/absl/debugging/stacktrace.h' l='81' type='int absl::lts_2020_02_25::GetStackFrames(void ** result, int * sizes, int max_depth, int skip_count)'/>
<doc f='halide/build-apps/abseil-cpp/absl/debugging/stacktrace.h' l='39'>// GetStackFrames()
//
// Records program counter values for up to `max_depth` frames, skipping the
// most recent `skip_count` stack frames, stores their corresponding values
// and sizes in `results` and `sizes` buffers, and returns the number of frames
// stored. (Note that the frame generated for the `absl::GetStackFrames()`
// routine itself is also skipped.)
//
// Example:
//
//      main() { foo(); }
//      foo() { bar(); }
//      bar() {
//        void* result[10];
//        int sizes[10];
//        int depth = absl::GetStackFrames(result, sizes, 10, 1);
//      }
//
// The current stack frame would consist of three function calls: `bar()`,
// `foo()`, and then `main()`; however, since the `GetStackFrames()` call sets
// `skip_count` to `1`, it will skip the frame for `bar()`, the most recently
// invoked function call. It will therefore return 2 and fill `result` with
// program counters within the following functions:
//
//      result[0]       foo()
//      result[1]       main()
//
// (Note: in practice, a few more entries after `main()` may be added to account
// for startup processes.)
//
// Corresponding stack frame sizes will also be recorded:
//
//    sizes[0]       16
//    sizes[1]       16
//
// (Stack frame sizes of `16` above are just for illustration purposes.)
//
// Stack frame sizes of 0 or less indicate that those frame sizes couldn&apos;t
// be identified.
//
// This routine may return fewer stack frame entries than are
// available. Also note that `result` and `sizes` must both be non-null.</doc>
<def f='halide/build-apps/abseil-cpp/absl/debugging/stacktrace.cc' l='85' ll='89' macro='1' type='int absl::lts_2020_02_25::GetStackFrames(void ** result, int * sizes, int max_depth, int skip_count)'/>
