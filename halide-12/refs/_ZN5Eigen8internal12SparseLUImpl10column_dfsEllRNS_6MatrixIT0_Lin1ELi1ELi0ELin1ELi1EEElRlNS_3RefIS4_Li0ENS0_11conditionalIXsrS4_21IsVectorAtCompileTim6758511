<dec f='halide/build-apps/eigen/Eigen/src/SparseLU/SparseLUImpl.h' l='52' type='Eigen::Index Eigen::internal::SparseLUImpl::column_dfs(const Eigen::Index m, const Eigen::Index jcol, Eigen::internal::SparseLUImpl::IndexVector &amp; perm_r, Eigen::Index maxsuper, Eigen::Index &amp; nseg, Eigen::internal::SparseLUImpl::BlockIndexVector lsub_col, Eigen::internal::SparseLUImpl::IndexVector &amp; segrep, Eigen::internal::SparseLUImpl::BlockIndexVector repfnz, Eigen::internal::SparseLUImpl::IndexVector &amp; xprune, Eigen::internal::SparseLUImpl::IndexVector &amp; marker, Eigen::internal::SparseLUImpl::IndexVector &amp; parent, Eigen::internal::SparseLUImpl::IndexVector &amp; xplore, Eigen::internal::SparseLUImpl::GlobalLU_t &amp; glu)'/>
<def f='halide/build-apps/eigen/Eigen/src/SparseLU/SparseLU_column_dfs.h' l='92' ll='173' type='Eigen::Index Eigen::internal::SparseLUImpl::column_dfs(const Eigen::Index m, const Eigen::Index jcol, Eigen::internal::SparseLUImpl::IndexVector &amp; perm_r, Eigen::Index maxsuper, Eigen::Index &amp; nseg, Eigen::internal::SparseLUImpl::BlockIndexVector lsub_col, Eigen::internal::SparseLUImpl::IndexVector &amp; segrep, Eigen::internal::SparseLUImpl::BlockIndexVector repfnz, Eigen::internal::SparseLUImpl::IndexVector &amp; xprune, Eigen::internal::SparseLUImpl::IndexVector &amp; marker, Eigen::internal::SparseLUImpl::IndexVector &amp; parent, Eigen::internal::SparseLUImpl::IndexVector &amp; xplore, Eigen::internal::SparseLUImpl::GlobalLU_t &amp; glu)'/>
<doc f='halide/build-apps/eigen/Eigen/src/SparseLU/SparseLU_column_dfs.h' l='65'>/**
 * \brief Performs a symbolic factorization on column jcol and decide the supernode boundary
 * 
 * A supernode representative is the last column of a supernode.
 * The nonzeros in U[*,j] are segments that end at supernodes representatives. 
 * The routine returns a list of the supernodal representatives 
 * in topological order of the dfs that generates them. 
 * The location of the first nonzero in each supernodal segment 
 * (supernodal entry location) is also returned. 
 * 
 * \param m number of rows in the matrix
 * \param jcol Current column 
 * \param perm_r Row permutation
 * \param maxsuper  Maximum number of column allowed in a supernode
 * \param [in,out] nseg Number of segments in current U[*,j] - new segments appended
 * \param lsub_col defines the rhs vector to start the dfs
 * \param [in,out] segrep Segment representatives - new segments appended 
 * \param repfnz  First nonzero location in each row
 * \param xprune 
 * \param marker  marker[i] == jj, if i was visited during dfs of current column jj;
 * \param parent
 * \param xplore working array
 * \param glu global LU data 
 * \return 0 success
 *         &gt; 0 number of bytes allocated when run out of space
 * 
 */</doc>
