<def f='halide/build-apps/eigen/Eigen/src/Core/GenericPacketMath.h' l='610' type='Packet Eigen::internal::psqrt(const Packet &amp; a)'/>
<def f='halide/build-apps/eigen/Eigen/src/Core/arch/SSE/MathFunctions.h' l='71' ll='85' type='Eigen::internal::Packet4f Eigen::internal::psqrt(const Eigen::internal::Packet4f &amp; _x)'/>
<def f='halide/build-apps/eigen/Eigen/src/Core/arch/SSE/MathFunctions.h' l='94' ll='95' type='Eigen::internal::Packet2d Eigen::internal::psqrt(const Eigen::internal::Packet2d &amp; x)'/>
<doc f='halide/build-apps/eigen/Eigen/src/Core/arch/SSE/MathFunctions.h' l='63'>// Functions for sqrt.
// The EIGEN_FAST_MATH version uses the _mm_rsqrt_ps approximation and one step
// of Newton&apos;s method, at a cost of 1-2 bits of precision as opposed to the
// exact solution. It does not handle +inf, or denormalized numbers correctly.
// The main advantage of this approach is not just speed, but also the fact that
// it can be inlined and pipelined with other computations, further reducing its
// effective latency. This is similar to Quake3&apos;s fast inverse square root.
// For detail see here: http://www.beyond3d.com/content/articles/8/</doc>
