<dec f='halide/build-apps/ruy/ruy/apply_multiplier.h' l='48' type='std::int32_t ruy::detail::MultiplyByQuantizedMultiplier(std::int32_t x, std::int32_t quantized_multiplier, int shift)'/>
<doc f='halide/build-apps/ruy/ruy/apply_multiplier.h' l='47'>// Copied from TF Lite code.</doc>
<def f='halide/build-apps/ruy/ruy/apply_multiplier.cc' l='48' ll='65' type='std::int32_t ruy::detail::MultiplyByQuantizedMultiplier(std::int32_t x, std::int32_t quantized_multiplier, int shift)'/>
<doc f='halide/build-apps/ruy/ruy/apply_multiplier.cc' l='26'>// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Warning: this code is not meant to be bit-exact-normative.
// Please refer to the class comment of ruy::MulParams, in mul_params.h.
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Simplified multiplier application function
//
// Double rounding and symmetric rounding are removed compared to reference.
// Double rounding seems unnecessary and can complicate implementations.
// Symmetric rounding also adds implementation complexity.
//
// Composed of a single rounding shift right and can lead to more HW
// friendly implementations.
//
// On NEON this can be translated to a SQDMULH + rounding shift right sequence.
// The use of SQDMULH rather than SQRDMULH gives a result that is
// equivalent to a single rounded shift since the truncating shift of SQDMULH
// can be combined with the rounding right shift via the formula (for k&gt;=1):
//  ((x&gt;&gt;31)+(1&lt;&lt;(k-1)))&gt;&gt;k = (x + (1&lt;&lt;(30+k))&gt;&gt;(31+k)
//
// Preconditions:
// - quantized_multiplier &gt;= 0
// - shift is -31 to +7 (negative for right shift)</doc>
