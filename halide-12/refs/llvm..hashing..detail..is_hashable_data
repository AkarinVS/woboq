<def f='halide/llvm-install/include/llvm/ADT/Hashing.h' l='349' ll='352'/>
<def f='halide/llvm-install/include/llvm/ADT/Hashing.h' l='358' ll='362'/>
<use f='halide/llvm-install/include/llvm/ADT/Hashing.h' l='359'/>
<use f='halide/llvm-install/include/llvm/ADT/Hashing.h' l='360'/>
<use f='halide/llvm-install/include/llvm/ADT/Hashing.h' l='367' c='_ZN4llvm7hashing6detail17get_hashable_dataERKT_'/>
<use f='halide/llvm-install/include/llvm/ADT/Hashing.h' l='375' c='_ZN4llvm7hashing6detail17get_hashable_dataERKT_'/>
<use f='halide/llvm-install/include/llvm/ADT/Hashing.h' l='449' c='_ZN4llvm7hashing6detail23hash_combine_range_implEPT_S3_'/>
<doc f='halide/llvm-install/include/llvm/ADT/Hashing.h' l='337'>/// Trait to indicate whether a type&apos;s bits can be hashed directly.
///
/// A type trait which is true if we want to combine values for hashing by
/// reading the underlying data. It is false if values of this type must
/// first be passed to hash_value, and the resulting hash_codes combined.
//
// FIXME: We want to replace is_integral_or_enum and is_pointer here with
// a predicate which asserts that comparing the underlying storage of two
// values of the type for equality is equivalent to comparing the two values
// for equality. For all the platforms we care about, this holds for integers
// and pointers, but there are platforms where it doesn&apos;t and we would like to
// support user-defined types which happen to satisfy this property.</doc>
<doc f='halide/llvm-install/include/llvm/ADT/Hashing.h' l='354'>// Special case std::pair to detect when both types are viable and when there
// is no alignment-derived padding in the pair. This is a bit of a lie because
// std::pair isn&apos;t truly POD, but it&apos;s close enough in all reasonable
// implementations for our use case of hashing the underlying data.</doc>
