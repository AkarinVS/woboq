<dec f='halide/build-apps/eigen/Eigen/src/SparseLU/SparseLUImpl.h' l='49' type='void Eigen::internal::SparseLUImpl::panel_dfs(const Eigen::Index m, const Eigen::Index w, const Eigen::Index jcol, Eigen::internal::SparseLUImpl::MatrixType &amp; A, Eigen::internal::SparseLUImpl::IndexVector &amp; perm_r, Eigen::Index &amp; nseg, Eigen::internal::SparseLUImpl::ScalarVector &amp; dense, Eigen::internal::SparseLUImpl::IndexVector &amp; panel_lsub, Eigen::internal::SparseLUImpl::IndexVector &amp; segrep, Eigen::internal::SparseLUImpl::IndexVector &amp; repfnz, Eigen::internal::SparseLUImpl::IndexVector &amp; xprune, Eigen::internal::SparseLUImpl::IndexVector &amp; marker, Eigen::internal::SparseLUImpl::IndexVector &amp; parent, Eigen::internal::SparseLUImpl::IndexVector &amp; xplore, Eigen::internal::SparseLUImpl::GlobalLU_t &amp; glu)'/>
<def f='halide/build-apps/eigen/Eigen/src/SparseLU/SparseLU_panel_dfs.h' l='218' ll='253' type='void Eigen::internal::SparseLUImpl::panel_dfs(const Eigen::Index m, const Eigen::Index w, const Eigen::Index jcol, Eigen::internal::SparseLUImpl::MatrixType &amp; A, Eigen::internal::SparseLUImpl::IndexVector &amp; perm_r, Eigen::Index &amp; nseg, Eigen::internal::SparseLUImpl::ScalarVector &amp; dense, Eigen::internal::SparseLUImpl::IndexVector &amp; panel_lsub, Eigen::internal::SparseLUImpl::IndexVector &amp; segrep, Eigen::internal::SparseLUImpl::IndexVector &amp; repfnz, Eigen::internal::SparseLUImpl::IndexVector &amp; xprune, Eigen::internal::SparseLUImpl::IndexVector &amp; marker, Eigen::internal::SparseLUImpl::IndexVector &amp; parent, Eigen::internal::SparseLUImpl::IndexVector &amp; xplore, Eigen::internal::SparseLUImpl::GlobalLU_t &amp; glu)'/>
<doc f='halide/build-apps/eigen/Eigen/src/SparseLU/SparseLU_panel_dfs.h' l='182'>/**
 * \brief Performs a symbolic factorization on a panel of columns [jcol, jcol+w)
 * 
 * A supernode representative is the last column of a supernode.
 * The nonzeros in U[*,j] are segments that end at supernodes representatives
 * 
 * The routine returns a list of the supernodal representatives 
 * in topological order of the dfs that generates them. This list is 
 * a superset of the topological order of each individual column within 
 * the panel.
 * The location of the first nonzero in each supernodal segment 
 * (supernodal entry location) is also returned. Each column has 
 * a separate list for this purpose. 
 * 
 * Two markers arrays are used for dfs :
 *    marker[i] == jj, if i was visited during dfs of current column jj;
 *    marker1[i] &gt;= jcol, if i was visited by earlier columns in this panel; 
 * 
 * \param[in] m number of rows in the matrix
 * \param[in] w Panel size
 * \param[in] jcol Starting  column of the panel
 * \param[in] A Input matrix in column-major storage
 * \param[in] perm_r Row permutation
 * \param[out] nseg Number of U segments
 * \param[out] dense Accumulate the column vectors of the panel
 * \param[out] panel_lsub Subscripts of the row in the panel 
 * \param[out] segrep Segment representative i.e first nonzero row of each segment
 * \param[out] repfnz First nonzero location in each row
 * \param[out] xprune The pruned elimination tree
 * \param[out] marker work vector
 * \param  parent The elimination tree
 * \param xplore work vector
 * \param glu The global data structure
 * 
 */</doc>
