<dec f='halide/halide-install/include/Halide.h' l='8000' type='Halide::Expr Halide::lerp(Halide::Expr zero_val, Halide::Expr one_val, Halide::Expr weight)'/>
<use f='halide/apps/bgu/bgu_generator.cpp' l='471' u='c' c='_ZN12_GLOBAL__N_13BGU8generateEv'/>
<use f='halide/apps/bgu/bgu_generator.cpp' l='479' u='c' c='_ZN12_GLOBAL__N_13BGU8generateEv'/>
<use f='halide/apps/bgu/bgu_generator.cpp' l='493' u='c' c='_ZN12_GLOBAL__N_13BGU8generateEv'/>
<doc f='halide/halide-install/include/Halide.h' l='7934'>/** Linear interpolate between the two values according to a weight.
 * \param zero_val The result when weight is 0
 * \param one_val The result when weight is 1
 * \param weight The interpolation amount
 *
 * Both zero_val and one_val must have the same type. All types are
 * supported, including bool.
 *
 * The weight is treated as its own type and must be float or an
 * unsigned integer type. It is scaled to the bit-size of the type of
 * x and y if they are integer, or converted to float if they are
 * float. Integer weights are converted to float via division by the
 * full-range value of the weight&apos;s type. Floating-point weights used
 * to interpolate between integer values must be between 0.0f and
 * 1.0f, and an error may be signaled if it is not provably so. (clamp
 * operators can be added to provide proof. Currently an error is only
 * signalled for constant weights.)
 *
 * For integer linear interpolation, out of range values cannot be
 * represented. In particular, weights that are conceptually less than
 * 0 or greater than 1.0 are not representable. As such the result is
 * always between x and y (inclusive of course). For lerp with
 * floating-point values and floating-point weight, the full range of
 * a float is valid, however underflow and overflow can still occur.
 *
 * Ordering is not required between zero_val and one_val:
 *     lerp(42, 69, .5f) == lerp(69, 42, .5f) == 56
 *
 * Results for integer types are for exactly rounded arithmetic. As
 * such, there are cases where 16-bit and float differ because 32-bit
 * floating-point (float) does not have enough precision to produce
 * the exact result. (Likely true for 32-bit integer
 * vs. double-precision floating-point as well.)
 *
 * At present, double precision and 64-bit integers are not supported.
 *
 * Generally, lerp will vectorize as if it were an operation on a type
 * twice the bit size of the inferred type for x and y.
 *
 * Some examples:
 * \code
 *
 *     // Since Halide does not have direct type delcarations, casts
 *     // below are used to indicate the types of the parameters.
 *     // Such casts not required or expected in actual code where types
 *     // are inferred.
 *
 *     lerp(cast&lt;float&gt;(x), cast&lt;float&gt;(y), cast&lt;float&gt;(w)) -&gt;
 *       x * (1.0f - w) + y * w
 *
 *     lerp(cast&lt;uint8_t&gt;(x), cast&lt;uint8_t&gt;(y), cast&lt;uint8_t&gt;(w)) -&gt;
 *       cast&lt;uint8_t&gt;(cast&lt;uint8_t&gt;(x) * (1.0f - cast&lt;uint8_t&gt;(w) / 255.0f) +
 *                     cast&lt;uint8_t&gt;(y) * cast&lt;uint8_t&gt;(w) / 255.0f + .5f)
 *
 *     // Note addition in Halide promoted uint8_t + int8_t to int16_t already,
 *     // the outer cast is added for clarity.
 *     lerp(cast&lt;uint8_t&gt;(x), cast&lt;int8_t&gt;(y), cast&lt;uint8_t&gt;(w)) -&gt;
 *       cast&lt;int16_t&gt;(cast&lt;uint8_t&gt;(x) * (1.0f - cast&lt;uint8_t&gt;(w) / 255.0f) +
 *                     cast&lt;int8_t&gt;(y) * cast&lt;uint8_t&gt;(w) / 255.0f + .5f)
 *
 *     lerp(cast&lt;int8_t&gt;(x), cast&lt;int8_t&gt;(y), cast&lt;float&gt;(w)) -&gt;
 *       cast&lt;int8_t&gt;(cast&lt;int8_t&gt;(x) * (1.0f - cast&lt;float&gt;(w)) +
 *                    cast&lt;int8_t&gt;(y) * cast&lt;uint8_t&gt;(w))
 *
 * \endcode
 * */</doc>
<use f='halide/apps/bilateral_grid/bilateral_grid_generator.cpp' l='61' u='c' c='_ZN12_GLOBAL__N_113BilateralGrid8generateEv'/>
<use f='halide/apps/bilateral_grid/bilateral_grid_generator.cpp' l='61' u='c' c='_ZN12_GLOBAL__N_113BilateralGrid8generateEv'/>
<use f='halide/apps/bilateral_grid/bilateral_grid_generator.cpp' l='61' u='c' c='_ZN12_GLOBAL__N_113BilateralGrid8generateEv'/>
<use f='halide/apps/bilateral_grid/bilateral_grid_generator.cpp' l='62' u='c' c='_ZN12_GLOBAL__N_113BilateralGrid8generateEv'/>
<use f='halide/apps/bilateral_grid/bilateral_grid_generator.cpp' l='63' u='c' c='_ZN12_GLOBAL__N_113BilateralGrid8generateEv'/>
<use f='halide/apps/bilateral_grid/bilateral_grid_generator.cpp' l='63' u='c' c='_ZN12_GLOBAL__N_113BilateralGrid8generateEv'/>
<use f='halide/apps/bilateral_grid/bilateral_grid_generator.cpp' l='64' u='c' c='_ZN12_GLOBAL__N_113BilateralGrid8generateEv'/>
<use f='halide/apps/lens_blur/lens_blur_generator.cpp' l='69' u='c' c='_ZN12_GLOBAL__N_18LensBlur8generateEv'/>
<use f='halide/apps/local_laplacian/local_laplacian_generator.cpp' l='240' u='c' c='_ZN12_GLOBAL__N_114LocalLaplacian8upsampleEN6Halide4FuncE'/>
<use f='halide/apps/local_laplacian/local_laplacian_generator.cpp' l='241' u='c' c='_ZN12_GLOBAL__N_114LocalLaplacian8upsampleEN6Halide4FuncE'/>
<dec f='halide/build/include/Halide.h' l='8000' type='Halide::Expr Halide::lerp(Halide::Expr zero_val, Halide::Expr one_val, Halide::Expr weight)'/>
<doc f='halide/build/include/Halide.h' l='7934'>/** Linear interpolate between the two values according to a weight.
 * \param zero_val The result when weight is 0
 * \param one_val The result when weight is 1
 * \param weight The interpolation amount
 *
 * Both zero_val and one_val must have the same type. All types are
 * supported, including bool.
 *
 * The weight is treated as its own type and must be float or an
 * unsigned integer type. It is scaled to the bit-size of the type of
 * x and y if they are integer, or converted to float if they are
 * float. Integer weights are converted to float via division by the
 * full-range value of the weight&apos;s type. Floating-point weights used
 * to interpolate between integer values must be between 0.0f and
 * 1.0f, and an error may be signaled if it is not provably so. (clamp
 * operators can be added to provide proof. Currently an error is only
 * signalled for constant weights.)
 *
 * For integer linear interpolation, out of range values cannot be
 * represented. In particular, weights that are conceptually less than
 * 0 or greater than 1.0 are not representable. As such the result is
 * always between x and y (inclusive of course). For lerp with
 * floating-point values and floating-point weight, the full range of
 * a float is valid, however underflow and overflow can still occur.
 *
 * Ordering is not required between zero_val and one_val:
 *     lerp(42, 69, .5f) == lerp(69, 42, .5f) == 56
 *
 * Results for integer types are for exactly rounded arithmetic. As
 * such, there are cases where 16-bit and float differ because 32-bit
 * floating-point (float) does not have enough precision to produce
 * the exact result. (Likely true for 32-bit integer
 * vs. double-precision floating-point as well.)
 *
 * At present, double precision and 64-bit integers are not supported.
 *
 * Generally, lerp will vectorize as if it were an operation on a type
 * twice the bit size of the inferred type for x and y.
 *
 * Some examples:
 * \code
 *
 *     // Since Halide does not have direct type delcarations, casts
 *     // below are used to indicate the types of the parameters.
 *     // Such casts not required or expected in actual code where types
 *     // are inferred.
 *
 *     lerp(cast&lt;float&gt;(x), cast&lt;float&gt;(y), cast&lt;float&gt;(w)) -&gt;
 *       x * (1.0f - w) + y * w
 *
 *     lerp(cast&lt;uint8_t&gt;(x), cast&lt;uint8_t&gt;(y), cast&lt;uint8_t&gt;(w)) -&gt;
 *       cast&lt;uint8_t&gt;(cast&lt;uint8_t&gt;(x) * (1.0f - cast&lt;uint8_t&gt;(w) / 255.0f) +
 *                     cast&lt;uint8_t&gt;(y) * cast&lt;uint8_t&gt;(w) / 255.0f + .5f)
 *
 *     // Note addition in Halide promoted uint8_t + int8_t to int16_t already,
 *     // the outer cast is added for clarity.
 *     lerp(cast&lt;uint8_t&gt;(x), cast&lt;int8_t&gt;(y), cast&lt;uint8_t&gt;(w)) -&gt;
 *       cast&lt;int16_t&gt;(cast&lt;uint8_t&gt;(x) * (1.0f - cast&lt;uint8_t&gt;(w) / 255.0f) +
 *                     cast&lt;int8_t&gt;(y) * cast&lt;uint8_t&gt;(w) / 255.0f + .5f)
 *
 *     lerp(cast&lt;int8_t&gt;(x), cast&lt;int8_t&gt;(y), cast&lt;float&gt;(w)) -&gt;
 *       cast&lt;int8_t&gt;(cast&lt;int8_t&gt;(x) * (1.0f - cast&lt;float&gt;(w)) +
 *                    cast&lt;int8_t&gt;(y) * cast&lt;uint8_t&gt;(w))
 *
 * \endcode
 * */</doc>
<use f='halide/python_bindings/src/PyIROperator.cpp' l='166' u='a' c='_ZN6Halide14PythonBindings16define_operatorsERN8pybind117module_E'/>
<dec f='halide/src/IROperator.h' l='1195' type='Halide::Expr Halide::lerp(Halide::Expr zero_val, Halide::Expr one_val, Halide::Expr weight)'/>
<doc f='halide/src/IROperator.h' l='1129'>/** Linear interpolate between the two values according to a weight.
 * \param zero_val The result when weight is 0
 * \param one_val The result when weight is 1
 * \param weight The interpolation amount
 *
 * Both zero_val and one_val must have the same type. All types are
 * supported, including bool.
 *
 * The weight is treated as its own type and must be float or an
 * unsigned integer type. It is scaled to the bit-size of the type of
 * x and y if they are integer, or converted to float if they are
 * float. Integer weights are converted to float via division by the
 * full-range value of the weight&apos;s type. Floating-point weights used
 * to interpolate between integer values must be between 0.0f and
 * 1.0f, and an error may be signaled if it is not provably so. (clamp
 * operators can be added to provide proof. Currently an error is only
 * signalled for constant weights.)
 *
 * For integer linear interpolation, out of range values cannot be
 * represented. In particular, weights that are conceptually less than
 * 0 or greater than 1.0 are not representable. As such the result is
 * always between x and y (inclusive of course). For lerp with
 * floating-point values and floating-point weight, the full range of
 * a float is valid, however underflow and overflow can still occur.
 *
 * Ordering is not required between zero_val and one_val:
 *     lerp(42, 69, .5f) == lerp(69, 42, .5f) == 56
 *
 * Results for integer types are for exactly rounded arithmetic. As
 * such, there are cases where 16-bit and float differ because 32-bit
 * floating-point (float) does not have enough precision to produce
 * the exact result. (Likely true for 32-bit integer
 * vs. double-precision floating-point as well.)
 *
 * At present, double precision and 64-bit integers are not supported.
 *
 * Generally, lerp will vectorize as if it were an operation on a type
 * twice the bit size of the inferred type for x and y.
 *
 * Some examples:
 * \code
 *
 *     // Since Halide does not have direct type delcarations, casts
 *     // below are used to indicate the types of the parameters.
 *     // Such casts not required or expected in actual code where types
 *     // are inferred.
 *
 *     lerp(cast&lt;float&gt;(x), cast&lt;float&gt;(y), cast&lt;float&gt;(w)) -&gt;
 *       x * (1.0f - w) + y * w
 *
 *     lerp(cast&lt;uint8_t&gt;(x), cast&lt;uint8_t&gt;(y), cast&lt;uint8_t&gt;(w)) -&gt;
 *       cast&lt;uint8_t&gt;(cast&lt;uint8_t&gt;(x) * (1.0f - cast&lt;uint8_t&gt;(w) / 255.0f) +
 *                     cast&lt;uint8_t&gt;(y) * cast&lt;uint8_t&gt;(w) / 255.0f + .5f)
 *
 *     // Note addition in Halide promoted uint8_t + int8_t to int16_t already,
 *     // the outer cast is added for clarity.
 *     lerp(cast&lt;uint8_t&gt;(x), cast&lt;int8_t&gt;(y), cast&lt;uint8_t&gt;(w)) -&gt;
 *       cast&lt;int16_t&gt;(cast&lt;uint8_t&gt;(x) * (1.0f - cast&lt;uint8_t&gt;(w) / 255.0f) +
 *                     cast&lt;int8_t&gt;(y) * cast&lt;uint8_t&gt;(w) / 255.0f + .5f)
 *
 *     lerp(cast&lt;int8_t&gt;(x), cast&lt;int8_t&gt;(y), cast&lt;float&gt;(w)) -&gt;
 *       cast&lt;int8_t&gt;(cast&lt;int8_t&gt;(x) * (1.0f - cast&lt;float&gt;(w)) +
 *                    cast&lt;int8_t&gt;(y) * cast&lt;uint8_t&gt;(w))
 *
 * \endcode
 * */</doc>
<def f='halide/src/IROperator.cpp' l='2426' ll='2466' type='Halide::Expr Halide::lerp(Halide::Expr zero_val, Halide::Expr one_val, Halide::Expr weight)'/>
<use f='halide/test/generator/mandelbrot_generator.cpp' l='67' u='c' c='_ZN12_GLOBAL__N_110Mandelbrot8generateEv'/>
<use f='halide/test/generator/mandelbrot_generator.cpp' l='68' u='c' c='_ZN12_GLOBAL__N_110Mandelbrot8generateEv'/>
<use f='halide/test/generator/memory_profiler_mandelbrot_generator.cpp' l='69' u='c' c='_ZN12_GLOBAL__N_110Mandelbrot8generateEv'/>
<use f='halide/test/generator/memory_profiler_mandelbrot_generator.cpp' l='70' u='c' c='_ZN12_GLOBAL__N_110Mandelbrot8generateEv'/>
