<use f='halide/build-apps/eigen/unsupported/Eigen/CXX11/src/ThreadPool/ThreadLocal.h' l='230' u='a' c='_ZN14EigenForTFLite11ThreadLocal7ForEachESt8functionIFvNSt6thread2idERT_EE'/>
<use f='halide/build-apps/eigen/unsupported/Eigen/CXX11/src/ThreadPool/ThreadLocal.h' l='250' u='a' c='_ZN14EigenForTFLite11ThreadLocalD1Ev'/>
<use f='halide/build-apps/eigen/unsupported/Eigen/CXX11/src/ThreadPool/ThreadLocal.h' l='264' u='a' c='_ZN14EigenForTFLite11ThreadLocal12SpilledLocalENSt6thread2idE'/>
<dec f='halide/build-apps/eigen/unsupported/Eigen/CXX11/src/ThreadPool/ThreadLocal.h' l='295' type='std::mutex'/>
<doc f='halide/build-apps/eigen/unsupported/Eigen/CXX11/src/ThreadPool/ThreadLocal.h' l='292'>// We fallback on per thread map if lock-free storage is full. In practice
  // this should never happen, if `capacity_` is a reasonable estimate of the
  // number of threads running in a system.</doc>
<doc f='halide/build-apps/eigen/unsupported/Eigen/CXX11/src/ThreadPool/ThreadLocal.h' l='295'>// Protects per_thread_map_.</doc>
