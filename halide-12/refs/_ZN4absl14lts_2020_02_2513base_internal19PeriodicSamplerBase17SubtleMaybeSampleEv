<dec f='halide/build-apps/abseil-cpp/absl/base/internal/periodic_sampler.h' l='98' type='bool absl::lts_2020_02_25::base_internal::PeriodicSamplerBase::SubtleMaybeSample()'/>
<def f='halide/build-apps/abseil-cpp/absl/base/internal/periodic_sampler.h' l='155' ll='161' type='bool absl::lts_2020_02_25::base_internal::PeriodicSamplerBase::SubtleMaybeSample()'/>
<use f='halide/build-apps/abseil-cpp/absl/base/internal/periodic_sampler.h' l='164' u='c' c='_ZN4absl14lts_2020_02_2513base_internal19PeriodicSamplerBase6SampleEv'/>
<doc f='halide/build-apps/abseil-cpp/absl/base/internal/periodic_sampler.h' l='49'>// The below methods are intended for optimized use cases where the
  // size of the inlined fast path code is highly important. Applications
  // should use the `Sample()` method unless they have proof that their
  // specific use case requires the optimizations offered by these methods.
  //
  // An example of such a use case is SwissTable sampling. All sampling checks
  // are in inlined SwissTable methods, and the number of call sites is huge.
  // In this case, the inlined code size added to each translation unit calling
  // SwissTable methods is non-trivial.
  //
  // The `SubtleMaybeSample()` function spuriously returns true even if the
  // function should not be sampled, applications MUST match each call to
  // &apos;SubtleMaybeSample()&apos; returning true with a `SubtleConfirmSample()` call,
  // and use the result of the latter as the sampling decision.
  // In other words: the code should logically be equivalent to:
  //
  //    if (SubtleMaybeSample() &amp;&amp; SubtleConfirmSample()) {
  //      // Sample this call
  //    }
  //
  // In the &apos;inline-size&apos; optimized case, the `SubtleConfirmSample()` call can
  // be placed out of line, for example, the typical use case looks as follows:
  //
  //   // --- frobber.h -----------
  //   void FrobberSampled();
  //
  //   inline void FrobberImpl() {
  //     // ...
  //   }
  //
  //   inline void Frobber() {
  //     if (ABSL_PREDICT_FALSE(sampler.SubtleMaybeSample())) {
  //       FrobberSampled();
  //     } else {
  //       FrobberImpl();
  //     }
  //   }
  //
  //   // --- frobber.cc -----------
  //   void FrobberSampled() {
  //     if (!sampler.SubtleConfirmSample())) {
  //       // Spurious false positive
  //       FrobberImpl();
  //       return;
  //     }
  //
  //     // Sampled execution
  //     // ...
  //   }</doc>
