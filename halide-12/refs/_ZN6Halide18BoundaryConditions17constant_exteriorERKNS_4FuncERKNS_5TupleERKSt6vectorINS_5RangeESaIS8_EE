<dec f='halide/halide-install/include/Halide.h' l='18578' type='Halide::Func Halide::BoundaryConditions::constant_exterior(const Halide::Func &amp; source, const Halide::Tuple &amp; value, const Halide::Region &amp; bounds)'/>
<doc f='halide/halide-install/include/Halide.h' l='18559'>/** Impose a boundary condition such that a given expression is returned
 *  everywhere outside the boundary. Generally the expression will be a
 *  constant, though the code currently allows accessing the arguments
 *  of source.
 *
 *  An ImageParam, Buffer&lt;T&gt;, or similar can be passed instead of a
 *  Func. If this is done and no bounds are given, the boundaries will
 *  be taken from the min and extent methods of the passed
 *  object. Note that objects are taken by mutable ref. Pipelines
 *  capture Buffers via mutable refs, because running a pipeline might
 *  alter the Buffer metadata (e.g. device allocation state).
 *
 *  (This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_BORDER
 *   and putting value in the border of the texture.)
 *
 *  You may pass undefined Exprs for dimensions that you do not wish
 *  to bound.
 */
// @{</doc>
<dec f='halide/build/include/Halide.h' l='18578' type='Halide::Func Halide::BoundaryConditions::constant_exterior(const Halide::Func &amp; source, const Halide::Tuple &amp; value, const Halide::Region &amp; bounds)'/>
<doc f='halide/build/include/Halide.h' l='18559'>/** Impose a boundary condition such that a given expression is returned
 *  everywhere outside the boundary. Generally the expression will be a
 *  constant, though the code currently allows accessing the arguments
 *  of source.
 *
 *  An ImageParam, Buffer&lt;T&gt;, or similar can be passed instead of a
 *  Func. If this is done and no bounds are given, the boundaries will
 *  be taken from the min and extent methods of the passed
 *  object. Note that objects are taken by mutable ref. Pipelines
 *  capture Buffers via mutable refs, because running a pipeline might
 *  alter the Buffer metadata (e.g. device allocation state).
 *
 *  (This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_BORDER
 *   and putting value in the border of the texture.)
 *
 *  You may pass undefined Exprs for dimensions that you do not wish
 *  to bound.
 */
// @{</doc>
<dec f='halide/src/BoundaryConditions.h' l='95' type='Halide::Func Halide::BoundaryConditions::constant_exterior(const Halide::Func &amp; source, const Halide::Tuple &amp; value, const Halide::Region &amp; bounds)'/>
<def f='halide/src/BoundaryConditions.cpp' l='40' ll='77' type='Halide::Func Halide::BoundaryConditions::constant_exterior(const Halide::Func &amp; source, const Halide::Tuple &amp; value, const Halide::Region &amp; bounds)'/>
<use f='halide/src/BoundaryConditions.cpp' l='81' u='c' c='_ZN6Halide18BoundaryConditions17constant_exteriorERKNS_4FuncERKNS_4ExprERKSt6vectorINS_5RangeESaIS8_EE'/>
<doc f='halide/src/BoundaryConditions.h' l='76'>/** Impose a boundary condition such that a given expression is returned
 *  everywhere outside the boundary. Generally the expression will be a
 *  constant, though the code currently allows accessing the arguments
 *  of source.
 *
 *  An ImageParam, Buffer&lt;T&gt;, or similar can be passed instead of a
 *  Func. If this is done and no bounds are given, the boundaries will
 *  be taken from the min and extent methods of the passed
 *  object. Note that objects are taken by mutable ref. Pipelines
 *  capture Buffers via mutable refs, because running a pipeline might
 *  alter the Buffer metadata (e.g. device allocation state).
 *
 *  (This is similar to setting GL_TEXTURE_WRAP_* to GL_CLAMP_TO_BORDER
 *   and putting value in the border of the texture.)
 *
 *  You may pass undefined Exprs for dimensions that you do not wish
 *  to bound.
 */
// @{</doc>
