<dec f='halide/halide-install/include/Halide.h' l='22261' type='Halide::Expr Halide::fast_integer_divide(Halide::Expr numerator, Halide::Expr denominator)'/>
<doc f='halide/halide-install/include/Halide.h' l='22241'>/** Integer division by small values can be done exactly as multiplies
 * and shifts. This function does integer division for numerators of
 * various integer types (8, 16, 32 bit signed and unsigned)
 * numerators and uint8 denominators. The type of the result is the
 * type of the numerator. The unsigned version is faster than the
 * signed version, so cast the numerator to an unsigned int if you
 * know it&apos;s positive.
 *
 * If your divisor is compile-time constant, Halide performs a
 * slightly better optimization automatically, so there&apos;s no need to
 * use this function (but it won&apos;t hurt).
 *
 * This function vectorizes well on arm, and well on x86 for 16 and 8
 * bit vectors. For 32-bit vectors on x86 you&apos;re better off using
 * native integer division.
 *
 * Also, this routine treats division by zero as division by
 * 256. I.e. it interprets the uint8 divisor as a number from 1 to 256
 * inclusive.
 */</doc>
<dec f='halide/build/include/Halide.h' l='22261' type='Halide::Expr Halide::fast_integer_divide(Halide::Expr numerator, Halide::Expr denominator)'/>
<doc f='halide/build/include/Halide.h' l='22241'>/** Integer division by small values can be done exactly as multiplies
 * and shifts. This function does integer division for numerators of
 * various integer types (8, 16, 32 bit signed and unsigned)
 * numerators and uint8 denominators. The type of the result is the
 * type of the numerator. The unsigned version is faster than the
 * signed version, so cast the numerator to an unsigned int if you
 * know it&apos;s positive.
 *
 * If your divisor is compile-time constant, Halide performs a
 * slightly better optimization automatically, so there&apos;s no need to
 * use this function (but it won&apos;t hurt).
 *
 * This function vectorizes well on arm, and well on x86 for 16 and 8
 * bit vectors. For 32-bit vectors on x86 you&apos;re better off using
 * native integer division.
 *
 * Also, this routine treats division by zero as division by
 * 256. I.e. it interprets the uint8 divisor as a number from 1 to 256
 * inclusive.
 */</doc>
<dec f='halide/src/FastIntegerDivide.h' l='29' type='Halide::Expr Halide::fast_integer_divide(Halide::Expr numerator, Halide::Expr denominator)'/>
<def f='halide/src/FastIntegerDivide.cpp' l='116' ll='229' type='Halide::Expr Halide::fast_integer_divide(Halide::Expr numerator, Halide::Expr denominator)'/>
<use f='halide/src/FastIntegerDivide.cpp' l='232' u='c' c='_ZN6Halide19fast_integer_moduloENS_4ExprES0_'/>
<doc f='halide/src/FastIntegerDivide.h' l='9'>/** Integer division by small values can be done exactly as multiplies
 * and shifts. This function does integer division for numerators of
 * various integer types (8, 16, 32 bit signed and unsigned)
 * numerators and uint8 denominators. The type of the result is the
 * type of the numerator. The unsigned version is faster than the
 * signed version, so cast the numerator to an unsigned int if you
 * know it&apos;s positive.
 *
 * If your divisor is compile-time constant, Halide performs a
 * slightly better optimization automatically, so there&apos;s no need to
 * use this function (but it won&apos;t hurt).
 *
 * This function vectorizes well on arm, and well on x86 for 16 and 8
 * bit vectors. For 32-bit vectors on x86 you&apos;re better off using
 * native integer division.
 *
 * Also, this routine treats division by zero as division by
 * 256. I.e. it interprets the uint8 divisor as a number from 1 to 256
 * inclusive.
 */</doc>
