<def f='halide/build/_deps/pybind11-src/include/pybind11/cast.h' l='1792' ll='1794' type='detail::enable_if_t&lt;detail::move_always&lt;T&gt;::value, T&gt; pybind11::cast(pybind11::object &amp;&amp; object)'/>
<def f='halide/build/_deps/pybind11-src/include/pybind11/cast.h' l='1795' ll='1800' type='detail::enable_if_t&lt;detail::move_if_unreferenced&lt;T&gt;::value, T&gt; pybind11::cast(pybind11::object &amp;&amp; object)'/>
<def f='halide/build/_deps/pybind11-src/include/pybind11/cast.h' l='1801' ll='1803' type='detail::enable_if_t&lt;detail::move_never&lt;T&gt;::value, T&gt; pybind11::cast(pybind11::object &amp;&amp; object)'/>
<doc f='halide/build/_deps/pybind11-src/include/pybind11/cast.h' l='1787'>// Calling cast() on an rvalue calls pybind11::cast with the object rvalue, which does:
// - If we have to move (because T has no copy constructor), do it.  This will fail if the moved
//   object has multiple references, but trying to copy will fail to compile.
// - If both movable and copyable, check ref count: if 1, move; otherwise copy
// - Otherwise (not movable), copy.</doc>
