<dec f='halide/llvm-install/include/llvm/Analysis/TargetTransformInfo.h' l='1039' type='int llvm::TargetTransformInfo::getArithmeticInstrCost(unsigned int Opcode, llvm::Type * Ty, TTI::TargetCostKind CostKind = TTI::TCK_RecipThroughput, llvm::TargetTransformInfo::OperandValueKind Opd1Info = OK_AnyValue, llvm::TargetTransformInfo::OperandValueKind Opd2Info = OK_AnyValue, llvm::TargetTransformInfo::OperandValueProperties Opd1PropInfo = OP_None, llvm::TargetTransformInfo::OperandValueProperties Opd2PropInfo = OP_None, ArrayRef&lt;const llvm::Value *&gt; Args = ArrayRef&lt;const llvm::Value *&gt;(), const llvm::Instruction * CxtI = nullptr) const'/>
<doc f='halide/llvm-install/include/llvm/Analysis/TargetTransformInfo.h' l='1023'>/// This is an approximation of reciprocal throughput of a math/logic op.
  /// A higher cost indicates less expected throughput.
  /// From Agner Fog&apos;s guides, reciprocal throughput is &quot;the average number of
  /// clock cycles per instruction when the instructions are not part of a
  /// limiting dependency chain.&quot;
  /// Therefore, costs should be scaled to account for multiple execution units
  /// on the target that can process this type of instruction. For example, if
  /// there are 5 scalar integer units and 2 vector integer units that can
  /// calculate an &apos;add&apos; in a single cycle, this model should indicate that the
  /// cost of the vector add instruction is 2.5 times the cost of the scalar
  /// add instruction.
  /// \p Args is an optional argument which holds the instruction operands
  /// values so the TTI can analyze those values searching for special
  /// cases or optimizations based on those values.
  /// \p CxtI is the optional original context instruction, if one exists, to
  /// provide even more information.</doc>
