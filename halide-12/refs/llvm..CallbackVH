<inh f='halide/llvm-install/include/llvm/IR/ValueHandle.h' l='29' c='llvm::ValueHandleBase'/>
<def f='halide/llvm-install/include/llvm/IR/ValueHandle.h' l='383' ll='424'/>
<use f='halide/llvm-install/include/llvm/IR/ValueHandle.h' l='387' c='_ZN4llvm10CallbackVHC1ERKS0_'/>
<use f='halide/llvm-install/include/llvm/IR/ValueHandle.h' l='388' c='_ZN4llvm10CallbackVHaSERKS0_'/>
<use f='halide/llvm-install/include/llvm/IR/ValueHandle.h' l='388' c='_ZN4llvm10CallbackVHaSERKS0_'/>
<use f='halide/llvm-install/include/llvm/IR/ValueHandle.h' l='397' c='_ZN4llvm10CallbackVHC1EPKNS_5ValueE'/>
<ovr f='halide/llvm-install/include/llvm/Analysis/AssumptionCache.h' l='66' c='llvm::AssumptionCache::AffectedValueCallbackVH'/>
<use f='halide/llvm-install/include/llvm/Analysis/AssumptionCache.h' l='66'/>
<use f='halide/llvm-install/include/llvm/Analysis/AssumptionCache.h' l='76' c='_ZN4llvm15AssumptionCache23AffectedValueCallbackVHC1EPNS_5ValueEPS0_'/>
<ovr f='halide/llvm-install/include/llvm/Analysis/AssumptionCache.h' l='203' c='llvm::AssumptionCacheTracker::FunctionCallbackVH'/>
<use f='halide/llvm-install/include/llvm/Analysis/AssumptionCache.h' l='203'/>
<use f='halide/llvm-install/include/llvm/Analysis/AssumptionCache.h' l='212' c='_ZN4llvm22AssumptionCacheTracker18FunctionCallbackVHC1EPNS_5ValueEPS0_'/>
<ovr f='halide/llvm-install/include/llvm/IR/ValueMap.h' l='241' c='llvm::ValueMapCallbackVH'/>
<use f='halide/llvm-install/include/llvm/IR/ValueMap.h' l='241'/>
<use f='halide/llvm-install/include/llvm/IR/ValueMap.h' l='251' c='_ZN4llvm18ValueMapCallbackVHC1ET_PNS_8ValueMapIS1_T0_T1_EE'/>
<use f='halide/llvm-install/include/llvm/IR/ValueMap.h' l='255' c='_ZN4llvm18ValueMapCallbackVHC1EPNS_5ValueE'/>
<size>32</size>
<doc f='halide/llvm-install/include/llvm/IR/ValueHandle.h' l='376'>/// Value handle with callbacks on RAUW and destruction.
///
/// This is a value handle that allows subclasses to define callbacks that run
/// when the underlying Value has RAUW called on it or is destroyed.  This
/// class can be used as the key of a map, as long as the user takes it out of
/// the map before calling setValPtr() (since the map has to rearrange itself
/// when the pointer changes).  Unlike ValueHandleBase, this class has a vtable.</doc>
<fun r='_ZN4llvm10CallbackVH6anchorEv'/>
<fun r='_ZN4llvm10CallbackVHD1Ev'/>
<fun r='_ZN4llvm10CallbackVHC1ERKS0_'/>
<fun r='_ZN4llvm10CallbackVHaSERKS0_'/>
<fun r='_ZN4llvm10CallbackVH9setValPtrEPNS_5ValueE'/>
<fun r='_ZN4llvm10CallbackVHC1Ev'/>
<fun r='_ZN4llvm10CallbackVHC1EPNS_5ValueE'/>
<fun r='_ZN4llvm10CallbackVHC1EPKNS_5ValueE'/>
<fun r='_ZNK4llvm10CallbackVHcvPNS_5ValueEEv'/>
<fun r='_ZN4llvm10CallbackVH7deletedEv'/>
<fun r='_ZN4llvm10CallbackVH19allUsesReplacedWithEPNS_5ValueE'/>
