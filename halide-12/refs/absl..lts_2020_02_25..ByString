<def f='halide/build-apps/abseil-cpp/absl/strings/str_split.h' l='123' ll='130'/>
<use f='halide/build-apps/abseil-cpp/absl/strings/str_split.h' l='241'/>
<use f='halide/build-apps/abseil-cpp/absl/strings/str_split.h' l='245'/>
<use f='halide/build-apps/abseil-cpp/absl/strings/str_split.h' l='249'/>
<use f='halide/build-apps/abseil-cpp/absl/strings/str_split.h' l='253'/>
<size>32</size>
<doc f='halide/build-apps/abseil-cpp/absl/strings/str_split.h' l='54'>//------------------------------------------------------------------------------
// Delimiters
//------------------------------------------------------------------------------
//
// `StrSplit()` uses delimiters to define the boundaries between elements in the
// provided input. Several `Delimiter` types are defined below. If a string
// (`const char*`, `std::string`, or `absl::string_view`) is passed in place of
// an explicit `Delimiter` object, `StrSplit()` treats it the same way as if it
// were passed a `ByString` delimiter.
//
// A `Delimiter` is an object with a `Find()` function that knows how to find
// the first occurrence of itself in a given `absl::string_view`.
//
// The following `Delimiter` types are available for use within `StrSplit()`:
//
//   - `ByString` (default for string arguments)
//   - `ByChar` (default for a char argument)
//   - `ByAnyChar`
//   - `ByLength`
//   - `MaxSplits`
//
// A Delimiter&apos;s `Find()` member function will be passed an input `text` that is
// to be split and a position (`pos`) to begin searching for the next delimiter
// in `text`. The returned absl::string_view should refer to the next occurrence
// (after `pos`) of the represented delimiter; this returned absl::string_view
// represents the next location where the input `text` should be broken.
//
// The returned absl::string_view may be zero-length if the Delimiter does not
// represent a part of the string (e.g., a fixed-length delimiter). If no
// delimiter is found in the input `text`, a zero-length absl::string_view
// referring to `text.end()` should be returned (e.g.,
// `text.substr(text.size())`). It is important that the returned
// absl::string_view always be within the bounds of the input `text` given as an
// argument--it must not refer to a string that is physically located outside of
// the given string.
//
// The following example is a simple Delimiter object that is created with a
// single char and will look for that char in the text passed to the `Find()`
// function:
//
//   struct SimpleDelimiter {
//     const char c_;
//     explicit SimpleDelimiter(char c) : c_(c) {}
//     absl::string_view Find(absl::string_view text, size_t pos) {
//       auto found = text.find(c_, pos);
//       if (found == absl::string_view::npos)
//         return text.substr(text.size());
//
//       return text.substr(found, 1);
//     }
//   };

// ByString
//
// A sub-string delimiter. If `StrSplit()` is passed a string in place of a
// `Delimiter` object, the string will be implicitly converted into a
// `ByString` delimiter.
//
// Example:
//
//   // Because a string literal is converted to an `absl::ByString`,
//   // the following two splits are equivalent.
//
//   std::vector&lt;std::string&gt; v1 = absl::StrSplit(&quot;a, b, c&quot;, &quot;, &quot;);
//
//   using absl::ByString;
//   std::vector&lt;std::string&gt; v2 = absl::StrSplit(&quot;a, b, c&quot;,
//                                                ByString(&quot;, &quot;));
//   // v[0] == &quot;a&quot;, v[1] == &quot;b&quot;, v[2] == &quot;c&quot;</doc>
<fun r='_ZN4absl14lts_2020_02_258ByStringC1ENS0_11string_viewE'/>
<fun r='_ZNK4absl14lts_2020_02_258ByString4FindENS0_11string_viewEm'/>
<mbr r='absl::lts_2020_02_25::ByString::delimiter_' o='0' t='const std::string'/>
