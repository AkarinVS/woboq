<dec f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='798' type='bool absl::lts_2020_02_25::CondVar::WaitWithTimeout(absl::lts_2020_02_25::Mutex * mu, absl::Duration timeout)'/>
<doc f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='785'>// CondVar::WaitWithTimeout()
  //
  // Atomically releases a `Mutex` and blocks on this condition variable.
  // Waits until awakened by a call to `Signal()` or `SignalAll()` (or a
  // spurious wakeup), or until the timeout has expired, then reacquires
  // the `Mutex` and returns.
  //
  // Returns true if the timeout has expired without this `CondVar`
  // being signalled in any manner. If both the timeout has expired
  // and this `CondVar` has been signalled, the implementation is free
  // to return `true` or `false`.
  //
  // Requires and ensures that the current thread holds the `Mutex`.</doc>
<def f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.cc' l='2564' ll='2566' type='bool absl::lts_2020_02_25::CondVar::WaitWithTimeout(absl::lts_2020_02_25::Mutex * mu, absl::Duration timeout)'/>
