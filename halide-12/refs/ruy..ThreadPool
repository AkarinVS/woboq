<use f='halide/build-apps/ruy/ruy/context.h' l='59' c='_ZNK3ruy7Context11thread_poolEv'/>
<use f='halide/build-apps/ruy/ruy/context.h' l='60' c='_ZN3ruy7Context19mutable_thread_poolEv'/>
<use f='halide/build-apps/ruy/ruy/ctx.h' l='48' c='_ZNK3ruy3Ctx11thread_poolEv'/>
<use f='halide/build-apps/ruy/ruy/ctx.h' l='49' c='_ZN3ruy3Ctx19mutable_thread_poolEv'/>
<def f='halide/build-apps/ruy/ruy/thread_pool.h' l='55' ll='123'/>
<use f='halide/build-apps/ruy/ruy/thread_pool.h' l='99' c='_ZN3ruy10ThreadPoolC1ERKS0_'/>
<use f='halide/build-apps/ruy/ruy/ctx_impl.h' l='64'/>
<use f='halide/build-apps/ruy/ruy/context.cc' l='39' c='_ZNK3ruy7Context11thread_poolEv'/>
<use f='halide/build-apps/ruy/ruy/context.cc' l='40' c='_ZN3ruy7Context19mutable_thread_poolEv'/>
<size>128</size>
<doc f='halide/build-apps/ruy/ruy/thread_pool.h' l='37'>// A simple pool of threads, that only allows the very
// specific parallelization pattern that we use here:
// One thread, which we call the &apos;main thread&apos;, calls Execute, distributing
// a Task each to N threads, being N-1 &apos;worker threads&apos; and the main thread
// itself. After the main thread has completed its own Task, it waits for
// the worker threads to have all completed. That is the only synchronization
// performed by this ThreadPool.
//
// In particular, there is a naive 1:1 mapping of Tasks to threads.
// This ThreadPool considers it outside of its own scope to try to work
// with fewer threads than there are Tasks. The idea is that such N:M mappings
// of tasks to threads can be implemented as a higher-level feature on top of
// the present low-level 1:1 threadpool. For example, a user might have a
// Task subclass referencing a shared atomic counter indexing into a vector of
// finer-granularity subtasks. Different threads would then concurrently
// increment this atomic counter, getting each their own subtasks to work on.
// That approach is the one used in ruy&apos;s multi-thread matrix multiplication
// implementation --- see ruy&apos;s TrMulTask.</doc>
<fun r='_ZN3ruy10ThreadPoolC1Ev'/>
<fun r='_ZN3ruy10ThreadPoolD1Ev'/>
<fun r='_ZN3ruy10ThreadPool7ExecuteEiPT_'/>
<fun r='_ZN3ruy10ThreadPool21set_spin_millisecondsEf'/>
<fun r='_ZNK3ruy10ThreadPool17spin_millisecondsEv'/>
<fun r='_ZN3ruy10ThreadPool13CreateThreadsEi'/>
<fun r='_ZN3ruy10ThreadPool11ExecuteImplEiiPNS_4TaskE'/>
<fun r='_ZN3ruy10ThreadPoolC1ERKS0_'/>
<mbr r='ruy::ThreadPool::threads_' o='0' t='std::vector&lt;Thread *&gt;'/>
<mbr r='ruy::ThreadPool::counter_to_decrement_when_ready_' o='192' t='ruy::BlockingCounter'/>
<mbr r='ruy::ThreadPool::spin_duration_' o='960' t='ruy::Duration'/>
<use f='halide/build-apps/ruy/ruy/ctx.cc' l='42' c='_ZNK3ruy3Ctx11thread_poolEv'/>
<use f='halide/build-apps/ruy/ruy/ctx.cc' l='43' c='_ZN3ruy3Ctx19mutable_thread_poolEv'/>
<size>128</size>
