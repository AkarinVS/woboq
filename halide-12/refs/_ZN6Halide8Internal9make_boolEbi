<dec f='halide/halide-install/include/Halide.h' l='6926' type='Halide::Expr Halide::Internal::make_bool(bool val, int lanes = 1)'/>
<doc f='halide/halide-install/include/Halide.h' l='6918'>/** Construct a boolean constant from a C++ boolean value.
 * May also be a vector if width is given.
 * It is not possible to coerce a C++ boolean to Expr because
 * if we provide such a path then char objects can ambiguously
 * be converted to Halide Expr or to std::string.  The problem
 * is that C++ does not have a real bool type - it is in fact
 * close enough to char that C++ does not know how to distinguish them.
 * make_bool is the explicit coercion. */</doc>
<dec f='halide/build/include/Halide.h' l='6926' type='Halide::Expr Halide::Internal::make_bool(bool val, int lanes = 1)'/>
<doc f='halide/build/include/Halide.h' l='6918'>/** Construct a boolean constant from a C++ boolean value.
 * May also be a vector if width is given.
 * It is not possible to coerce a C++ boolean to Expr because
 * if we provide such a path then char objects can ambiguously
 * be converted to Halide Expr or to std::string.  The problem
 * is that C++ does not have a real bool type - it is in fact
 * close enough to char that C++ does not know how to distinguish them.
 * make_bool is the explicit coercion. */</doc>
<dec f='halide/src/IROperator.h' l='121' type='Halide::Expr Halide::Internal::make_bool(bool val, int lanes = 1)'/>
<doc f='halide/src/IROperator.h' l='113'>/** Construct a boolean constant from a C++ boolean value.
 * May also be a vector if width is given.
 * It is not possible to coerce a C++ boolean to Expr because
 * if we provide such a path then char objects can ambiguously
 * be converted to Halide Expr or to std::string.  The problem
 * is that C++ does not have a real bool type - it is in fact
 * close enough to char that C++ does not know how to distinguish them.
 * make_bool is the explicit coercion. */</doc>
<use f='halide/src/Bounds.cpp' l='3150' u='c' c='_ZN6Halide8Internal11bounds_testEv'/>
<use f='halide/src/Bounds.cpp' l='3150' u='c' c='_ZN6Halide8Internal11bounds_testEv'/>
<use f='halide/src/Bounds.cpp' l='3151' u='c' c='_ZN6Halide8Internal11bounds_testEv'/>
<use f='halide/src/Bounds.cpp' l='3151' u='c' c='_ZN6Halide8Internal11bounds_testEv'/>
<use f='halide/src/Bounds.cpp' l='3152' u='c' c='_ZN6Halide8Internal11bounds_testEv'/>
<use f='halide/src/Bounds.cpp' l='3152' u='c' c='_ZN6Halide8Internal11bounds_testEv'/>
<use f='halide/src/Bounds.cpp' l='3153' u='c' c='_ZN6Halide8Internal11bounds_testEv'/>
<use f='halide/src/Bounds.cpp' l='3153' u='c' c='_ZN6Halide8Internal11bounds_testEv'/>
<def f='halide/src/IROperator.cpp' l='378' ll='380' type='Halide::Expr Halide::Internal::make_bool(bool val, int w = 1)'/>
<use f='halide/src/Parameter.cpp' l='137' u='c' c='_ZNK6Halide8Internal9Parameter11scalar_exprEv'/>
<use f='halide/src/Simplify_Call.cpp' l='725' u='c' c='_ZN6Halide8Internal8Simplify5visitEPKNS0_4CallEPNS1_8ExprInfoE'/>
