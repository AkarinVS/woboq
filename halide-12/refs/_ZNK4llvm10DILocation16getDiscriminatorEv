<dec f='halide/llvm-install/include/llvm/IR/DebugInfoMetadata.h' l='1698' type='unsigned int llvm::DILocation::getDiscriminator() const'/>
<def f='halide/llvm-install/include/llvm/IR/DebugInfoMetadata.h' l='2190' ll='2194' type='unsigned int llvm::DILocation::getDiscriminator() const'/>
<use f='halide/llvm-install/include/llvm/IR/DebugInfoMetadata.h' l='2214' u='c' c='_ZNK4llvm10DILocation20getBaseDiscriminatorEv'/>
<use f='halide/llvm-install/include/llvm/IR/DebugInfoMetadata.h' l='2218' u='c' c='_ZNK4llvm10DILocation20getDuplicationFactorEv'/>
<use f='halide/llvm-install/include/llvm/IR/DebugInfoMetadata.h' l='2222' u='c' c='_ZNK4llvm10DILocation17getCopyIdentifierEv'/>
<use f='halide/llvm-install/include/llvm/IR/DebugInfoMetadata.h' l='2227' u='c' c='_ZNK4llvm10DILocation26cloneWithBaseDiscriminatorEj'/>
<doc f='halide/llvm-install/include/llvm/IR/DebugInfoMetadata.h' l='1664'>/// Get the DWARF discriminator.
  ///
  /// DWARF discriminators distinguish identical file locations between
  /// instructions that are on different basic blocks.
  ///
  /// There are 3 components stored in discriminator, from lower bits:
  ///
  /// Base discriminator: assigned by AddDiscriminators pass to identify IRs
  ///                     that are defined by the same source line, but
  ///                     different basic blocks.
  /// Duplication factor: assigned by optimizations that will scale down
  ///                     the execution frequency of the original IR.
  /// Copy Identifier: assigned by optimizations that clones the IR.
  ///                  Each copy of the IR will be assigned an identifier.
  ///
  /// Encoding:
  ///
  /// The above 3 components are encoded into a 32bit unsigned integer in
  /// order. If the lowest bit is 1, the current component is empty, and the
  /// next component will start in the next bit. Otherwise, the current
  /// component is non-empty, and its content starts in the next bit. The
  /// value of each components is either 5 bit or 12 bit: if the 7th bit
  /// is 0, the bit 2~6 (5 bits) are used to represent the component; if the
  /// 7th bit is 1, the bit 2~6 (5 bits) and 8~14 (7 bits) are combined to
  /// represent the component. Thus, the number of bits used for a component
  /// is either 0 (if it and all the next components are empty); 1 - if it is
  /// empty; 7 - if its value is up to and including 0x1f (lsb and msb are both
  /// 0); or 14, if its value is up to and including 0x1ff. Note that the last
  /// component is also capped at 0x1ff, even in the case when both first
  /// components are 0, and we&apos;d technically have 29 bits available.
  ///
  /// For precise control over the data being encoded in the discriminator,
  /// use encodeDiscriminator/decodeDiscriminator.</doc>
