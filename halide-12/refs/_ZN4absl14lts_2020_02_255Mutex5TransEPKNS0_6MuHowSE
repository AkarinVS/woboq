<dec f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='505' type='void absl::lts_2020_02_25::Mutex::Trans(absl::lts_2020_02_25::Mutex::MuHow how)'/>
<doc f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='505'>// used for CondVar-&gt;Mutex transfer</doc>
<def f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.cc' l='2327' ll='2329' type='void absl::lts_2020_02_25::Mutex::Trans(absl::lts_2020_02_25::Mutex::MuHow how)'/>
<use f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.cc' l='2559' u='c' c='_ZN4absl14lts_2020_02_257CondVar10WaitCommonEPNS0_5MutexENS0_24synchronization_internal13KernelTimeoutE'/>
<doc f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.cc' l='2318'>// Used by CondVar implementation to reacquire mutex after waking from
// condition variable.  This routine is used instead of Lock() because the
// waiting thread may have been moved from the condition variable queue to the
// mutex queue without a wakeup, by Trans().  In that case, when the thread is
// finally woken, the woken thread will believe it has been woken from the
// condition variable (i.e. its PC will be in when in the CondVar code), when
// in fact it has just been woken from the mutex.  Thus, it must enter the slow
// path of the mutex in the same state as if it had just woken from the mutex.
// That is, it must ensure to clear kMuDesig (INV1b).</doc>
