<def f='halide/halide-install/include/Halide.h' l='12531' ll='12535' type='bool Halide::Internal::Call::is_pure() const'/>
<doc f='halide/halide-install/include/Halide.h' l='12525'>/** Check if a call node is pure within a pipeline, meaning that
     * the same args always give the same result, and the calls can be
     * reordered, duplicated, unified, etc without changing the
     * meaning of anything. Not transitive - doesn&apos;t guarantee the
     * args themselves are pure. An example of a pure Call node is
     * sqrt. If in doubt, don&apos;t mark a Call node as pure. */</doc>
<def f='halide/build/include/Halide.h' l='12531' ll='12535' type='bool Halide::Internal::Call::is_pure() const'/>
<doc f='halide/build/include/Halide.h' l='12525'>/** Check if a call node is pure within a pipeline, meaning that
     * the same args always give the same result, and the calls can be
     * reordered, duplicated, unified, etc without changing the
     * meaning of anything. Not transitive - doesn&apos;t guarantee the
     * args themselves are pure. An example of a pure Call node is
     * sqrt. If in doubt, don&apos;t mark a Call node as pure. */</doc>
<def f='halide/src/IR.h' l='639' ll='643' type='bool Halide::Internal::Call::is_pure() const'/>
<doc f='halide/src/IR.h' l='633'>/** Check if a call node is pure within a pipeline, meaning that
     * the same args always give the same result, and the calls can be
     * reordered, duplicated, unified, etc without changing the
     * meaning of anything. Not transitive - doesn&apos;t guarantee the
     * args themselves are pure. An example of a pure Call node is
     * sqrt. If in doubt, don&apos;t mark a Call node as pure. */</doc>
<use f='halide/src/CodeGen_LLVM.cpp' l='3348' u='c' c='_ZN6Halide8Internal12CodeGen_LLVM5visitEPKNS0_4CallE'/>
<use f='halide/src/CodeGen_LLVM.cpp' l='3381' u='c' c='_ZN6Halide8Internal12CodeGen_LLVM5visitEPKNS0_4CallE'/>
<use f='halide/src/Deinterleave.cpp' l='129' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_114StoreCollector5visitEPKNS0_4CallE'/>
<use f='halide/src/Deinterleave.cpp' l='531' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_111Interleaver5visitEPKNS0_4CallE'/>
<use f='halide/src/IROperator.cpp' l='130' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_110ExprIsPure5visitEPKNS0_4CallE'/>
<use f='halide/src/LICM.cpp' l='27' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_17CanLift5visitEPKNS0_4CallE'/>
<use f='halide/src/Monotonic.cpp' l='491' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_116DerivativeBounds5visitEPKNS0_4CallE'/>
<use f='halide/src/ScheduleFunctions.cpp' l='65' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_118ContainsImpureCall5visitEPKNS0_4CallE'/>
<use f='halide/src/TrimNoOps.cpp' l='157' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_16IsNoOp5visitEPKNS0_4CallE'/>
<use f='halide/src/UnifyDuplicateLets.cpp' l='50' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_118UnifyDuplicateLets5visitEPKNS0_4CallE'/>
<use f='halide/src/VectorizeLoops.cpp' l='475' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_118PredicateLoadStore5visitEPKNS0_4CallE'/>
<use f='halide/src/VectorizeLoops.cpp' l='1429' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_133FindVectorizableExprsInAtomicNode5visitEPKNS0_4CallE'/>
