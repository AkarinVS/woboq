<dec f='halide/halide-install/include/Halide.h' l='4773' type='Halide::Internal::Interval Halide::Internal::bounds_of_expr_in_scope(const Halide::Expr &amp; expr, const Scope&lt;Halide::Internal::Interval&gt; &amp; scope, const Halide::Internal::FuncValueBounds &amp; func_bounds = empty_func_value_bounds(), bool const_bound = false)'/>
<doc f='halide/halide-install/include/Halide.h' l='4761'>/** Given an expression in some variables, and a map from those
 * variables to their bounds (in the form of (minimum possible value,
 * maximum possible value)), compute two expressions that give the
 * minimum possible value and the maximum possible value of this
 * expression. Max or min may be undefined expressions if the value is
 * not bounded above or below. If the expression is a vector, also
 * takes the bounds across the vector lanes and returns a scalar
 * result.
 *
 * This is for tasks such as deducing the region of a buffer
 * loaded by a chunk of code.
 */</doc>
<dec f='halide/build/include/Halide.h' l='4773' type='Halide::Internal::Interval Halide::Internal::bounds_of_expr_in_scope(const Halide::Expr &amp; expr, const Scope&lt;Halide::Internal::Interval&gt; &amp; scope, const Halide::Internal::FuncValueBounds &amp; func_bounds = empty_func_value_bounds(), bool const_bound = false)'/>
<doc f='halide/build/include/Halide.h' l='4761'>/** Given an expression in some variables, and a map from those
 * variables to their bounds (in the form of (minimum possible value,
 * maximum possible value)), compute two expressions that give the
 * minimum possible value and the maximum possible value of this
 * expression. Max or min may be undefined expressions if the value is
 * not bounded above or below. If the expression is a vector, also
 * takes the bounds across the vector lanes and returns a scalar
 * result.
 *
 * This is for tasks such as deducing the region of a buffer
 * loaded by a chunk of code.
 */</doc>
<dec f='halide/src/Bounds.h' l='33' type='Halide::Internal::Interval Halide::Internal::bounds_of_expr_in_scope(const Halide::Expr &amp; expr, const Scope&lt;Halide::Internal::Interval&gt; &amp; scope, const Halide::Internal::FuncValueBounds &amp; func_bounds = empty_func_value_bounds(), bool const_bound = false)'/>
<doc f='halide/src/Bounds.h' l='21'>/** Given an expression in some variables, and a map from those
 * variables to their bounds (in the form of (minimum possible value,
 * maximum possible value)), compute two expressions that give the
 * minimum possible value and the maximum possible value of this
 * expression. Max or min may be undefined expressions if the value is
 * not bounded above or below. If the expression is a vector, also
 * takes the bounds across the vector lanes and returns a scalar
 * result.
 *
 * This is for tasks such as deducing the region of a buffer
 * loaded by a chunk of code.
 */</doc>
<use f='halide/src/Bounds.cpp' l='69' u='c' c='_ZN6Halide8Internal20find_constant_boundsERKNS_4ExprERKNS0_5ScopeINS0_8IntervalEEE'/>
<def f='halide/src/Bounds.cpp' l='1636' ll='1655' type='Halide::Internal::Interval Halide::Internal::bounds_of_expr_in_scope(const Halide::Expr &amp; expr, const Scope&lt;Halide::Internal::Interval&gt; &amp; scope, const Halide::Internal::FuncValueBounds &amp; fb = empty_func_value_bounds(), bool const_bound = false)'/>
<use f='halide/src/Bounds.cpp' l='2004' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_112BoxesTouched22box_from_extended_cropERKNS_4ExprERNS0_3BoxE'/>
<use f='halide/src/Bounds.cpp' l='2005' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_112BoxesTouched22box_from_extended_cropERKNS_4ExprERNS0_3BoxE'/>
<use f='halide/src/Bounds.cpp' l='2017' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_112BoxesTouched22box_from_extended_cropERKNS_4ExprERNS0_3BoxE'/>
<use f='halide/src/Bounds.cpp' l='2018' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_112BoxesTouched22box_from_extended_cropERKNS_4ExprERNS0_3BoxE'/>
<use f='halide/src/Bounds.cpp' l='2063' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_112BoxesTouched5visitEPKNS0_4CallE'/>
<use f='halide/src/Bounds.cpp' l='2403' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_112BoxesTouched14trim_scope_popERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERSt6vectorINS2_8LetBoundESaISC_EE'/>
<use f='halide/src/Bounds.cpp' l='2551' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_112BoxesTouched5visitEPKNS0_10IfThenElseE'/>
<use f='halide/src/Bounds.cpp' l='2639' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_112BoxesTouched5visitEPKNS0_3ForE'/>
<use f='halide/src/Bounds.cpp' l='2645' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_112BoxesTouched5visitEPKNS0_3ForE'/>
<use f='halide/src/Bounds.cpp' l='2646' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_112BoxesTouched5visitEPKNS0_3ForE'/>
<use f='halide/src/Bounds.cpp' l='2663' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_112BoxesTouched5visitEPKNS0_7ProvideE'/>
<use f='halide/src/Bounds.cpp' l='2864' u='c' c='_ZN6Halide8Internal45compute_pure_function_definition_value_boundsERKNS0_10DefinitionERKNS0_5ScopeINS0_8IntervalEEERKSt3mapISt4pairINSt7__cxx1112basic16640102'/>
<use f='halide/src/Bounds.cpp' l='2934' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_15checkERKNS0_5ScopeINS0_8IntervalEEERKNS_4ExprES9_S9_'/>
<use f='halide/src/Bounds.cpp' l='2951' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_120check_constant_boundERKNS0_5ScopeINS0_8IntervalEEERKNS_4ExprES9_S9_'/>
<use f='halide/src/BoundsInference.cpp' l='128' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_116BoundsOfInnerVar5visitEPKNS0_3ForE'/>
<use f='halide/src/BoundsInference.cpp' l='131' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_116BoundsOfInnerVar5visitEPKNS0_3ForE'/>
<use f='halide/src/Derivative.cpp' l='260' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_126ReverseAccumulationVisitor18propagate_adjointsERKNS_4FuncES5_RKSt6vectorINS_5RangeESaIS7_EE'/>
<use f='halide/src/FlattenNestedRamps.cpp' l='53' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_112FlattenRamps5visitEPKNS0_4LoadE'/>
<use f='halide/src/FuseGPUThreadLoops.cpp' l='75' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_116ExtractBlockSize5visitEPKNS0_3ForE'/>
<use f='halide/src/FuseGPUThreadLoops.cpp' l='741' u='c' c='_ZNK6Halide8Internal12_GLOBAL__N_131ExtractSharedAndHeapAllocations15max_over_blocksERKNS_4ExprERKNS1_16ExtractBlockSizeE'/>
<use f='halide/src/FuseGPUThreadLoops.cpp' l='1086' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_126ExtractRegisterAllocations5visitEPKNS0_3ForE'/>
<use f='halide/src/HexagonOptimize.cpp' l='1987' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_116OptimizeShuffles5visitEPKNS0_4LoadE'/>
<use f='halide/src/HexagonOptimize.cpp' l='2223' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_122ScatterGatherGenerator11make_gatherEPKNS0_4LoadENS_4ExprES6_'/>
<use f='halide/src/Solve.cpp' l='1186' u='c' c='_ZN6Halide8Internal25and_condition_over_domainERKNS_4ExprERKNS0_5ScopeINS0_8IntervalEEE'/>
<use f='halide/src/autoschedulers/adams2019/FunctionDAG.cpp' l='658' u='c' c='_ZN6Halide8Internal13Autoscheduler11FunctionDAGC1ERKSt6vectorINS0_8FunctionESaIS4_EERKNS_13MachineParamsERKNS_6TargetE'/>
<use f='halide/src/autoschedulers/mullapudi2016/AutoSchedule.cpp' l='510' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_118DependenceAnalysis16regions_requiredERKNS0_8FunctionEiRKSt3mapINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE1958793'/>
