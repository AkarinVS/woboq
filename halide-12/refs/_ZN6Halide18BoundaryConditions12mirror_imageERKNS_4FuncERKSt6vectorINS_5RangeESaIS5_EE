<dec f='halide/halide-install/include/Halide.h' l='18698' type='Halide::Func Halide::BoundaryConditions::mirror_image(const Halide::Func &amp; source, const Halide::Region &amp; bounds)'/>
<doc f='halide/halide-install/include/Halide.h' l='18684'>/** Impose a boundary condition such that the entire coordinate space is
 *  tiled with copies of the image abutted against each other, but mirror
 *  them such that adjacent edges are the same.
 *
 *  An ImageParam, Buffer&lt;T&gt;, or similar can be passed instead of a Func. If this
 *  is done and no bounds are given, the boundaries will be taken from the
 *  min and extent methods of the passed object.
 *
 *  (This is similar to setting GL_TEXTURE_WRAP_* to GL_MIRRORED_REPEAT.)
 *
 *  You may pass undefined Exprs for dimensions that you do not wish
 *  to bound.
 */
// @{</doc>
<dec f='halide/build/include/Halide.h' l='18698' type='Halide::Func Halide::BoundaryConditions::mirror_image(const Halide::Func &amp; source, const Halide::Region &amp; bounds)'/>
<doc f='halide/build/include/Halide.h' l='18684'>/** Impose a boundary condition such that the entire coordinate space is
 *  tiled with copies of the image abutted against each other, but mirror
 *  them such that adjacent edges are the same.
 *
 *  An ImageParam, Buffer&lt;T&gt;, or similar can be passed instead of a Func. If this
 *  is done and no bounds are given, the boundaries will be taken from the
 *  min and extent methods of the passed object.
 *
 *  (This is similar to setting GL_TEXTURE_WRAP_* to GL_MIRRORED_REPEAT.)
 *
 *  You may pass undefined Exprs for dimensions that you do not wish
 *  to bound.
 */
// @{</doc>
<use f='halide/python_bindings/src/PyBoundaryConditions.cpp' l='123' u='c' c='_ZN6Halide14PythonBindings26define_boundary_conditionsERN8pybind117module_E'/>
<use f='halide/python_bindings/src/PyBoundaryConditions.cpp' l='128' u='c' c='_ZN6Halide14PythonBindings26define_boundary_conditionsERN8pybind117module_E'/>
<dec f='halide/src/BoundaryConditions.h' l='215' type='Halide::Func Halide::BoundaryConditions::mirror_image(const Halide::Func &amp; source, const Halide::Region &amp; bounds)'/>
<def f='halide/src/BoundaryConditions.cpp' l='124' ll='163' type='Halide::Func Halide::BoundaryConditions::mirror_image(const Halide::Func &amp; source, const Halide::Region &amp; bounds)'/>
<doc f='halide/src/BoundaryConditions.h' l='201'>/** Impose a boundary condition such that the entire coordinate space is
 *  tiled with copies of the image abutted against each other, but mirror
 *  them such that adjacent edges are the same.
 *
 *  An ImageParam, Buffer&lt;T&gt;, or similar can be passed instead of a Func. If this
 *  is done and no bounds are given, the boundaries will be taken from the
 *  min and extent methods of the passed object.
 *
 *  (This is similar to setting GL_TEXTURE_WRAP_* to GL_MIRRORED_REPEAT.)
 *
 *  You may pass undefined Exprs for dimensions that you do not wish
 *  to bound.
 */
// @{</doc>
