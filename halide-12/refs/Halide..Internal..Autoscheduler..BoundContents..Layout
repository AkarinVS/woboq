<use f='halide/src/autoschedulers/adams2019/FunctionDAG.h' l='277'/>
<def f='halide/src/autoschedulers/adams2019/FunctionDAG.h' l='322' ll='358'/>
<use f='halide/src/autoschedulers/adams2019/FunctionDAG.h' l='348' c='_ZN6Halide8Internal13Autoscheduler13BoundContents6LayoutC1ERKS3_'/>
<use f='halide/src/autoschedulers/adams2019/FunctionDAG.h' l='349' c='_ZN6Halide8Internal13Autoscheduler13BoundContents6LayoutaSERKS3_'/>
<use f='halide/src/autoschedulers/adams2019/FunctionDAG.h' l='350' c='_ZN6Halide8Internal13Autoscheduler13BoundContents6LayoutC1EOS3_'/>
<use f='halide/src/autoschedulers/adams2019/FunctionDAG.h' l='351' c='_ZN6Halide8Internal13Autoscheduler13BoundContents6LayoutaSEOS3_'/>
<use f='halide/src/autoschedulers/adams2019/FunctionDAG.h' l='516'/>
<size>88</size>
<doc f='halide/src/autoschedulers/adams2019/FunctionDAG.h' l='317'>// We&apos;re frequently going to need to make these concrete bounds
    // arrays.  It makes things more efficient if we figure out the
    // memory layout of those data structures once ahead of time, and
    // make each individual instance just use that. Note that this is
    // not thread-safe.</doc>
<mbr r='Halide::Internal::Autoscheduler::BoundContents::Layout::pool' o='0' t='std::vector&lt;BoundContents *&gt;'/>
<mbr r='Halide::Internal::Autoscheduler::BoundContents::Layout::blocks' o='192' t='std::vector&lt;void *&gt;'/>
<mbr r='Halide::Internal::Autoscheduler::BoundContents::Layout::num_live' o='384' t='size_t'/>
<fun r='_ZNK6Halide8Internal13Autoscheduler13BoundContents6Layout18allocate_some_moreEv'/>
<mbr r='Halide::Internal::Autoscheduler::BoundContents::Layout::total_size' o='448' t='int'/>
<mbr r='Halide::Internal::Autoscheduler::BoundContents::Layout::computed_offset' o='480' t='int'/>
<mbr r='Halide::Internal::Autoscheduler::BoundContents::Layout::loop_offset' o='512' t='std::vector&lt;int&gt;'/>
<fun r='_ZN6Halide8Internal13Autoscheduler13BoundContents6LayoutC1Ev'/>
<fun r='_ZN6Halide8Internal13Autoscheduler13BoundContents6LayoutD1Ev'/>
<fun r='_ZN6Halide8Internal13Autoscheduler13BoundContents6LayoutC1ERKS3_'/>
<fun r='_ZN6Halide8Internal13Autoscheduler13BoundContents6LayoutaSERKS3_'/>
<fun r='_ZN6Halide8Internal13Autoscheduler13BoundContents6LayoutC1EOS3_'/>
<fun r='_ZN6Halide8Internal13Autoscheduler13BoundContents6LayoutaSEOS3_'/>
<fun r='_ZNK6Halide8Internal13Autoscheduler13BoundContents6Layout4makeEv'/>
<fun r='_ZNK6Halide8Internal13Autoscheduler13BoundContents6Layout7releaseEPKS2_'/>
<use f='halide/src/autoschedulers/adams2019/FunctionDAG.cpp' l='944' c='_ZN6Halide8Internal13Autoscheduler11FunctionDAGC1ERKSt6vectorINS0_8FunctionESaIS4_EERKNS_13MachineParamsERKNS_6TargetE'/>
<size>88</size>
<fun r='_ZN6Halide8Internal13Autoscheduler13BoundContents6LayoutD1Ev'/>
<fun r='_ZNK6Halide8Internal13Autoscheduler13BoundContents6Layout18allocate_some_moreEv'/>
<fun r='_ZNK6Halide8Internal13Autoscheduler13BoundContents6Layout4makeEv'/>
<fun r='_ZNK6Halide8Internal13Autoscheduler13BoundContents6Layout7releaseEPKS2_'/>
