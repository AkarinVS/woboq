<dec f='halide/build-apps/abseil-cpp/absl/strings/escaping.h' l='72' type='bool absl::lts_2020_02_25::CUnescape(absl::string_view source, std::string * dest, std::string * error)'/>
<use f='halide/build-apps/abseil-cpp/absl/strings/escaping.h' l='76' u='c' c='_ZN4absl14lts_2020_02_259CUnescapeENS0_11string_viewEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE'/>
<doc f='halide/build-apps/abseil-cpp/absl/strings/escaping.h' l='38'>// CUnescape()
//
// Unescapes a `source` string and copies it into `dest`, rewriting C-style
// escape sequences (https://en.cppreference.com/w/cpp/language/escape) into
// their proper code point equivalents, returning `true` if successful.
//
// The following unescape sequences can be handled:
//
//   * ASCII escape sequences (&apos;\n&apos;,&apos;\r&apos;,&apos;\\&apos;, etc.) to their ASCII equivalents
//   * Octal escape sequences (&apos;\nnn&apos;) to byte nnn. The unescaped value must
//     resolve to a single byte or an error will occur. E.g. values greater than
//     0xff will produce an error.
//   * Hexadecimal escape sequences (&apos;\xnn&apos;) to byte nn. While an arbitrary
//     number of following digits are allowed, the unescaped value must resolve
//     to a single byte or an error will occur. E.g. &apos;\x0045&apos; is equivalent to
//     &apos;\x45&apos;, but &apos;\x1234&apos; will produce an error.
//   * Unicode escape sequences (&apos;\unnnn&apos; for exactly four hex digits or
//     &apos;\Unnnnnnnn&apos; for exactly eight hex digits, which will be encoded in
//     UTF-8. (E.g., `\u2019` unescapes to the three bytes 0xE2, 0x80, and
//     0x99).
//
// If any errors are encountered, this function returns `false`, leaving the
// `dest` output parameter in an unspecified state, and stores the first
// encountered error in `error`. To disable error reporting, set `error` to
// `nullptr` or use the overload with no error reporting below.
//
// Example:
//
//   std::string s = &quot;foo\\rbar\\nbaz\\t&quot;;
//   std::string unescaped_s;
//   if (!absl::CUnescape(s, &amp;unescaped_s) {
//     ...
//   }
//   EXPECT_EQ(unescaped_s, &quot;foo\rbar\nbaz\t&quot;);</doc>
<def f='halide/build-apps/abseil-cpp/absl/strings/escaping.cc' l='849' ll='852' type='bool absl::lts_2020_02_25::CUnescape(absl::string_view source, std::string * dest, std::string * error)'/>
<doc f='halide/build-apps/abseil-cpp/absl/strings/escaping.cc' l='844'>// ----------------------------------------------------------------------
// CUnescape()
//
// See CUnescapeInternal() for implementation details.
// ----------------------------------------------------------------------</doc>
