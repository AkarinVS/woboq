<dec f='halide/build-apps/eigen/Eigen/src/SparseLU/SparseLUImpl.h' l='43' type='Eigen::Index Eigen::internal::SparseLUImpl::pivotL(const Eigen::Index jcol, const Eigen::internal::SparseLUImpl::RealScalar &amp; diagpivotthresh, Eigen::internal::SparseLUImpl::IndexVector &amp; perm_r, Eigen::internal::SparseLUImpl::IndexVector &amp; iperm_c, Eigen::Index &amp; pivrow, Eigen::internal::SparseLUImpl::GlobalLU_t &amp; glu)'/>
<def f='halide/build-apps/eigen/Eigen/src/SparseLU/SparseLU_pivotL.h' l='59' ll='132' type='Eigen::Index Eigen::internal::SparseLUImpl::pivotL(const Eigen::Index jcol, const Eigen::internal::SparseLUImpl::RealScalar &amp; diagpivotthresh, Eigen::internal::SparseLUImpl::IndexVector &amp; perm_r, Eigen::internal::SparseLUImpl::IndexVector &amp; iperm_c, Eigen::Index &amp; pivrow, Eigen::internal::SparseLUImpl::GlobalLU_t &amp; glu)'/>
<doc f='halide/build-apps/eigen/Eigen/src/SparseLU/SparseLU_pivotL.h' l='36'>/**
 * \brief Performs the numerical pivotin on the current column of L, and the CDIV operation.
 * 
 * Pivot policy :
 * (1) Compute thresh = u * max_(i&gt;=j) abs(A_ij);
 * (2) IF user specifies pivot row k and abs(A_kj) &gt;= thresh THEN
 *           pivot row = k;
 *       ELSE IF abs(A_jj) &gt;= thresh THEN
 *           pivot row = j;
 *       ELSE
 *           pivot row = m;
 * 
 *   Note: If you absolutely want to use a given pivot order, then set u=0.0.
 * 
 * \param jcol The current column of L
 * \param diagpivotthresh diagonal pivoting threshold
 * \param[in,out] perm_r Row permutation (threshold pivoting)
 * \param[in] iperm_c column permutation - used to finf diagonal of Pc*A*Pc&apos;
 * \param[out] pivrow  The pivot row
 * \param glu Global LU data
 * \return 0 if success, i &gt; 0 if U(i,i) is exactly zero 
 * 
 */</doc>
