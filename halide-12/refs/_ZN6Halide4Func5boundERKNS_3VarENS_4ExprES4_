<dec f='halide/halide-install/include/Halide.h' l='17411' type='Halide::Func &amp; Halide::Func::bound(const Halide::Var &amp; var, Halide::Expr min, Halide::Expr extent)'/>
<use f='halide/halide-install/include/Halide.h' l='25174' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase5boundEDpOT_'/>
<use f='halide/halide-install/include/Halide.h' l='25174' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase5boundEDpOT_'/>
<use f='halide/apps/bgu/bgu_generator.cpp' l='590' u='c' c='_ZN12_GLOBAL__N_13BGU8generateEv'/>
<use f='halide/apps/bgu/bgu_generator.cpp' l='679' u='c' c='_ZN12_GLOBAL__N_13BGU8generateEv'/>
<doc f='halide/halide-install/include/Halide.h' l='17403'>/** Statically declare that the range over which a function should
     * be evaluated is given by the second and third arguments. This
     * can let Halide perform some optimizations. E.g. if you know
     * there are going to be 4 color channels, you can completely
     * vectorize the color channel dimension without the overhead of
     * splitting it up. If bounds inference decides that it requires
     * more of this function than the bounds you have stated, a
     * runtime error will occur when you try to run your pipeline. */</doc>
<use f='halide/apps/camera_pipe/camera_pipe_generator.cpp' l='453' u='c' c='_ZN12_GLOBAL__N_110CameraPipe8generateEv'/>
<use f='halide/apps/camera_pipe/camera_pipe_generator.cpp' l='452' u='c' c='_ZN12_GLOBAL__N_110CameraPipe8generateEv'/>
<use f='halide/apps/camera_pipe/camera_pipe_generator.cpp' l='576' u='c' c='_ZN12_GLOBAL__N_110CameraPipe8generateEv'/>
<use f='halide/apps/camera_pipe/camera_pipe_generator.cpp' l='575' u='c' c='_ZN12_GLOBAL__N_110CameraPipe8generateEv'/>
<use f='halide/apps/fft/fft.cpp' l='371' u='c' c='_ZN12_GLOBAL__N_18fft_dim1E5FuncTI11ComplexExprERKSt6vectorIiSaIiEEiiN6Halide4ExprEbRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS8_6Targe14237183'/>
<use f='halide/apps/fft/fft.cpp' l='550' u='c' c='_Z9fft2d_c2c5FuncTI11ComplexExprESt6vectorIiSaIiEES4_iRKN6Halide6TargetERK9Fft2dDesc'/>
<use f='halide/apps/fft/fft.cpp' l='551' u='c' c='_Z9fft2d_c2c5FuncTI11ComplexExprESt6vectorIiSaIiEES4_iRKN6Halide6TargetERK9Fft2dDesc'/>
<use f='halide/apps/fft/fft.cpp' l='708' u='c' c='_Z9fft2d_r2cN6Halide4FuncERKSt6vectorIiSaIiEES5_RKNS_6TargetERK9Fft2dDesc'/>
<use f='halide/apps/fft/fft.cpp' l='709' u='c' c='_Z9fft2d_r2cN6Halide4FuncERKSt6vectorIiSaIiEES5_RKNS_6TargetERK9Fft2dDesc'/>
<use f='halide/apps/fft/fft.cpp' l='878' u='c' c='_Z9fft2d_r2cN6Halide4FuncERKSt6vectorIiSaIiEES5_RKNS_6TargetERK9Fft2dDesc'/>
<use f='halide/apps/fft/fft.cpp' l='879' u='c' c='_Z9fft2d_r2cN6Halide4FuncERKSt6vectorIiSaIiEES5_RKNS_6TargetERK9Fft2dDesc'/>
<use f='halide/apps/fft/fft.cpp' l='1058' u='c' c='_Z9fft2d_c2r5FuncTI11ComplexExprESt6vectorIiSaIiEES4_RKN6Halide6TargetERK9Fft2dDesc'/>
<use f='halide/apps/fft/fft.cpp' l='1059' u='c' c='_Z9fft2d_c2r5FuncTI11ComplexExprESt6vectorIiSaIiEES4_RKN6Halide6TargetERK9Fft2dDesc'/>
<use f='halide/apps/hist/hist_generator.cpp' l='68' u='c' c='_ZN12_GLOBAL__N_14Hist8generateEv'/>
<use f='halide/apps/hist/hist_generator.cpp' l='156' u='c' c='_ZN12_GLOBAL__N_14Hist8generateEv'/>
<use f='halide/apps/hist/hist_generator.cpp' l='204' u='c' c='_ZN12_GLOBAL__N_14Hist8generateEv'/>
<use f='halide/apps/interpolate/interpolate_generator.cpp' l='84' u='c' c='_ZN12_GLOBAL__N_111Interpolate8generateEv'/>
<use f='halide/apps/interpolate/interpolate_generator.cpp' l='83' u='c' c='_ZN12_GLOBAL__N_111Interpolate8generateEv'/>
<use f='halide/apps/interpolate/interpolate_generator.cpp' l='82' u='c' c='_ZN12_GLOBAL__N_111Interpolate8generateEv'/>
<use f='halide/apps/interpolate/interpolate_generator.cpp' l='173' u='c' c='_ZN12_GLOBAL__N_111Interpolate8generateEv'/>
<use f='halide/apps/interpolate/interpolate_generator.cpp' l='172' u='c' c='_ZN12_GLOBAL__N_111Interpolate8generateEv'/>
<use f='halide/apps/interpolate/interpolate_generator.cpp' l='171' u='c' c='_ZN12_GLOBAL__N_111Interpolate8generateEv'/>
<use f='halide/apps/lens_blur/lens_blur_generator.cpp' l='177' u='c' c='_ZN12_GLOBAL__N_18LensBlur8generateEv'/>
<use f='halide/apps/lens_blur/lens_blur_generator.cpp' l='202' u='c' c='_ZN12_GLOBAL__N_18LensBlur8generateEv'/>
<use f='halide/apps/lens_blur/lens_blur_generator.cpp' l='215' u='c' c='_ZN12_GLOBAL__N_18LensBlur8generateEv'/>
<use f='halide/apps/lens_blur/lens_blur_generator.cpp' l='258' u='c' c='_ZN12_GLOBAL__N_18LensBlur8generateEv'/>
<use f='halide/apps/nl_means/nl_means_generator.cpp' l='145' u='c' c='_ZN12_GLOBAL__N_113NonLocalMeans8generateEv'/>
<use f='halide/apps/unsharp/unsharp_generator.cpp' l='78' u='c' c='_ZN12_GLOBAL__N_17Unsharp8generateEv'/>
<dec f='halide/build/include/Halide.h' l='17411' type='Halide::Func &amp; Halide::Func::bound(const Halide::Var &amp; var, Halide::Expr min, Halide::Expr extent)'/>
<use f='halide/build/include/Halide.h' l='25174' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase5boundEDpOT_'/>
<use f='halide/build/include/Halide.h' l='25174' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase5boundEDpOT_'/>
<doc f='halide/build/include/Halide.h' l='17403'>/** Statically declare that the range over which a function should
     * be evaluated is given by the second and third arguments. This
     * can let Halide perform some optimizations. E.g. if you know
     * there are going to be 4 color channels, you can completely
     * vectorize the color channel dimension without the overhead of
     * splitting it up. If bounds inference decides that it requires
     * more of this function than the bounds you have stated, a
     * runtime error will occur when you try to run your pipeline. */</doc>
<use f='halide/python_bindings/src/PyFunc.cpp' l='191' u='a' c='_ZN6Halide14PythonBindings11define_funcERN8pybind117module_E'/>
<dec f='halide/src/Func.h' l='1531' type='Halide::Func &amp; Halide::Func::bound(const Halide::Var &amp; var, Halide::Expr min, Halide::Expr extent)'/>
<doc f='halide/src/Func.h' l='1523'>/** Statically declare that the range over which a function should
     * be evaluated is given by the second and third arguments. This
     * can let Halide perform some optimizations. E.g. if you know
     * there are going to be 4 color channels, you can completely
     * vectorize the color channel dimension without the overhead of
     * splitting it up. If bounds inference decides that it requires
     * more of this function than the bounds you have stated, a
     * runtime error will occur when you try to run your pipeline. */</doc>
<def f='halide/src/Func.cpp' l='2222' ll='2253' type='Halide::Func &amp; Halide::Func::bound(const Halide::Var &amp; var, Halide::Expr min, Halide::Expr extent)'/>
<use f='halide/src/Func.cpp' l='2302' u='c' c='_ZN6Halide4Func12bound_extentERKNS_3VarENS_4ExprE'/>
<use f='halide/src/Generator.h' l='2240' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase5boundEDpOT_'/>
<use f='halide/src/Generator.h' l='2240' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase5boundEDpOT_'/>
<use f='halide/src/autoschedulers/adams2019/FunctionDAG.cpp' l='867' u='c' c='_ZN6Halide8Internal13Autoscheduler11FunctionDAGC1ERKSt6vectorINS0_8FunctionESaIS4_EERKNS_13MachineParamsERKNS_6TargetE'/>
<use f='halide/src/autoschedulers/adams2019/demo_generator.cpp' l='28' u='c' c='_ZN12_GLOBAL__N_18ConvRelu8generateEv'/>
<use f='halide/src/autoschedulers/adams2019/demo_generator.cpp' l='27' u='c' c='_ZN12_GLOBAL__N_18ConvRelu8generateEv'/>
<use f='halide/src/autoschedulers/adams2019/demo_generator.cpp' l='26' u='c' c='_ZN12_GLOBAL__N_18ConvRelu8generateEv'/>
<use f='halide/src/autoschedulers/li2018/demo_generator.cpp' l='28' u='c' c='_ZN12_GLOBAL__N_18ConvRelu8generateEv'/>
<use f='halide/src/autoschedulers/li2018/demo_generator.cpp' l='27' u='c' c='_ZN12_GLOBAL__N_18ConvRelu8generateEv'/>
<use f='halide/src/autoschedulers/li2018/demo_generator.cpp' l='26' u='c' c='_ZN12_GLOBAL__N_18ConvRelu8generateEv'/>
<use f='halide/src/autoschedulers/li2018/test.cpp' l='144' u='c' c='main'/>
<use f='halide/tutorial/lesson_12_using_the_gpu.cpp' l='82' u='c' c='_ZN10MyPipeline16schedule_for_cpuEv'/>
<use f='halide/tutorial/lesson_12_using_the_gpu.cpp' l='162' u='c' c='_ZN10MyPipeline16schedule_for_gpuEv'/>
