<dec f='halide/build-apps/abseil-cpp/absl/time/time.h' l='1326' type='bool absl::lts_2020_02_25::ParseTime(const std::string &amp; format, const std::string &amp; input, absl::lts_2020_02_25::TimeZone tz, absl::lts_2020_02_25::Time * time, std::string * err)'/>
<doc f='halide/build-apps/abseil-cpp/absl/time/time.h' l='1319'>// Like ParseTime() above, but if the format string does not contain a UTC
// offset specification (%z/%Ez/%E*z) then the input is interpreted in the
// given TimeZone.  This means that the input, by itself, does not identify a
// unique instant.  Being time-zone dependent, it also admits the possibility
// of ambiguity or non-existence, in which case the &quot;pre&quot; time (as defined
// by TimeZone::TimeInfo) is returned.  For these reasons we recommend that
// all date/time strings include a UTC offset so they&apos;re context independent.</doc>
<use f='halide/build-apps/abseil-cpp/absl/time/civil_time.cc' l='62' u='c' c='_ZN4absl14lts_2020_02_2512_GLOBAL__N_112ParseYearAndENS0_11string_viewES2_PT_'/>
<use f='halide/build-apps/abseil-cpp/absl/time/format.cc' l='93' u='c' c='_ZN4absl14lts_2020_02_259ParseTimeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_PNS0_4TimeEPS6_'/>
<def f='halide/build-apps/abseil-cpp/absl/time/format.cc' l='98' ll='133' type='bool absl::lts_2020_02_25::ParseTime(const std::string &amp; format, const std::string &amp; input, absl::TimeZone tz, absl::Time * time, std::string * err)'/>
<use f='halide/build-apps/abseil-cpp/absl/time/format.cc' l='137' u='c' c='_ZN4absl14lts_2020_02_2513AbslParseFlagENS0_11string_viewEPNS0_4TimeEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE'/>
<use f='halide/build-apps/abseil-cpp/absl/time/format.cc' l='145' u='c' c='_ZN4absl14lts_2020_02_259ParseFlagERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPNS0_4TimeEPS6_'/>
<doc f='halide/build-apps/abseil-cpp/absl/time/format.cc' l='96'>// If the input string does not contain an explicit UTC offset, interpret
// the fields with respect to the given TimeZone.</doc>
