<dec f='halide/halide-install/include/Halide.h' l='11501'/>
<use f='halide/halide-install/include/Halide.h' l='11531' u='c'/>
<use f='halide/halide-install/include/Halide.h' l='11538' u='c'/>
<doc f='halide/halide-install/include/Halide.h' l='11491'>// This is a weird-looking but effective workaround for a deficiency in &quot;perfect forwarding&quot;:
// namely, it can&apos;t really handle initializer-lists. The idea here is that we declare
// the expected type to be passed on, and that allows the compiler to handle it.
// The weirdness comes in with the variadic macro: the problem is that the type
// we want to forward might be something like `std::vector&lt;std::pair&lt;int, int&gt;&gt;`,
// which contains a comma, which throws a big wrench in C++ macro system.
// However... since all we really need to do is capture the remainder of the macro,
// and forward it as is, we can just use ... to allow an arbitrary number of commas,
// then use __VA_ARGS__ to forward the mess as-is, and while it looks horrible, it
// works.</doc>
<dec f='halide/build/include/Halide.h' l='11501'/>
<use f='halide/build/include/Halide.h' l='11531' u='c'/>
<use f='halide/build/include/Halide.h' l='11538' u='c'/>
<doc f='halide/build/include/Halide.h' l='11491'>// This is a weird-looking but effective workaround for a deficiency in &quot;perfect forwarding&quot;:
// namely, it can&apos;t really handle initializer-lists. The idea here is that we declare
// the expected type to be passed on, and that allows the compiler to handle it.
// The weirdness comes in with the variadic macro: the problem is that the type
// we want to forward might be something like `std::vector&lt;std::pair&lt;int, int&gt;&gt;`,
// which contains a comma, which throws a big wrench in C++ macro system.
// However... since all we really need to do is capture the remainder of the macro,
// and forward it as is, we can just use ... to allow an arbitrary number of commas,
// then use __VA_ARGS__ to forward the mess as-is, and while it looks horrible, it
// works.</doc>
<dec f='halide/src/Buffer.h' l='414'/>
<use f='halide/src/Buffer.h' l='444' u='c'/>
<use f='halide/src/Buffer.h' l='451' u='c'/>
<doc f='halide/src/Buffer.h' l='404'>// This is a weird-looking but effective workaround for a deficiency in &quot;perfect forwarding&quot;:
// namely, it can&apos;t really handle initializer-lists. The idea here is that we declare
// the expected type to be passed on, and that allows the compiler to handle it.
// The weirdness comes in with the variadic macro: the problem is that the type
// we want to forward might be something like `std::vector&lt;std::pair&lt;int, int&gt;&gt;`,
// which contains a comma, which throws a big wrench in C++ macro system.
// However... since all we really need to do is capture the remainder of the macro,
// and forward it as is, we can just use ... to allow an arbitrary number of commas,
// then use __VA_ARGS__ to forward the mess as-is, and while it looks horrible, it
// works.</doc>
