<dec f='halide/build-apps/abseil-cpp/absl/strings/charconv.h' l='78' type='absl::from_chars_result absl::lts_2020_02_25::from_chars(const char * first, const char * last, double &amp; value, absl::lts_2020_02_25::chars_format fmt = chars_format::general)'/>
<def f='halide/build-apps/abseil-cpp/absl/strings/charconv.cc' l='679' ll='682' type='absl::lts_2020_02_25::from_chars_result absl::lts_2020_02_25::from_chars(const char * first, const char * last, double &amp; value, absl::lts_2020_02_25::chars_format fmt = chars_format::general)'/>
<doc f='halide/build-apps/abseil-cpp/absl/strings/charconv.h' l='51'>// Workalike compatibilty version of std::from_chars from C++17.  Currently
// this only supports the `double` and `float` types.
//
// This interface incorporates the proposed resolutions for library issues
// DR 3080 and DR 3081.  If these are adopted with different wording,
// Abseil&apos;s behavior will change to match the standard.  (The behavior most
// likely to change is for DR 3081, which says what `value` will be set to in
// the case of overflow and underflow.  Code that wants to avoid possible
// breaking changes in this area should not depend on `value` when the returned
// from_chars_result indicates a range error.)
//
// Searches the range [first, last) for the longest matching pattern beginning
// at `first` that represents a floating point number.  If one is found, store
// the result in `value`.
//
// The matching pattern format is almost the same as that of strtod(), except
// that C locale is not respected, and an initial &apos;+&apos; character in the input
// range will never be matched.
//
// If `fmt` is set, it must be one of the enumerator values of the chars_format.
// (This is despite the fact that chars_format is a bitmask type.)  If set to
// `scientific`, a matching number must contain an exponent.  If set to `fixed`,
// then an exponent will never match.  (For example, the string &quot;1e5&quot; will be
// parsed as &quot;1&quot;.)  If set to `hex`, then a hexadecimal float is parsed in the
// format that strtod() accepts, except that a &quot;0x&quot; prefix is NOT matched.
// (In particular, in `hex` mode, the input &quot;0xff&quot; results in the largest
// matching pattern &quot;0&quot;.)</doc>
<use f='halide/build-apps/abseil-cpp/absl/strings/numbers.cc' l='78' u='c' c='_ZN4absl14lts_2020_02_2510SimpleAtodENS0_11string_viewEPd'/>
