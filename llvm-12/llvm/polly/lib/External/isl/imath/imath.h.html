<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>imath.h source code [llvm/polly/lib/External/isl/imath/imath.h] - Woboq Code Browser</title>
<link rel="stylesheet" href="../../../../../.././data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../../.././data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../../.././data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../../.././data/jquery/jquery-ui.min.js"></script>
<script>var file = 'llvm/polly/lib/External/isl/imath/imath.h'; var root_path = '../../../../../..'; var data_path = '../../../../../.././data'; var ecma_script_api_version = 2;</script>
<script src='../../../../../.././data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../../..'>llvm</a>/<a href='../../../..'>polly</a>/<a href='../../..'>lib</a>/<a href='../..'>External</a>/<a href='..'>isl</a>/<a href='./'>imath</a>/<a href='imath.h.html'>imath.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>/*</i></td></tr>
<tr><th id="2">2</th><td><i>  Name:     imath.h</i></td></tr>
<tr><th id="3">3</th><td><i>  Purpose:  Arbitrary precision integer arithmetic routines.</i></td></tr>
<tr><th id="4">4</th><td><i>  Author:   M. J. Fromberger</i></td></tr>
<tr><th id="5">5</th><td><i></i></td></tr>
<tr><th id="6">6</th><td><i>  Copyright (C) 2002-2007 Michael J. Fromberger, All Rights Reserved.</i></td></tr>
<tr><th id="7">7</th><td><i></i></td></tr>
<tr><th id="8">8</th><td><i>  Permission is hereby granted, free of charge, to any person obtaining a copy</i></td></tr>
<tr><th id="9">9</th><td><i>  of this software and associated documentation files (the "Software"), to deal</i></td></tr>
<tr><th id="10">10</th><td><i>  in the Software without restriction, including without limitation the rights</i></td></tr>
<tr><th id="11">11</th><td><i>  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</i></td></tr>
<tr><th id="12">12</th><td><i>  copies of the Software, and to permit persons to whom the Software is</i></td></tr>
<tr><th id="13">13</th><td><i>  furnished to do so, subject to the following conditions:</i></td></tr>
<tr><th id="14">14</th><td><i></i></td></tr>
<tr><th id="15">15</th><td><i>  The above copyright notice and this permission notice shall be included in</i></td></tr>
<tr><th id="16">16</th><td><i>  all copies or substantial portions of the Software.</i></td></tr>
<tr><th id="17">17</th><td><i></i></td></tr>
<tr><th id="18">18</th><td><i>  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</i></td></tr>
<tr><th id="19">19</th><td><i>  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</i></td></tr>
<tr><th id="20">20</th><td><i>  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE</i></td></tr>
<tr><th id="21">21</th><td><i>  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</i></td></tr>
<tr><th id="22">22</th><td><i>  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</i></td></tr>
<tr><th id="23">23</th><td><i>  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</i></td></tr>
<tr><th id="24">24</th><td><i>  SOFTWARE.</i></td></tr>
<tr><th id="25">25</th><td><i> */</i></td></tr>
<tr><th id="26">26</th><td></td></tr>
<tr><th id="27">27</th><td><u>#<span data-ppcond="27">ifndef</span> <span class="macro" data-ref="_M/IMATH_H_">IMATH_H_</span></u></td></tr>
<tr><th id="28">28</th><td><u>#define <dfn class="macro" id="_M/IMATH_H_" data-ref="_M/IMATH_H_">IMATH_H_</dfn></u></td></tr>
<tr><th id="29">29</th><td></td></tr>
<tr><th id="30">30</th><td><u>#include &lt;limits.h&gt;</u></td></tr>
<tr><th id="31">31</th><td><u>#include &lt;stdbool.h&gt;</u></td></tr>
<tr><th id="32">32</th><td><u>#include &lt;stdint.h&gt;</u></td></tr>
<tr><th id="33">33</th><td></td></tr>
<tr><th id="34">34</th><td><u>#<span data-ppcond="34">ifdef</span> <span class="macro" data-ref="_M/__cplusplus">__cplusplus</span></u></td></tr>
<tr><th id="35">35</th><td><b>extern</b> <q>"C"</q> {</td></tr>
<tr><th id="36">36</th><td><u>#<span data-ppcond="34">endif</span></u></td></tr>
<tr><th id="37">37</th><td></td></tr>
<tr><th id="38">38</th><td><b>typedef</b> <em>unsigned</em> <em>char</em>  <dfn class="typedef" id="mp_sign" title='mp_sign' data-type='unsigned char' data-ref="mp_sign" data-ref-filename="mp_sign">mp_sign</dfn>;</td></tr>
<tr><th id="39">39</th><td><b>typedef</b> <em>unsigned</em> <em>int</em>   <dfn class="typedef" id="mp_size" title='mp_size' data-type='unsigned int' data-ref="mp_size" data-ref-filename="mp_size">mp_size</dfn>;</td></tr>
<tr><th id="40">40</th><td><b>typedef</b> <em>int</em>            <dfn class="typedef" id="mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</dfn>;</td></tr>
<tr><th id="41">41</th><td><b>typedef</b> <em>long</em>           <dfn class="typedef" id="mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</dfn>;  <i>/* must be a signed type */</i></td></tr>
<tr><th id="42">42</th><td><b>typedef</b> <em>unsigned</em> <em>long</em>  <dfn class="typedef" id="mp_usmall" title='mp_usmall' data-type='unsigned long' data-ref="mp_usmall" data-ref-filename="mp_usmall">mp_usmall</dfn>; <i>/* must be an unsigned type */</i></td></tr>
<tr><th id="43">43</th><td></td></tr>
<tr><th id="44">44</th><td></td></tr>
<tr><th id="45">45</th><td><i>/* Build with words as uint64_t by default. */</i></td></tr>
<tr><th id="46">46</th><td><u>#<span data-ppcond="46">ifdef</span> <span class="macro" data-ref="_M/USE_32BIT_WORDS">USE_32BIT_WORDS</span></u></td></tr>
<tr><th id="47">47</th><td><b>typedef</b> uint16_t        mp_digit;</td></tr>
<tr><th id="48">48</th><td><b>typedef</b> uint32_t        mp_word;</td></tr>
<tr><th id="49">49</th><td><u>#  define MP_DIGIT_MAX  (UINT16_MAX * 1UL)</u></td></tr>
<tr><th id="50">50</th><td><u>#  define MP_WORD_MAX   (UINT32_MAX * 1UL)</u></td></tr>
<tr><th id="51">51</th><td><u>#<span data-ppcond="46">else</span></u></td></tr>
<tr><th id="52">52</th><td><b>typedef</b> <a class="typedef" href="../../../../../../include/bits/stdint-uintn.h.html#uint32_t" title='uint32_t' data-type='__uint32_t' data-ref="uint32_t" data-ref-filename="uint32_t">uint32_t</a>        <dfn class="typedef" id="mp_digit" title='mp_digit' data-type='uint32_t' data-ref="mp_digit" data-ref-filename="mp_digit">mp_digit</dfn>;</td></tr>
<tr><th id="53">53</th><td><b>typedef</b> <a class="typedef" href="../../../../../../include/bits/stdint-uintn.h.html#uint64_t" title='uint64_t' data-type='__uint64_t' data-ref="uint64_t" data-ref-filename="uint64_t">uint64_t</a>        <dfn class="typedef" id="mp_word" title='mp_word' data-type='uint64_t' data-ref="mp_word" data-ref-filename="mp_word">mp_word</dfn>;</td></tr>
<tr><th id="54">54</th><td><u>#  define <dfn class="macro" id="_M/MP_DIGIT_MAX" data-ref="_M/MP_DIGIT_MAX">MP_DIGIT_MAX</dfn>  (UINT32_MAX * UINT64_C(1))</u></td></tr>
<tr><th id="55">55</th><td><u>#  define <dfn class="macro" id="_M/MP_WORD_MAX" data-ref="_M/MP_WORD_MAX">MP_WORD_MAX</dfn>   (UINT64_MAX)</u></td></tr>
<tr><th id="56">56</th><td><u>#<span data-ppcond="46">endif</span></u></td></tr>
<tr><th id="57">57</th><td></td></tr>
<tr><th id="58">58</th><td><b>typedef</b> <b>struct</b> {</td></tr>
<tr><th id="59">59</th><td>  <a class="typedef" href="#mp_digit" title='mp_digit' data-type='uint32_t' data-ref="mp_digit" data-ref-filename="mp_digit">mp_digit</a>  <dfn class="decl field" id="(anonymous)::single" title='(anonymous struct)::single' data-ref="(anonymous)::single" data-ref-filename="(anonymous)..single">single</dfn>;</td></tr>
<tr><th id="60">60</th><td>  <a class="typedef" href="#mp_digit" title='mp_digit' data-type='uint32_t' data-ref="mp_digit" data-ref-filename="mp_digit">mp_digit</a>* <dfn class="decl field" id="(anonymous)::digits" title='(anonymous struct)::digits' data-ref="(anonymous)::digits" data-ref-filename="(anonymous)..digits">digits</dfn>;</td></tr>
<tr><th id="61">61</th><td>  <a class="typedef" href="#mp_size" title='mp_size' data-type='unsigned int' data-ref="mp_size" data-ref-filename="mp_size">mp_size</a>   <dfn class="decl field" id="(anonymous)::alloc" title='(anonymous struct)::alloc' data-ref="(anonymous)::alloc" data-ref-filename="(anonymous)..alloc">alloc</dfn>;</td></tr>
<tr><th id="62">62</th><td>  <a class="typedef" href="#mp_size" title='mp_size' data-type='unsigned int' data-ref="mp_size" data-ref-filename="mp_size">mp_size</a>   <dfn class="decl field" id="(anonymous)::used" title='(anonymous struct)::used' data-ref="(anonymous)::used" data-ref-filename="(anonymous)..used">used</dfn>;</td></tr>
<tr><th id="63">63</th><td>  <a class="typedef" href="#mp_sign" title='mp_sign' data-type='unsigned char' data-ref="mp_sign" data-ref-filename="mp_sign">mp_sign</a>   <dfn class="decl field" id="(anonymous)::sign" title='(anonymous struct)::sign' data-ref="(anonymous)::sign" data-ref-filename="(anonymous)..sign">sign</dfn>;</td></tr>
<tr><th id="64">64</th><td>} <dfn class="typedef" id="mpz_t" title='mpz_t' data-type='struct mpz_t' data-ref="mpz_t" data-ref-filename="mpz_t">mpz_t</dfn>, *<dfn class="typedef" id="mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</dfn>;</td></tr>
<tr><th id="65">65</th><td></td></tr>
<tr><th id="66">66</th><td><em>static</em> <b>inline</b> <a class="typedef" href="#mp_digit" title='mp_digit' data-type='uint32_t' data-ref="mp_digit" data-ref-filename="mp_digit">mp_digit</a>* <dfn class="decl def fn" id="MP_DIGITS" title='MP_DIGITS' data-ref="MP_DIGITS" data-ref-filename="MP_DIGITS">MP_DIGITS</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col4 decl" id="44Z" title='Z' data-type='mp_int' data-ref="44Z" data-ref-filename="44Z">Z</dfn>) { <b>return</b> <a class="local col4 ref" href="#44Z" title='Z' data-ref="44Z" data-ref-filename="44Z">Z</a>-&gt;<a class="ref field" href="#(anonymous)::digits" title='(anonymous struct)::digits' data-ref="(anonymous)::digits" data-ref-filename="(anonymous)..digits">digits</a>; }</td></tr>
<tr><th id="67">67</th><td><em>static</em> <b>inline</b> <a class="typedef" href="#mp_size" title='mp_size' data-type='unsigned int' data-ref="mp_size" data-ref-filename="mp_size">mp_size</a>   <dfn class="decl def fn" id="MP_ALLOC" title='MP_ALLOC' data-ref="MP_ALLOC" data-ref-filename="MP_ALLOC">MP_ALLOC</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col5 decl" id="45Z" title='Z' data-type='mp_int' data-ref="45Z" data-ref-filename="45Z">Z</dfn>)  { <b>return</b> <a class="local col5 ref" href="#45Z" title='Z' data-ref="45Z" data-ref-filename="45Z">Z</a>-&gt;<a class="ref field" href="#(anonymous)::alloc" title='(anonymous struct)::alloc' data-ref="(anonymous)::alloc" data-ref-filename="(anonymous)..alloc">alloc</a>; }</td></tr>
<tr><th id="68">68</th><td><em>static</em> <b>inline</b> <a class="typedef" href="#mp_size" title='mp_size' data-type='unsigned int' data-ref="mp_size" data-ref-filename="mp_size">mp_size</a>   <dfn class="decl def fn" id="MP_USED" title='MP_USED' data-ref="MP_USED" data-ref-filename="MP_USED">MP_USED</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col6 decl" id="46Z" title='Z' data-type='mp_int' data-ref="46Z" data-ref-filename="46Z">Z</dfn>)   { <b>return</b> <a class="local col6 ref" href="#46Z" title='Z' data-ref="46Z" data-ref-filename="46Z">Z</a>-&gt;<a class="ref field" href="#(anonymous)::used" title='(anonymous struct)::used' data-ref="(anonymous)::used" data-ref-filename="(anonymous)..used">used</a>; }</td></tr>
<tr><th id="69">69</th><td><em>static</em> <b>inline</b> <a class="typedef" href="#mp_sign" title='mp_sign' data-type='unsigned char' data-ref="mp_sign" data-ref-filename="mp_sign">mp_sign</a>   <dfn class="decl def fn" id="MP_SIGN" title='MP_SIGN' data-ref="MP_SIGN" data-ref-filename="MP_SIGN">MP_SIGN</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col7 decl" id="47Z" title='Z' data-type='mp_int' data-ref="47Z" data-ref-filename="47Z">Z</dfn>)   { <b>return</b> <a class="local col7 ref" href="#47Z" title='Z' data-ref="47Z" data-ref-filename="47Z">Z</a>-&gt;<a class="ref field" href="#(anonymous)::sign" title='(anonymous struct)::sign' data-ref="(anonymous)::sign" data-ref-filename="(anonymous)..sign">sign</a>; }</td></tr>
<tr><th id="70">70</th><td></td></tr>
<tr><th id="71">71</th><td><b>extern</b> <em>const</em> <a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl" id="MP_OK" title='MP_OK' data-ref="MP_OK" data-ref-filename="MP_OK">MP_OK</dfn>;</td></tr>
<tr><th id="72">72</th><td><b>extern</b> <em>const</em> <a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl" id="MP_FALSE" title='MP_FALSE' data-ref="MP_FALSE" data-ref-filename="MP_FALSE">MP_FALSE</dfn>;</td></tr>
<tr><th id="73">73</th><td><b>extern</b> <em>const</em> <a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl" id="MP_TRUE" title='MP_TRUE' data-ref="MP_TRUE" data-ref-filename="MP_TRUE">MP_TRUE</dfn>;</td></tr>
<tr><th id="74">74</th><td><b>extern</b> <em>const</em> <a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl" id="MP_MEMORY" title='MP_MEMORY' data-ref="MP_MEMORY" data-ref-filename="MP_MEMORY">MP_MEMORY</dfn>;</td></tr>
<tr><th id="75">75</th><td><b>extern</b> <em>const</em> <a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl" id="MP_RANGE" title='MP_RANGE' data-ref="MP_RANGE" data-ref-filename="MP_RANGE">MP_RANGE</dfn>;</td></tr>
<tr><th id="76">76</th><td><b>extern</b> <em>const</em> <a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl" id="MP_UNDEF" title='MP_UNDEF' data-ref="MP_UNDEF" data-ref-filename="MP_UNDEF">MP_UNDEF</dfn>;</td></tr>
<tr><th id="77">77</th><td><b>extern</b> <em>const</em> <a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl" id="MP_TRUNC" title='MP_TRUNC' data-ref="MP_TRUNC" data-ref-filename="MP_TRUNC">MP_TRUNC</dfn>;</td></tr>
<tr><th id="78">78</th><td><b>extern</b> <em>const</em> <a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl" id="MP_BADARG" title='MP_BADARG' data-ref="MP_BADARG" data-ref-filename="MP_BADARG">MP_BADARG</dfn>;</td></tr>
<tr><th id="79">79</th><td><b>extern</b> <em>const</em> <a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl" id="MP_MINERR" title='MP_MINERR' data-ref="MP_MINERR" data-ref-filename="MP_MINERR">MP_MINERR</dfn>;</td></tr>
<tr><th id="80">80</th><td></td></tr>
<tr><th id="81">81</th><td><u>#define <dfn class="macro" id="_M/MP_DIGIT_BIT" data-ref="_M/MP_DIGIT_BIT">MP_DIGIT_BIT</dfn>   (sizeof(mp_digit) * CHAR_BIT)</u></td></tr>
<tr><th id="82">82</th><td><u>#define <dfn class="macro" id="_M/MP_WORD_BIT" data-ref="_M/MP_WORD_BIT">MP_WORD_BIT</dfn>    (sizeof(mp_word) * CHAR_BIT)</u></td></tr>
<tr><th id="83">83</th><td><u>#define <dfn class="macro" id="_M/MP_SMALL_MIN" data-ref="_M/MP_SMALL_MIN">MP_SMALL_MIN</dfn>   LONG_MIN</u></td></tr>
<tr><th id="84">84</th><td><u>#define <dfn class="macro" id="_M/MP_SMALL_MAX" data-ref="_M/MP_SMALL_MAX">MP_SMALL_MAX</dfn>   LONG_MAX</u></td></tr>
<tr><th id="85">85</th><td><u>#define <dfn class="macro" id="_M/MP_USMALL_MAX" data-ref="_M/MP_USMALL_MAX">MP_USMALL_MAX</dfn>  ULONG_MAX</u></td></tr>
<tr><th id="86">86</th><td></td></tr>
<tr><th id="87">87</th><td><u>#define <dfn class="macro" id="_M/MP_MIN_RADIX" data-ref="_M/MP_MIN_RADIX">MP_MIN_RADIX</dfn>   2</u></td></tr>
<tr><th id="88">88</th><td><u>#define <dfn class="macro" id="_M/MP_MAX_RADIX" data-ref="_M/MP_MAX_RADIX">MP_MAX_RADIX</dfn>   36</u></td></tr>
<tr><th id="89">89</th><td></td></tr>
<tr><th id="90">90</th><td><i class="doc">/** Sets the default number of digits allocated to an `mp_int` constructed by</i></td></tr>
<tr><th id="91">91</th><td><i class="doc">    `mp_int_init_size()` with `prec == 0`. Allocations are rounded up to</i></td></tr>
<tr><th id="92">92</th><td><i class="doc">    multiples of this value. `MP_DEFAULT_PREC` is the default value. Requires</i></td></tr>
<tr><th id="93">93</th><td><i class="doc">    `ndigits &gt; 0`. */</i></td></tr>
<tr><th id="94">94</th><td><em>void</em> <dfn class="decl fn" id="mp_int_default_precision" title='mp_int_default_precision' data-ref="mp_int_default_precision" data-ref-filename="mp_int_default_precision">mp_int_default_precision</dfn>(<a class="typedef" href="#mp_size" title='mp_size' data-type='unsigned int' data-ref="mp_size" data-ref-filename="mp_size">mp_size</a> <dfn class="local col8 decl" id="48ndigits" title='ndigits' data-type='mp_size' data-ref="48ndigits" data-ref-filename="48ndigits">ndigits</dfn>);</td></tr>
<tr><th id="95">95</th><td></td></tr>
<tr><th id="96">96</th><td><i class="doc">/** Sets the number of digits below which multiplication will use the standard</i></td></tr>
<tr><th id="97">97</th><td><i class="doc">    quadratic "schoolbook" multiplication algorithm rather than Karatsuba-Ofman.</i></td></tr>
<tr><th id="98">98</th><td><i class="doc">    Requires `ndigits &gt;= sizeof(mp_word)`. */</i></td></tr>
<tr><th id="99">99</th><td><em>void</em> <dfn class="decl fn" id="mp_int_multiply_threshold" title='mp_int_multiply_threshold' data-ref="mp_int_multiply_threshold" data-ref-filename="mp_int_multiply_threshold">mp_int_multiply_threshold</dfn>(<a class="typedef" href="#mp_size" title='mp_size' data-type='unsigned int' data-ref="mp_size" data-ref-filename="mp_size">mp_size</a> <dfn class="local col9 decl" id="49ndigits" title='ndigits' data-type='mp_size' data-ref="49ndigits" data-ref-filename="49ndigits">ndigits</dfn>);</td></tr>
<tr><th id="100">100</th><td></td></tr>
<tr><th id="101">101</th><td><i class="doc">/** A sign indicating a (strictly) negative value. */</i></td></tr>
<tr><th id="102">102</th><td><b>extern</b> <em>const</em> <a class="typedef" href="#mp_sign" title='mp_sign' data-type='unsigned char' data-ref="mp_sign" data-ref-filename="mp_sign">mp_sign</a> <dfn class="decl" id="MP_NEG" title='MP_NEG' data-ref="MP_NEG" data-ref-filename="MP_NEG">MP_NEG</dfn>;</td></tr>
<tr><th id="103">103</th><td></td></tr>
<tr><th id="104">104</th><td><i class="doc">/** A sign indicating a zero or positive value. */</i></td></tr>
<tr><th id="105">105</th><td><b>extern</b> <em>const</em> <a class="typedef" href="#mp_sign" title='mp_sign' data-type='unsigned char' data-ref="mp_sign" data-ref-filename="mp_sign">mp_sign</a> <dfn class="decl" id="MP_ZPOS" title='MP_ZPOS' data-ref="MP_ZPOS" data-ref-filename="MP_ZPOS">MP_ZPOS</dfn>;</td></tr>
<tr><th id="106">106</th><td></td></tr>
<tr><th id="107">107</th><td><i class="doc">/** Reports whether `z` is odd, having remainder 1 when divided by 2. */</i></td></tr>
<tr><th id="108">108</th><td><em>static</em> <b>inline</b> <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl def fn" id="mp_int_is_odd" title='mp_int_is_odd' data-ref="mp_int_is_odd" data-ref-filename="mp_int_is_odd">mp_int_is_odd</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col0 decl" id="50z" title='z' data-type='mp_int' data-ref="50z" data-ref-filename="50z">z</dfn>) { <b>return</b> (<a class="local col0 ref" href="#50z" title='z' data-ref="50z" data-ref-filename="50z">z</a>-&gt;<a class="ref field" href="#(anonymous)::digits" title='(anonymous struct)::digits' data-ref="(anonymous)::digits" data-ref-filename="(anonymous)..digits">digits</a>[<var>0</var>] &amp; <var>1</var>) != <var>0</var>; }</td></tr>
<tr><th id="109">109</th><td></td></tr>
<tr><th id="110">110</th><td><i class="doc">/** Reports whether `z` is even, having remainder 0 when divided by 2. */</i></td></tr>
<tr><th id="111">111</th><td><em>static</em> <b>inline</b> <span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl def fn" id="mp_int_is_even" title='mp_int_is_even' data-ref="mp_int_is_even" data-ref-filename="mp_int_is_even">mp_int_is_even</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col1 decl" id="51z" title='z' data-type='mp_int' data-ref="51z" data-ref-filename="51z">z</dfn>) { <b>return</b> (<a class="local col1 ref" href="#51z" title='z' data-ref="51z" data-ref-filename="51z">z</a>-&gt;<a class="ref field" href="#(anonymous)::digits" title='(anonymous struct)::digits' data-ref="(anonymous)::digits" data-ref-filename="(anonymous)..digits">digits</a>[<var>0</var>] &amp; <var>1</var>) == <var>0</var>; }</td></tr>
<tr><th id="112">112</th><td></td></tr>
<tr><th id="113">113</th><td><i class="doc">/** Initializes `z` with 1-digit precision and sets it to zero.  This function</i></td></tr>
<tr><th id="114">114</th><td><i class="doc">    cannot fail unless `z == NULL`. */</i></td></tr>
<tr><th id="115">115</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_init" title='mp_int_init' data-ref="mp_int_init" data-ref-filename="mp_int_init">mp_int_init</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col2 decl" id="52z" title='z' data-type='mp_int' data-ref="52z" data-ref-filename="52z">z</dfn>);</td></tr>
<tr><th id="116">116</th><td></td></tr>
<tr><th id="117">117</th><td><i class="doc">/** Allocates a fresh zero-valued `mpz_t` on the heap, returning NULL in case</i></td></tr>
<tr><th id="118">118</th><td><i class="doc">    of error. The only possible error is out-of-memory. */</i></td></tr>
<tr><th id="119">119</th><td><a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="decl fn" id="mp_int_alloc" title='mp_int_alloc' data-ref="mp_int_alloc" data-ref-filename="mp_int_alloc">mp_int_alloc</dfn>(<em>void</em>);</td></tr>
<tr><th id="120">120</th><td></td></tr>
<tr><th id="121">121</th><td><i class="doc">/** Initializes `z` with at least `prec` digits of storage, and sets it to</i></td></tr>
<tr><th id="122">122</th><td><i class="doc">    zero. If `prec` is zero, the default precision is used. In either case the</i></td></tr>
<tr><th id="123">123</th><td><i class="doc">    size is rounded up to the nearest multiple of the word size. */</i></td></tr>
<tr><th id="124">124</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_init_size" title='mp_int_init_size' data-ref="mp_int_init_size" data-ref-filename="mp_int_init_size">mp_int_init_size</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col3 decl" id="53z" title='z' data-type='mp_int' data-ref="53z" data-ref-filename="53z">z</dfn>, <a class="typedef" href="#mp_size" title='mp_size' data-type='unsigned int' data-ref="mp_size" data-ref-filename="mp_size">mp_size</a> <dfn class="local col4 decl" id="54prec" title='prec' data-type='mp_size' data-ref="54prec" data-ref-filename="54prec">prec</dfn>);</td></tr>
<tr><th id="125">125</th><td></td></tr>
<tr><th id="126">126</th><td><i class="doc">/** Initializes `z` to be a copy of an already-initialized value in `old`. The</i></td></tr>
<tr><th id="127">127</th><td><i class="doc">    new copy does not share storage with the original. */</i></td></tr>
<tr><th id="128">128</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_init_copy" title='mp_int_init_copy' data-ref="mp_int_init_copy" data-ref-filename="mp_int_init_copy">mp_int_init_copy</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col5 decl" id="55z" title='z' data-type='mp_int' data-ref="55z" data-ref-filename="55z">z</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col6 decl" id="56old" title='old' data-type='mp_int' data-ref="56old" data-ref-filename="56old">old</dfn>);</td></tr>
<tr><th id="129">129</th><td></td></tr>
<tr><th id="130">130</th><td><i class="doc">/** Initializes `z` to the specified signed `value` at default precision. */</i></td></tr>
<tr><th id="131">131</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_init_value" title='mp_int_init_value' data-ref="mp_int_init_value" data-ref-filename="mp_int_init_value">mp_int_init_value</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col7 decl" id="57z" title='z' data-type='mp_int' data-ref="57z" data-ref-filename="57z">z</dfn>, <a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> <dfn class="local col8 decl" id="58value" title='value' data-type='mp_small' data-ref="58value" data-ref-filename="58value">value</dfn>);</td></tr>
<tr><th id="132">132</th><td></td></tr>
<tr><th id="133">133</th><td><i class="doc">/** Initializes `z` to the specified unsigned `value` at default precision. */</i></td></tr>
<tr><th id="134">134</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_init_uvalue" title='mp_int_init_uvalue' data-ref="mp_int_init_uvalue" data-ref-filename="mp_int_init_uvalue">mp_int_init_uvalue</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col9 decl" id="59z" title='z' data-type='mp_int' data-ref="59z" data-ref-filename="59z">z</dfn>, <a class="typedef" href="#mp_usmall" title='mp_usmall' data-type='unsigned long' data-ref="mp_usmall" data-ref-filename="mp_usmall">mp_usmall</a> <dfn class="local col0 decl" id="60uvalue" title='uvalue' data-type='mp_usmall' data-ref="60uvalue" data-ref-filename="60uvalue">uvalue</dfn>);</td></tr>
<tr><th id="135">135</th><td></td></tr>
<tr><th id="136">136</th><td><i class="doc">/** Sets `z` to the value of the specified signed `value`. */</i></td></tr>
<tr><th id="137">137</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_set_value" title='mp_int_set_value' data-ref="mp_int_set_value" data-ref-filename="mp_int_set_value">mp_int_set_value</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col1 decl" id="61z" title='z' data-type='mp_int' data-ref="61z" data-ref-filename="61z">z</dfn>, <a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> <dfn class="local col2 decl" id="62value" title='value' data-type='mp_small' data-ref="62value" data-ref-filename="62value">value</dfn>);</td></tr>
<tr><th id="138">138</th><td></td></tr>
<tr><th id="139">139</th><td><i class="doc">/** Sets `z` to the value of the specified unsigned `value`. */</i></td></tr>
<tr><th id="140">140</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_set_uvalue" title='mp_int_set_uvalue' data-ref="mp_int_set_uvalue" data-ref-filename="mp_int_set_uvalue">mp_int_set_uvalue</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col3 decl" id="63z" title='z' data-type='mp_int' data-ref="63z" data-ref-filename="63z">z</dfn>, <a class="typedef" href="#mp_usmall" title='mp_usmall' data-type='unsigned long' data-ref="mp_usmall" data-ref-filename="mp_usmall">mp_usmall</a> <dfn class="local col4 decl" id="64uvalue" title='uvalue' data-type='mp_usmall' data-ref="64uvalue" data-ref-filename="64uvalue">uvalue</dfn>);</td></tr>
<tr><th id="141">141</th><td></td></tr>
<tr><th id="142">142</th><td><i class="doc">/** Releases the storage used by `z`. */</i></td></tr>
<tr><th id="143">143</th><td><em>void</em> <dfn class="decl fn" id="mp_int_clear" title='mp_int_clear' data-ref="mp_int_clear" data-ref-filename="mp_int_clear">mp_int_clear</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col5 decl" id="65z" title='z' data-type='mp_int' data-ref="65z" data-ref-filename="65z">z</dfn>);</td></tr>
<tr><th id="144">144</th><td></td></tr>
<tr><th id="145">145</th><td><i class="doc">/** Releases the storage used by `z` and also `z` itself.</i></td></tr>
<tr><th id="146">146</th><td><i class="doc">    This should only be used for `z` allocated by `mp_int_alloc()`. */</i></td></tr>
<tr><th id="147">147</th><td><em>void</em> <dfn class="decl fn" id="mp_int_free" title='mp_int_free' data-ref="mp_int_free" data-ref-filename="mp_int_free">mp_int_free</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col6 decl" id="66z" title='z' data-type='mp_int' data-ref="66z" data-ref-filename="66z">z</dfn>);</td></tr>
<tr><th id="148">148</th><td></td></tr>
<tr><th id="149">149</th><td><i class="doc">/** Replaces the value of `c` with a copy of the value of `a`. No new memory is</i></td></tr>
<tr><th id="150">150</th><td><i class="doc">    allocated unless `a` has more significant digits than `c` has allocated. */</i></td></tr>
<tr><th id="151">151</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_copy" title='mp_int_copy' data-ref="mp_int_copy" data-ref-filename="mp_int_copy">mp_int_copy</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col7 decl" id="67a" title='a' data-type='mp_int' data-ref="67a" data-ref-filename="67a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col8 decl" id="68c" title='c' data-type='mp_int' data-ref="68c" data-ref-filename="68c">c</dfn>);</td></tr>
<tr><th id="152">152</th><td></td></tr>
<tr><th id="153">153</th><td><i class="doc">/** Swaps the values and storage between `a` and `c`. */</i></td></tr>
<tr><th id="154">154</th><td><em>void</em> <dfn class="decl fn" id="mp_int_swap" title='mp_int_swap' data-ref="mp_int_swap" data-ref-filename="mp_int_swap">mp_int_swap</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col9 decl" id="69a" title='a' data-type='mp_int' data-ref="69a" data-ref-filename="69a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col0 decl" id="70c" title='c' data-type='mp_int' data-ref="70c" data-ref-filename="70c">c</dfn>);</td></tr>
<tr><th id="155">155</th><td></td></tr>
<tr><th id="156">156</th><td><i class="doc">/** Sets `z` to zero. The allocated storage of `z` is not changed. */</i></td></tr>
<tr><th id="157">157</th><td><em>void</em> <dfn class="decl fn" id="mp_int_zero" title='mp_int_zero' data-ref="mp_int_zero" data-ref-filename="mp_int_zero">mp_int_zero</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col1 decl" id="71z" title='z' data-type='mp_int' data-ref="71z" data-ref-filename="71z">z</dfn>);</td></tr>
<tr><th id="158">158</th><td></td></tr>
<tr><th id="159">159</th><td><i class="doc">/** Sets `c` to the absolute value of `a`. */</i></td></tr>
<tr><th id="160">160</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_abs" title='mp_int_abs' data-ref="mp_int_abs" data-ref-filename="mp_int_abs">mp_int_abs</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col2 decl" id="72a" title='a' data-type='mp_int' data-ref="72a" data-ref-filename="72a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col3 decl" id="73c" title='c' data-type='mp_int' data-ref="73c" data-ref-filename="73c">c</dfn>);</td></tr>
<tr><th id="161">161</th><td></td></tr>
<tr><th id="162">162</th><td><i class="doc">/** Sets `c` to the additive inverse (negation) of `a`. */</i></td></tr>
<tr><th id="163">163</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_neg" title='mp_int_neg' data-ref="mp_int_neg" data-ref-filename="mp_int_neg">mp_int_neg</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col4 decl" id="74a" title='a' data-type='mp_int' data-ref="74a" data-ref-filename="74a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col5 decl" id="75c" title='c' data-type='mp_int' data-ref="75c" data-ref-filename="75c">c</dfn>);</td></tr>
<tr><th id="164">164</th><td></td></tr>
<tr><th id="165">165</th><td><i class="doc">/** Sets `c` to the sum of `a` and `b`. */</i></td></tr>
<tr><th id="166">166</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_add" title='mp_int_add' data-ref="mp_int_add" data-ref-filename="mp_int_add">mp_int_add</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col6 decl" id="76a" title='a' data-type='mp_int' data-ref="76a" data-ref-filename="76a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col7 decl" id="77b" title='b' data-type='mp_int' data-ref="77b" data-ref-filename="77b">b</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col8 decl" id="78c" title='c' data-type='mp_int' data-ref="78c" data-ref-filename="78c">c</dfn>);</td></tr>
<tr><th id="167">167</th><td></td></tr>
<tr><th id="168">168</th><td><i class="doc">/** Sets `c` to the sum of `a` and `value`. */</i></td></tr>
<tr><th id="169">169</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_add_value" title='mp_int_add_value' data-ref="mp_int_add_value" data-ref-filename="mp_int_add_value">mp_int_add_value</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col9 decl" id="79a" title='a' data-type='mp_int' data-ref="79a" data-ref-filename="79a">a</dfn>, <a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> <dfn class="local col0 decl" id="80value" title='value' data-type='mp_small' data-ref="80value" data-ref-filename="80value">value</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col1 decl" id="81c" title='c' data-type='mp_int' data-ref="81c" data-ref-filename="81c">c</dfn>);</td></tr>
<tr><th id="170">170</th><td></td></tr>
<tr><th id="171">171</th><td><i class="doc">/** Sets `c` to the difference of `a` less `b`. */</i></td></tr>
<tr><th id="172">172</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_sub" title='mp_int_sub' data-ref="mp_int_sub" data-ref-filename="mp_int_sub">mp_int_sub</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col2 decl" id="82a" title='a' data-type='mp_int' data-ref="82a" data-ref-filename="82a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col3 decl" id="83b" title='b' data-type='mp_int' data-ref="83b" data-ref-filename="83b">b</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col4 decl" id="84c" title='c' data-type='mp_int' data-ref="84c" data-ref-filename="84c">c</dfn>);</td></tr>
<tr><th id="173">173</th><td></td></tr>
<tr><th id="174">174</th><td><i class="doc">/** Sets `c` to the difference of `a` less `value`. */</i></td></tr>
<tr><th id="175">175</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_sub_value" title='mp_int_sub_value' data-ref="mp_int_sub_value" data-ref-filename="mp_int_sub_value">mp_int_sub_value</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col5 decl" id="85a" title='a' data-type='mp_int' data-ref="85a" data-ref-filename="85a">a</dfn>, <a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> <dfn class="local col6 decl" id="86value" title='value' data-type='mp_small' data-ref="86value" data-ref-filename="86value">value</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col7 decl" id="87c" title='c' data-type='mp_int' data-ref="87c" data-ref-filename="87c">c</dfn>);</td></tr>
<tr><th id="176">176</th><td></td></tr>
<tr><th id="177">177</th><td><i class="doc">/** Sets `c` to the product of `a` and `b`. */</i></td></tr>
<tr><th id="178">178</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_mul" title='mp_int_mul' data-ref="mp_int_mul" data-ref-filename="mp_int_mul">mp_int_mul</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col8 decl" id="88a" title='a' data-type='mp_int' data-ref="88a" data-ref-filename="88a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col9 decl" id="89b" title='b' data-type='mp_int' data-ref="89b" data-ref-filename="89b">b</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col0 decl" id="90c" title='c' data-type='mp_int' data-ref="90c" data-ref-filename="90c">c</dfn>);</td></tr>
<tr><th id="179">179</th><td></td></tr>
<tr><th id="180">180</th><td><i class="doc">/** Sets `c` to the product of `a` and `value`. */</i></td></tr>
<tr><th id="181">181</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_mul_value" title='mp_int_mul_value' data-ref="mp_int_mul_value" data-ref-filename="mp_int_mul_value">mp_int_mul_value</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col1 decl" id="91a" title='a' data-type='mp_int' data-ref="91a" data-ref-filename="91a">a</dfn>, <a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> <dfn class="local col2 decl" id="92value" title='value' data-type='mp_small' data-ref="92value" data-ref-filename="92value">value</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col3 decl" id="93c" title='c' data-type='mp_int' data-ref="93c" data-ref-filename="93c">c</dfn>);</td></tr>
<tr><th id="182">182</th><td></td></tr>
<tr><th id="183">183</th><td><i class="doc">/** Sets `c` to the product of `a` and `2^p2`. Requires `p2 &gt;= 0`. */</i></td></tr>
<tr><th id="184">184</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_mul_pow2" title='mp_int_mul_pow2' data-ref="mp_int_mul_pow2" data-ref-filename="mp_int_mul_pow2">mp_int_mul_pow2</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col4 decl" id="94a" title='a' data-type='mp_int' data-ref="94a" data-ref-filename="94a">a</dfn>, <a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> <dfn class="local col5 decl" id="95p2" title='p2' data-type='mp_small' data-ref="95p2" data-ref-filename="95p2">p2</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col6 decl" id="96c" title='c' data-type='mp_int' data-ref="96c" data-ref-filename="96c">c</dfn>);</td></tr>
<tr><th id="185">185</th><td></td></tr>
<tr><th id="186">186</th><td><i class="doc">/** Sets `c` to the square of `a`. */</i></td></tr>
<tr><th id="187">187</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_sqr" title='mp_int_sqr' data-ref="mp_int_sqr" data-ref-filename="mp_int_sqr">mp_int_sqr</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col7 decl" id="97a" title='a' data-type='mp_int' data-ref="97a" data-ref-filename="97a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col8 decl" id="98c" title='c' data-type='mp_int' data-ref="98c" data-ref-filename="98c">c</dfn>);</td></tr>
<tr><th id="188">188</th><td></td></tr>
<tr><th id="189">189</th><td><i class="doc">/** Sets `q` and `r` to the quotent and remainder of `a / b`. Division by</i></td></tr>
<tr><th id="190">190</th><td><i class="doc">    powers of 2 is detected and handled efficiently.  The remainder is pinned</i></td></tr>
<tr><th id="191">191</th><td><i class="doc">    to `0 &lt;= r &lt; b`.</i></td></tr>
<tr><th id="192">192</th><td><i class="doc"></i></td></tr>
<tr><th id="193">193</th><td><i class="doc">    Either of `q` or `r` may be NULL, but not both, and `q` and `r` may not</i></td></tr>
<tr><th id="194">194</th><td><i class="doc">    point to the same value. */</i></td></tr>
<tr><th id="195">195</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_div" title='mp_int_div' data-ref="mp_int_div" data-ref-filename="mp_int_div">mp_int_div</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col9 decl" id="99a" title='a' data-type='mp_int' data-ref="99a" data-ref-filename="99a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col0 decl" id="100b" title='b' data-type='mp_int' data-ref="100b" data-ref-filename="100b">b</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col1 decl" id="101q" title='q' data-type='mp_int' data-ref="101q" data-ref-filename="101q">q</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col2 decl" id="102r" title='r' data-type='mp_int' data-ref="102r" data-ref-filename="102r">r</dfn>);</td></tr>
<tr><th id="196">196</th><td></td></tr>
<tr><th id="197">197</th><td><i class="doc">/** Sets `q` and `*r` to the quotent and remainder of `a / value`. Division by</i></td></tr>
<tr><th id="198">198</th><td><i class="doc">    powers of 2 is detected and handled efficiently. The remainder is pinned to</i></td></tr>
<tr><th id="199">199</th><td><i class="doc">    `0 &lt;= *r &lt; b`. Either of `q` or `r` may be NULL. */</i></td></tr>
<tr><th id="200">200</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_div_value" title='mp_int_div_value' data-ref="mp_int_div_value" data-ref-filename="mp_int_div_value">mp_int_div_value</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col3 decl" id="103a" title='a' data-type='mp_int' data-ref="103a" data-ref-filename="103a">a</dfn>, <a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> <dfn class="local col4 decl" id="104value" title='value' data-type='mp_small' data-ref="104value" data-ref-filename="104value">value</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col5 decl" id="105q" title='q' data-type='mp_int' data-ref="105q" data-ref-filename="105q">q</dfn>, <a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> *<dfn class="local col6 decl" id="106r" title='r' data-type='mp_small *' data-ref="106r" data-ref-filename="106r">r</dfn>);</td></tr>
<tr><th id="201">201</th><td></td></tr>
<tr><th id="202">202</th><td><i class="doc">/** Sets `q` and `r` to the quotient and remainder of `a / 2^p2`. This is a</i></td></tr>
<tr><th id="203">203</th><td><i class="doc">    special case for division by powers of two that is more efficient than</i></td></tr>
<tr><th id="204">204</th><td><i class="doc">    using ordinary division. Note that `mp_int_div()` will automatically handle</i></td></tr>
<tr><th id="205">205</th><td><i class="doc">    this case, this function is for cases where you have only the exponent. */</i></td></tr>
<tr><th id="206">206</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_div_pow2" title='mp_int_div_pow2' data-ref="mp_int_div_pow2" data-ref-filename="mp_int_div_pow2">mp_int_div_pow2</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col7 decl" id="107a" title='a' data-type='mp_int' data-ref="107a" data-ref-filename="107a">a</dfn>, <a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> <dfn class="local col8 decl" id="108p2" title='p2' data-type='mp_small' data-ref="108p2" data-ref-filename="108p2">p2</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col9 decl" id="109q" title='q' data-type='mp_int' data-ref="109q" data-ref-filename="109q">q</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col0 decl" id="110r" title='r' data-type='mp_int' data-ref="110r" data-ref-filename="110r">r</dfn>);</td></tr>
<tr><th id="207">207</th><td></td></tr>
<tr><th id="208">208</th><td><i class="doc">/** Sets `c` to the remainder of `a / m`.</i></td></tr>
<tr><th id="209">209</th><td><i class="doc">    The remainder is pinned to `0 &lt;= c &lt; m`. */</i></td></tr>
<tr><th id="210">210</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_mod" title='mp_int_mod' data-ref="mp_int_mod" data-ref-filename="mp_int_mod">mp_int_mod</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col1 decl" id="111a" title='a' data-type='mp_int' data-ref="111a" data-ref-filename="111a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col2 decl" id="112m" title='m' data-type='mp_int' data-ref="112m" data-ref-filename="112m">m</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col3 decl" id="113c" title='c' data-type='mp_int' data-ref="113c" data-ref-filename="113c">c</dfn>);</td></tr>
<tr><th id="211">211</th><td></td></tr>
<tr><th id="212">212</th><td><i class="doc">/** Sets `c` to the value of `a` raised to the `b` power.</i></td></tr>
<tr><th id="213">213</th><td><i class="doc">    It returns `MP_RANGE` if `b &lt; 0`. */</i></td></tr>
<tr><th id="214">214</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_expt" title='mp_int_expt' data-ref="mp_int_expt" data-ref-filename="mp_int_expt">mp_int_expt</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col4 decl" id="114a" title='a' data-type='mp_int' data-ref="114a" data-ref-filename="114a">a</dfn>, <a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> <dfn class="local col5 decl" id="115b" title='b' data-type='mp_small' data-ref="115b" data-ref-filename="115b">b</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col6 decl" id="116c" title='c' data-type='mp_int' data-ref="116c" data-ref-filename="116c">c</dfn>);</td></tr>
<tr><th id="215">215</th><td></td></tr>
<tr><th id="216">216</th><td><i class="doc">/** Sets `c` to the value of `a` raised to the `b` power.</i></td></tr>
<tr><th id="217">217</th><td><i class="doc">    It returns `MP_RANGE` if `b &lt; 0`. */</i></td></tr>
<tr><th id="218">218</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_expt_value" title='mp_int_expt_value' data-ref="mp_int_expt_value" data-ref-filename="mp_int_expt_value">mp_int_expt_value</dfn>(<a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> <dfn class="local col7 decl" id="117a" title='a' data-type='mp_small' data-ref="117a" data-ref-filename="117a">a</dfn>, <a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> <dfn class="local col8 decl" id="118b" title='b' data-type='mp_small' data-ref="118b" data-ref-filename="118b">b</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col9 decl" id="119c" title='c' data-type='mp_int' data-ref="119c" data-ref-filename="119c">c</dfn>);</td></tr>
<tr><th id="219">219</th><td></td></tr>
<tr><th id="220">220</th><td><i class="doc">/** Sets `c` to the value of `a` raised to the `b` power.</i></td></tr>
<tr><th id="221">221</th><td><i class="doc">    It returns `MP_RANGE`) if `b &lt; 0`. */</i></td></tr>
<tr><th id="222">222</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_expt_full" title='mp_int_expt_full' data-ref="mp_int_expt_full" data-ref-filename="mp_int_expt_full">mp_int_expt_full</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col0 decl" id="120a" title='a' data-type='mp_int' data-ref="120a" data-ref-filename="120a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col1 decl" id="121b" title='b' data-type='mp_int' data-ref="121b" data-ref-filename="121b">b</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col2 decl" id="122c" title='c' data-type='mp_int' data-ref="122c" data-ref-filename="122c">c</dfn>);</td></tr>
<tr><th id="223">223</th><td></td></tr>
<tr><th id="224">224</th><td><i class="doc">/** Sets `*r` to the remainder of `a / value`.</i></td></tr>
<tr><th id="225">225</th><td><i class="doc">    The remainder is pinned to `0 &lt;= r &lt; value`. */</i></td></tr>
<tr><th id="226">226</th><td><em>static</em> <b>inline</b></td></tr>
<tr><th id="227">227</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl def fn" id="mp_int_mod_value" title='mp_int_mod_value' data-ref="mp_int_mod_value" data-ref-filename="mp_int_mod_value">mp_int_mod_value</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col3 decl" id="123a" title='a' data-type='mp_int' data-ref="123a" data-ref-filename="123a">a</dfn>, <a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> <dfn class="local col4 decl" id="124value" title='value' data-type='mp_small' data-ref="124value" data-ref-filename="124value">value</dfn>, <a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a>* <dfn class="local col5 decl" id="125r" title='r' data-type='mp_small *' data-ref="125r" data-ref-filename="125r">r</dfn>) {</td></tr>
<tr><th id="228">228</th><td>  <b>return</b> <a class="ref fn" href="#mp_int_div_value" title='mp_int_div_value' data-ref="mp_int_div_value" data-ref-filename="mp_int_div_value">mp_int_div_value</a>(<a class="local col3 ref" href="#123a" title='a' data-ref="123a" data-ref-filename="123a">a</a>, <a class="local col4 ref" href="#124value" title='value' data-ref="124value" data-ref-filename="124value">value</a>, <var>0</var>, <a class="local col5 ref" href="#125r" title='r' data-ref="125r" data-ref-filename="125r">r</a>);</td></tr>
<tr><th id="229">229</th><td>}</td></tr>
<tr><th id="230">230</th><td></td></tr>
<tr><th id="231">231</th><td><i class="doc">/** Returns the comparator of `a` and `b`. */</i></td></tr>
<tr><th id="232">232</th><td><em>int</em> <dfn class="decl fn" id="mp_int_compare" title='mp_int_compare' data-ref="mp_int_compare" data-ref-filename="mp_int_compare">mp_int_compare</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col6 decl" id="126a" title='a' data-type='mp_int' data-ref="126a" data-ref-filename="126a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col7 decl" id="127b" title='b' data-type='mp_int' data-ref="127b" data-ref-filename="127b">b</dfn>);</td></tr>
<tr><th id="233">233</th><td></td></tr>
<tr><th id="234">234</th><td><i class="doc">/** Returns the comparator of the magnitudes of `a` and `b`, disregarding their</i></td></tr>
<tr><th id="235">235</th><td><i class="doc">    signs. Neither `a` nor `b` is modified by the comparison. */</i></td></tr>
<tr><th id="236">236</th><td><em>int</em> <dfn class="decl fn" id="mp_int_compare_unsigned" title='mp_int_compare_unsigned' data-ref="mp_int_compare_unsigned" data-ref-filename="mp_int_compare_unsigned">mp_int_compare_unsigned</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col8 decl" id="128a" title='a' data-type='mp_int' data-ref="128a" data-ref-filename="128a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col9 decl" id="129b" title='b' data-type='mp_int' data-ref="129b" data-ref-filename="129b">b</dfn>);</td></tr>
<tr><th id="237">237</th><td></td></tr>
<tr><th id="238">238</th><td><i class="doc">/** Returns the comparator of `z` and zero. */</i></td></tr>
<tr><th id="239">239</th><td><em>int</em> <dfn class="decl fn" id="mp_int_compare_zero" title='mp_int_compare_zero' data-ref="mp_int_compare_zero" data-ref-filename="mp_int_compare_zero">mp_int_compare_zero</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col0 decl" id="130z" title='z' data-type='mp_int' data-ref="130z" data-ref-filename="130z">z</dfn>);</td></tr>
<tr><th id="240">240</th><td></td></tr>
<tr><th id="241">241</th><td><i class="doc">/** Returns the comparator of `z` and the signed value `v`. */</i></td></tr>
<tr><th id="242">242</th><td><em>int</em> <dfn class="decl fn" id="mp_int_compare_value" title='mp_int_compare_value' data-ref="mp_int_compare_value" data-ref-filename="mp_int_compare_value">mp_int_compare_value</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col1 decl" id="131z" title='z' data-type='mp_int' data-ref="131z" data-ref-filename="131z">z</dfn>, <a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> <dfn class="local col2 decl" id="132v" title='v' data-type='mp_small' data-ref="132v" data-ref-filename="132v">v</dfn>);</td></tr>
<tr><th id="243">243</th><td></td></tr>
<tr><th id="244">244</th><td><i class="doc">/** Returns the comparator of `z` and the unsigned value `uv`. */</i></td></tr>
<tr><th id="245">245</th><td><em>int</em> <dfn class="decl fn" id="mp_int_compare_uvalue" title='mp_int_compare_uvalue' data-ref="mp_int_compare_uvalue" data-ref-filename="mp_int_compare_uvalue">mp_int_compare_uvalue</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col3 decl" id="133z" title='z' data-type='mp_int' data-ref="133z" data-ref-filename="133z">z</dfn>, <a class="typedef" href="#mp_usmall" title='mp_usmall' data-type='unsigned long' data-ref="mp_usmall" data-ref-filename="mp_usmall">mp_usmall</a> <dfn class="local col4 decl" id="134uv" title='uv' data-type='mp_usmall' data-ref="134uv" data-ref-filename="134uv">uv</dfn>);</td></tr>
<tr><th id="246">246</th><td></td></tr>
<tr><th id="247">247</th><td><i class="doc">/** Reports whether `a` is divisible by `v`. */</i></td></tr>
<tr><th id="248">248</th><td><span class="macro" title="_Bool" data-ref="_M/bool">bool</span> <dfn class="decl fn" id="mp_int_divisible_value" title='mp_int_divisible_value' data-ref="mp_int_divisible_value" data-ref-filename="mp_int_divisible_value">mp_int_divisible_value</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col5 decl" id="135a" title='a' data-type='mp_int' data-ref="135a" data-ref-filename="135a">a</dfn>, <a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> <dfn class="local col6 decl" id="136v" title='v' data-type='mp_small' data-ref="136v" data-ref-filename="136v">v</dfn>);</td></tr>
<tr><th id="249">249</th><td></td></tr>
<tr><th id="250">250</th><td><i class="doc">/** Returns `k &gt;= 0` such that `z` is `2^k`, if such a `k` exists. If no such</i></td></tr>
<tr><th id="251">251</th><td><i class="doc">    `k` exists, the function returns -1. */</i></td></tr>
<tr><th id="252">252</th><td><em>int</em> <dfn class="decl fn" id="mp_int_is_pow2" title='mp_int_is_pow2' data-ref="mp_int_is_pow2" data-ref-filename="mp_int_is_pow2">mp_int_is_pow2</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col7 decl" id="137z" title='z' data-type='mp_int' data-ref="137z" data-ref-filename="137z">z</dfn>);</td></tr>
<tr><th id="253">253</th><td></td></tr>
<tr><th id="254">254</th><td><i class="doc">/** Sets `c` to the value of `a` raised to the `b` power, reduced modulo `m`.</i></td></tr>
<tr><th id="255">255</th><td><i class="doc">    It returns `MP_RANGE` if `b &lt; 0` or `MP_UNDEF` if `m == 0`. */</i></td></tr>
<tr><th id="256">256</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_exptmod" title='mp_int_exptmod' data-ref="mp_int_exptmod" data-ref-filename="mp_int_exptmod">mp_int_exptmod</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col8 decl" id="138a" title='a' data-type='mp_int' data-ref="138a" data-ref-filename="138a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col9 decl" id="139b" title='b' data-type='mp_int' data-ref="139b" data-ref-filename="139b">b</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col0 decl" id="140m" title='m' data-type='mp_int' data-ref="140m" data-ref-filename="140m">m</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col1 decl" id="141c" title='c' data-type='mp_int' data-ref="141c" data-ref-filename="141c">c</dfn>);</td></tr>
<tr><th id="257">257</th><td></td></tr>
<tr><th id="258">258</th><td><i class="doc">/** Sets `c` to the value of `a` raised to the `value` power, modulo `m`.</i></td></tr>
<tr><th id="259">259</th><td><i class="doc">    It returns `MP_RANGE` if `value &lt; 0` or `MP_UNDEF` if `m == 0`. */</i></td></tr>
<tr><th id="260">260</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_exptmod_evalue" title='mp_int_exptmod_evalue' data-ref="mp_int_exptmod_evalue" data-ref-filename="mp_int_exptmod_evalue">mp_int_exptmod_evalue</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col2 decl" id="142a" title='a' data-type='mp_int' data-ref="142a" data-ref-filename="142a">a</dfn>, <a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> <dfn class="local col3 decl" id="143value" title='value' data-type='mp_small' data-ref="143value" data-ref-filename="143value">value</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col4 decl" id="144m" title='m' data-type='mp_int' data-ref="144m" data-ref-filename="144m">m</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col5 decl" id="145c" title='c' data-type='mp_int' data-ref="145c" data-ref-filename="145c">c</dfn>);</td></tr>
<tr><th id="261">261</th><td></td></tr>
<tr><th id="262">262</th><td><i class="doc">/** Sets `c` to the value of `value` raised to the `b` power, modulo `m`.</i></td></tr>
<tr><th id="263">263</th><td><i class="doc">    It returns `MP_RANGE` if `b &lt; 0` or `MP_UNDEF` if `m == 0`. */</i></td></tr>
<tr><th id="264">264</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_exptmod_bvalue" title='mp_int_exptmod_bvalue' data-ref="mp_int_exptmod_bvalue" data-ref-filename="mp_int_exptmod_bvalue">mp_int_exptmod_bvalue</dfn>(<a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> <dfn class="local col6 decl" id="146value" title='value' data-type='mp_small' data-ref="146value" data-ref-filename="146value">value</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col7 decl" id="147b" title='b' data-type='mp_int' data-ref="147b" data-ref-filename="147b">b</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col8 decl" id="148m" title='m' data-type='mp_int' data-ref="148m" data-ref-filename="148m">m</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col9 decl" id="149c" title='c' data-type='mp_int' data-ref="149c" data-ref-filename="149c">c</dfn>);</td></tr>
<tr><th id="265">265</th><td></td></tr>
<tr><th id="266">266</th><td><i class="doc">/** Sets `c` to the value of `a` raised to the `b` power, reduced modulo `m`,</i></td></tr>
<tr><th id="267">267</th><td><i class="doc">    given a precomputed reduction constant `mu` defined for Barrett's modular</i></td></tr>
<tr><th id="268">268</th><td><i class="doc">    reduction algorithm.</i></td></tr>
<tr><th id="269">269</th><td><i class="doc"></i></td></tr>
<tr><th id="270">270</th><td><i class="doc">    It returns `MP_RANGE` if `b &lt; 0` or `MP_UNDEF` if `m == 0`. */</i></td></tr>
<tr><th id="271">271</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_exptmod_known" title='mp_int_exptmod_known' data-ref="mp_int_exptmod_known" data-ref-filename="mp_int_exptmod_known">mp_int_exptmod_known</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col0 decl" id="150a" title='a' data-type='mp_int' data-ref="150a" data-ref-filename="150a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col1 decl" id="151b" title='b' data-type='mp_int' data-ref="151b" data-ref-filename="151b">b</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col2 decl" id="152m" title='m' data-type='mp_int' data-ref="152m" data-ref-filename="152m">m</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col3 decl" id="153mu" title='mu' data-type='mp_int' data-ref="153mu" data-ref-filename="153mu">mu</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col4 decl" id="154c" title='c' data-type='mp_int' data-ref="154c" data-ref-filename="154c">c</dfn>);</td></tr>
<tr><th id="272">272</th><td></td></tr>
<tr><th id="273">273</th><td><i class="doc">/** Sets `c` to the reduction constant for Barrett reduction by modulus `m`.</i></td></tr>
<tr><th id="274">274</th><td><i class="doc">    Requires that `c` and `m` point to distinct locations. */</i></td></tr>
<tr><th id="275">275</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_redux_const" title='mp_int_redux_const' data-ref="mp_int_redux_const" data-ref-filename="mp_int_redux_const">mp_int_redux_const</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col5 decl" id="155m" title='m' data-type='mp_int' data-ref="155m" data-ref-filename="155m">m</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col6 decl" id="156c" title='c' data-type='mp_int' data-ref="156c" data-ref-filename="156c">c</dfn>);</td></tr>
<tr><th id="276">276</th><td></td></tr>
<tr><th id="277">277</th><td><i class="doc">/** Sets `c` to the multiplicative inverse of `a` modulo `m`, if it exists.</i></td></tr>
<tr><th id="278">278</th><td><i class="doc">    The least non-negative representative of the congruence class is computed.</i></td></tr>
<tr><th id="279">279</th><td><i class="doc"></i></td></tr>
<tr><th id="280">280</th><td><i class="doc">    It returns `MP_UNDEF` if the inverse does not exist, or `MP_RANGE` if `a ==</i></td></tr>
<tr><th id="281">281</th><td><i class="doc">    0` or `m &lt;= 0`. */</i></td></tr>
<tr><th id="282">282</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_invmod" title='mp_int_invmod' data-ref="mp_int_invmod" data-ref-filename="mp_int_invmod">mp_int_invmod</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col7 decl" id="157a" title='a' data-type='mp_int' data-ref="157a" data-ref-filename="157a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col8 decl" id="158m" title='m' data-type='mp_int' data-ref="158m" data-ref-filename="158m">m</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col9 decl" id="159c" title='c' data-type='mp_int' data-ref="159c" data-ref-filename="159c">c</dfn>);</td></tr>
<tr><th id="283">283</th><td></td></tr>
<tr><th id="284">284</th><td><i class="doc">/** Sets `c` to the greatest common divisor of `a` and `b`.</i></td></tr>
<tr><th id="285">285</th><td><i class="doc"></i></td></tr>
<tr><th id="286">286</th><td><i class="doc">    It returns `MP_UNDEF` if the GCD is undefined, such as for example if `a`</i></td></tr>
<tr><th id="287">287</th><td><i class="doc">    and `b` are both zero. */</i></td></tr>
<tr><th id="288">288</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_gcd" title='mp_int_gcd' data-ref="mp_int_gcd" data-ref-filename="mp_int_gcd">mp_int_gcd</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col0 decl" id="160a" title='a' data-type='mp_int' data-ref="160a" data-ref-filename="160a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col1 decl" id="161b" title='b' data-type='mp_int' data-ref="161b" data-ref-filename="161b">b</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col2 decl" id="162c" title='c' data-type='mp_int' data-ref="162c" data-ref-filename="162c">c</dfn>);</td></tr>
<tr><th id="289">289</th><td></td></tr>
<tr><th id="290">290</th><td><i class="doc">/** Sets `c` to the greatest common divisor of `a` and `b`, and sets `x` and</i></td></tr>
<tr><th id="291">291</th><td><i class="doc">    `y` to values satisfying Bezout's identity `gcd(a, b) = ax + by`.</i></td></tr>
<tr><th id="292">292</th><td><i class="doc"></i></td></tr>
<tr><th id="293">293</th><td><i class="doc">    It returns `MP_UNDEF` if the GCD is undefined, such as for example if `a`</i></td></tr>
<tr><th id="294">294</th><td><i class="doc">    and `b` are both zero. */</i></td></tr>
<tr><th id="295">295</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_egcd" title='mp_int_egcd' data-ref="mp_int_egcd" data-ref-filename="mp_int_egcd">mp_int_egcd</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col3 decl" id="163a" title='a' data-type='mp_int' data-ref="163a" data-ref-filename="163a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col4 decl" id="164b" title='b' data-type='mp_int' data-ref="164b" data-ref-filename="164b">b</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col5 decl" id="165c" title='c' data-type='mp_int' data-ref="165c" data-ref-filename="165c">c</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col6 decl" id="166x" title='x' data-type='mp_int' data-ref="166x" data-ref-filename="166x">x</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col7 decl" id="167y" title='y' data-type='mp_int' data-ref="167y" data-ref-filename="167y">y</dfn>);</td></tr>
<tr><th id="296">296</th><td></td></tr>
<tr><th id="297">297</th><td><i class="doc">/** Sets `c` to the least common multiple of `a` and `b`.</i></td></tr>
<tr><th id="298">298</th><td><i class="doc"></i></td></tr>
<tr><th id="299">299</th><td><i class="doc">    It returns `MP_UNDEF` if the LCM is undefined, such as for example if `a`</i></td></tr>
<tr><th id="300">300</th><td><i class="doc">    and `b` are both zero. */</i></td></tr>
<tr><th id="301">301</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_lcm" title='mp_int_lcm' data-ref="mp_int_lcm" data-ref-filename="mp_int_lcm">mp_int_lcm</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col8 decl" id="168a" title='a' data-type='mp_int' data-ref="168a" data-ref-filename="168a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col9 decl" id="169b" title='b' data-type='mp_int' data-ref="169b" data-ref-filename="169b">b</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col0 decl" id="170c" title='c' data-type='mp_int' data-ref="170c" data-ref-filename="170c">c</dfn>);</td></tr>
<tr><th id="302">302</th><td></td></tr>
<tr><th id="303">303</th><td><i class="doc">/** Sets `c` to the greatest integer not less than the `b`th root of `a`,</i></td></tr>
<tr><th id="304">304</th><td><i class="doc">    using Newton's root-finding algorithm.</i></td></tr>
<tr><th id="305">305</th><td><i class="doc">    It returns `MP_UNDEF` if `a &lt; 0` and `b` is even. */</i></td></tr>
<tr><th id="306">306</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_root" title='mp_int_root' data-ref="mp_int_root" data-ref-filename="mp_int_root">mp_int_root</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col1 decl" id="171a" title='a' data-type='mp_int' data-ref="171a" data-ref-filename="171a">a</dfn>, <a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> <dfn class="local col2 decl" id="172b" title='b' data-type='mp_small' data-ref="172b" data-ref-filename="172b">b</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col3 decl" id="173c" title='c' data-type='mp_int' data-ref="173c" data-ref-filename="173c">c</dfn>);</td></tr>
<tr><th id="307">307</th><td></td></tr>
<tr><th id="308">308</th><td><i class="doc">/** Sets `c` to the greatest integer not less than the square root of `a`.</i></td></tr>
<tr><th id="309">309</th><td><i class="doc">    This is a special case of `mp_int_root()`. */</i></td></tr>
<tr><th id="310">310</th><td><em>static</em> <b>inline</b></td></tr>
<tr><th id="311">311</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl def fn" id="mp_int_sqrt" title='mp_int_sqrt' data-ref="mp_int_sqrt" data-ref-filename="mp_int_sqrt">mp_int_sqrt</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col4 decl" id="174a" title='a' data-type='mp_int' data-ref="174a" data-ref-filename="174a">a</dfn>, <a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col5 decl" id="175c" title='c' data-type='mp_int' data-ref="175c" data-ref-filename="175c">c</dfn>) { <b>return</b> <a class="ref fn" href="#mp_int_root" title='mp_int_root' data-ref="mp_int_root" data-ref-filename="mp_int_root">mp_int_root</a>(<a class="local col4 ref" href="#174a" title='a' data-ref="174a" data-ref-filename="174a">a</a>, <var>2</var>, <a class="local col5 ref" href="#175c" title='c' data-ref="175c" data-ref-filename="175c">c</a>); }</td></tr>
<tr><th id="312">312</th><td></td></tr>
<tr><th id="313">313</th><td><i class="doc">/** Returns `MP_OK` if `z` is representable as `mp_small`, else `MP_RANGE`.</i></td></tr>
<tr><th id="314">314</th><td><i class="doc">    If `out` is not NULL, `*out` is set to the value of `z` when `MP_OK`. */</i></td></tr>
<tr><th id="315">315</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_to_int" title='mp_int_to_int' data-ref="mp_int_to_int" data-ref-filename="mp_int_to_int">mp_int_to_int</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col6 decl" id="176z" title='z' data-type='mp_int' data-ref="176z" data-ref-filename="176z">z</dfn>, <a class="typedef" href="#mp_small" title='mp_small' data-type='long' data-ref="mp_small" data-ref-filename="mp_small">mp_small</a> *<dfn class="local col7 decl" id="177out" title='out' data-type='mp_small *' data-ref="177out" data-ref-filename="177out">out</dfn>);</td></tr>
<tr><th id="316">316</th><td></td></tr>
<tr><th id="317">317</th><td><i class="doc">/** Returns `MP_OK` if `z` is representable as `mp_usmall`, or `MP_RANGE`.</i></td></tr>
<tr><th id="318">318</th><td><i class="doc">    If `out` is not NULL, `*out` is set to the value of `z` when `MP_OK`. */</i></td></tr>
<tr><th id="319">319</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_to_uint" title='mp_int_to_uint' data-ref="mp_int_to_uint" data-ref-filename="mp_int_to_uint">mp_int_to_uint</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col8 decl" id="178z" title='z' data-type='mp_int' data-ref="178z" data-ref-filename="178z">z</dfn>, <a class="typedef" href="#mp_usmall" title='mp_usmall' data-type='unsigned long' data-ref="mp_usmall" data-ref-filename="mp_usmall">mp_usmall</a> *<dfn class="local col9 decl" id="179out" title='out' data-type='mp_usmall *' data-ref="179out" data-ref-filename="179out">out</dfn>);</td></tr>
<tr><th id="320">320</th><td></td></tr>
<tr><th id="321">321</th><td><i class="doc">/** Converts `z` to a zero-terminated string of characters in the specified</i></td></tr>
<tr><th id="322">322</th><td><i class="doc">    `radix`, writing at most `limit` characters to `str` including the</i></td></tr>
<tr><th id="323">323</th><td><i class="doc">    terminating NUL value. A leading `-` is used to indicate a negative value.</i></td></tr>
<tr><th id="324">324</th><td><i class="doc"></i></td></tr>
<tr><th id="325">325</th><td><i class="doc">    Returns `MP_TRUNC` if `limit` was to small to write all of `z`.</i></td></tr>
<tr><th id="326">326</th><td><i class="doc">    Requires `MP_MIN_RADIX &lt;= radix &lt;= MP_MAX_RADIX`. */</i></td></tr>
<tr><th id="327">327</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_to_string" title='mp_int_to_string' data-ref="mp_int_to_string" data-ref-filename="mp_int_to_string">mp_int_to_string</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col0 decl" id="180z" title='z' data-type='mp_int' data-ref="180z" data-ref-filename="180z">z</dfn>, <a class="typedef" href="#mp_size" title='mp_size' data-type='unsigned int' data-ref="mp_size" data-ref-filename="mp_size">mp_size</a> <dfn class="local col1 decl" id="181radix" title='radix' data-type='mp_size' data-ref="181radix" data-ref-filename="181radix">radix</dfn>, <em>char</em> *<dfn class="local col2 decl" id="182str" title='str' data-type='char *' data-ref="182str" data-ref-filename="182str">str</dfn>, <em>int</em> <dfn class="local col3 decl" id="183limit" title='limit' data-type='int' data-ref="183limit" data-ref-filename="183limit">limit</dfn>);</td></tr>
<tr><th id="328">328</th><td></td></tr>
<tr><th id="329">329</th><td><i class="doc">/** Reports the minimum number of characters required to represent `z` as a</i></td></tr>
<tr><th id="330">330</th><td><i class="doc">    zero-terminated string in the given `radix`.</i></td></tr>
<tr><th id="331">331</th><td><i class="doc">    Requires `MP_MIN_RADIX &lt;= radix &lt;= MP_MAX_RADIX`. */</i></td></tr>
<tr><th id="332">332</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_string_len" title='mp_int_string_len' data-ref="mp_int_string_len" data-ref-filename="mp_int_string_len">mp_int_string_len</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col4 decl" id="184z" title='z' data-type='mp_int' data-ref="184z" data-ref-filename="184z">z</dfn>, <a class="typedef" href="#mp_size" title='mp_size' data-type='unsigned int' data-ref="mp_size" data-ref-filename="mp_size">mp_size</a> <dfn class="local col5 decl" id="185radix" title='radix' data-type='mp_size' data-ref="185radix" data-ref-filename="185radix">radix</dfn>);</td></tr>
<tr><th id="333">333</th><td></td></tr>
<tr><th id="334">334</th><td><i class="doc">/** Reads a string of ASCII digits in the specified `radix` from the zero</i></td></tr>
<tr><th id="335">335</th><td><i class="doc">    terminated `str` provided into `z`. For values of `radix &gt; 10`, the letters</i></td></tr>
<tr><th id="336">336</th><td><i class="doc">    `A`..`Z` or `a`..`z` are accepted. Letters are interpreted without respect</i></td></tr>
<tr><th id="337">337</th><td><i class="doc">    to case.</i></td></tr>
<tr><th id="338">338</th><td><i class="doc"></i></td></tr>
<tr><th id="339">339</th><td><i class="doc">    Leading whitespace is ignored, and a leading `+` or `-` is interpreted as a</i></td></tr>
<tr><th id="340">340</th><td><i class="doc">    sign flag. Processing stops when a NUL or any other character out of range</i></td></tr>
<tr><th id="341">341</th><td><i class="doc">    for a digit in the given radix is encountered.</i></td></tr>
<tr><th id="342">342</th><td><i class="doc"></i></td></tr>
<tr><th id="343">343</th><td><i class="doc">    If the whole string was consumed, `MP_OK` is returned; otherwise</i></td></tr>
<tr><th id="344">344</th><td><i class="doc">    `MP_TRUNC`. is returned.</i></td></tr>
<tr><th id="345">345</th><td><i class="doc"></i></td></tr>
<tr><th id="346">346</th><td><i class="doc">    Requires `MP_MIN_RADIX &lt;= radix &lt;= MP_MAX_RADIX`. */</i></td></tr>
<tr><th id="347">347</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_read_string" title='mp_int_read_string' data-ref="mp_int_read_string" data-ref-filename="mp_int_read_string">mp_int_read_string</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col6 decl" id="186z" title='z' data-type='mp_int' data-ref="186z" data-ref-filename="186z">z</dfn>, <a class="typedef" href="#mp_size" title='mp_size' data-type='unsigned int' data-ref="mp_size" data-ref-filename="mp_size">mp_size</a> <dfn class="local col7 decl" id="187radix" title='radix' data-type='mp_size' data-ref="187radix" data-ref-filename="187radix">radix</dfn>, <em>const</em> <em>char</em> *<dfn class="local col8 decl" id="188str" title='str' data-type='const char *' data-ref="188str" data-ref-filename="188str">str</dfn>);</td></tr>
<tr><th id="348">348</th><td></td></tr>
<tr><th id="349">349</th><td><i class="doc">/** Reads a string of ASCII digits in the specified `radix` from the zero</i></td></tr>
<tr><th id="350">350</th><td><i class="doc">    terminated `str` provided into `z`. For values of `radix &gt; 10`, the letters</i></td></tr>
<tr><th id="351">351</th><td><i class="doc">    `A`..`Z` or `a`..`z` are accepted. Letters are interpreted without respect</i></td></tr>
<tr><th id="352">352</th><td><i class="doc">    to case.</i></td></tr>
<tr><th id="353">353</th><td><i class="doc"></i></td></tr>
<tr><th id="354">354</th><td><i class="doc">    Leading whitespace is ignored, and a leading `+` or `-` is interpreted as a</i></td></tr>
<tr><th id="355">355</th><td><i class="doc">    sign flag. Processing stops when a NUL or any other character out of range</i></td></tr>
<tr><th id="356">356</th><td><i class="doc">    for a digit in the given radix is encountered.</i></td></tr>
<tr><th id="357">357</th><td><i class="doc"></i></td></tr>
<tr><th id="358">358</th><td><i class="doc">    If the whole string was consumed, `MP_OK` is returned; otherwise</i></td></tr>
<tr><th id="359">359</th><td><i class="doc">    `MP_TRUNC`. is returned. If `end` is not NULL, `*end` is set to point to</i></td></tr>
<tr><th id="360">360</th><td><i class="doc">    the first unconsumed byte of the input string (the NUL byte if the whole</i></td></tr>
<tr><th id="361">361</th><td><i class="doc">    string was consumed). This emulates the behavior of the standard C</i></td></tr>
<tr><th id="362">362</th><td><i class="doc">    `strtol()` function.</i></td></tr>
<tr><th id="363">363</th><td><i class="doc"></i></td></tr>
<tr><th id="364">364</th><td><i class="doc">    Requires `MP_MIN_RADIX &lt;= radix &lt;= MP_MAX_RADIX`. */</i></td></tr>
<tr><th id="365">365</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_read_cstring" title='mp_int_read_cstring' data-ref="mp_int_read_cstring" data-ref-filename="mp_int_read_cstring">mp_int_read_cstring</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col9 decl" id="189z" title='z' data-type='mp_int' data-ref="189z" data-ref-filename="189z">z</dfn>, <a class="typedef" href="#mp_size" title='mp_size' data-type='unsigned int' data-ref="mp_size" data-ref-filename="mp_size">mp_size</a> <dfn class="local col0 decl" id="190radix" title='radix' data-type='mp_size' data-ref="190radix" data-ref-filename="190radix">radix</dfn>, <em>const</em> <em>char</em> *<dfn class="local col1 decl" id="191str" title='str' data-type='const char *' data-ref="191str" data-ref-filename="191str">str</dfn>, <em>char</em> **<dfn class="local col2 decl" id="192end" title='end' data-type='char **' data-ref="192end" data-ref-filename="192end">end</dfn>);</td></tr>
<tr><th id="366">366</th><td></td></tr>
<tr><th id="367">367</th><td><i class="doc">/** Returns the number of significant bits in `z`. */</i></td></tr>
<tr><th id="368">368</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_count_bits" title='mp_int_count_bits' data-ref="mp_int_count_bits" data-ref-filename="mp_int_count_bits">mp_int_count_bits</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col3 decl" id="193z" title='z' data-type='mp_int' data-ref="193z" data-ref-filename="193z">z</dfn>);</td></tr>
<tr><th id="369">369</th><td></td></tr>
<tr><th id="370">370</th><td><i class="doc">/** Converts `z` to 2's complement binary, writing at most `limit` bytes into</i></td></tr>
<tr><th id="371">371</th><td><i class="doc">    the given `buf`.  Returns `MP_TRUNC` if the buffer limit was too small to</i></td></tr>
<tr><th id="372">372</th><td><i class="doc">    contain the whole value.  If this occurs, the contents of buf will be</i></td></tr>
<tr><th id="373">373</th><td><i class="doc">    effectively garbage, as the function uses the buffer as scratch space.</i></td></tr>
<tr><th id="374">374</th><td><i class="doc"></i></td></tr>
<tr><th id="375">375</th><td><i class="doc">    The binary representation of `z` is in base-256 with digits ordered from</i></td></tr>
<tr><th id="376">376</th><td><i class="doc">    most significant to least significant (network byte ordering).  The</i></td></tr>
<tr><th id="377">377</th><td><i class="doc">    high-order bit of the first byte is set for negative values, clear for</i></td></tr>
<tr><th id="378">378</th><td><i class="doc">    non-negative values.</i></td></tr>
<tr><th id="379">379</th><td><i class="doc"></i></td></tr>
<tr><th id="380">380</th><td><i class="doc">    As a result, non-negative values will be padded with a leading zero byte if</i></td></tr>
<tr><th id="381">381</th><td><i class="doc">    the high-order byte of the base-256 magnitude is set.  This extra byte is</i></td></tr>
<tr><th id="382">382</th><td><i class="doc">    accounted for by the `mp_int_binary_len()` function. */</i></td></tr>
<tr><th id="383">383</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_to_binary" title='mp_int_to_binary' data-ref="mp_int_to_binary" data-ref-filename="mp_int_to_binary">mp_int_to_binary</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col4 decl" id="194z" title='z' data-type='mp_int' data-ref="194z" data-ref-filename="194z">z</dfn>, <em>unsigned</em> <em>char</em> *<dfn class="local col5 decl" id="195buf" title='buf' data-type='unsigned char *' data-ref="195buf" data-ref-filename="195buf">buf</dfn>, <em>int</em> <dfn class="local col6 decl" id="196limit" title='limit' data-type='int' data-ref="196limit" data-ref-filename="196limit">limit</dfn>);</td></tr>
<tr><th id="384">384</th><td></td></tr>
<tr><th id="385">385</th><td><i class="doc">/** Reads a 2's complement binary value from `buf` into `z`, where `len` is the</i></td></tr>
<tr><th id="386">386</th><td><i class="doc">    length of the buffer.  The contents of `buf` may be overwritten during</i></td></tr>
<tr><th id="387">387</th><td><i class="doc">    processing, although they will be restored when the function returns. */</i></td></tr>
<tr><th id="388">388</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_read_binary" title='mp_int_read_binary' data-ref="mp_int_read_binary" data-ref-filename="mp_int_read_binary">mp_int_read_binary</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col7 decl" id="197z" title='z' data-type='mp_int' data-ref="197z" data-ref-filename="197z">z</dfn>, <em>unsigned</em> <em>char</em> *<dfn class="local col8 decl" id="198buf" title='buf' data-type='unsigned char *' data-ref="198buf" data-ref-filename="198buf">buf</dfn>, <em>int</em> <dfn class="local col9 decl" id="199len" title='len' data-type='int' data-ref="199len" data-ref-filename="199len">len</dfn>);</td></tr>
<tr><th id="389">389</th><td></td></tr>
<tr><th id="390">390</th><td><i class="doc">/** Returns the number of bytes to represent `z` in 2's complement binary. */</i></td></tr>
<tr><th id="391">391</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_binary_len" title='mp_int_binary_len' data-ref="mp_int_binary_len" data-ref-filename="mp_int_binary_len">mp_int_binary_len</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col0 decl" id="200z" title='z' data-type='mp_int' data-ref="200z" data-ref-filename="200z">z</dfn>);</td></tr>
<tr><th id="392">392</th><td></td></tr>
<tr><th id="393">393</th><td><i class="doc">/** Converts the magnitude of `z` to unsigned binary, writing at most `limit`</i></td></tr>
<tr><th id="394">394</th><td><i class="doc">    bytes into the given `buf`.  The sign of `z` is ignored, but `z` is not</i></td></tr>
<tr><th id="395">395</th><td><i class="doc">    modified.  Returns `MP_TRUNC` if the buffer limit was too small to contain</i></td></tr>
<tr><th id="396">396</th><td><i class="doc">    the whole value.  If this occurs, the contents of `buf` will be effectively</i></td></tr>
<tr><th id="397">397</th><td><i class="doc">    garbage, as the function uses the buffer as scratch space during</i></td></tr>
<tr><th id="398">398</th><td><i class="doc">    conversion.</i></td></tr>
<tr><th id="399">399</th><td><i class="doc"></i></td></tr>
<tr><th id="400">400</th><td><i class="doc">    The binary representation of `z` is in base-256 with digits ordered from</i></td></tr>
<tr><th id="401">401</th><td><i class="doc">    most significant to least significant (network byte ordering). */</i></td></tr>
<tr><th id="402">402</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_to_unsigned" title='mp_int_to_unsigned' data-ref="mp_int_to_unsigned" data-ref-filename="mp_int_to_unsigned">mp_int_to_unsigned</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col1 decl" id="201z" title='z' data-type='mp_int' data-ref="201z" data-ref-filename="201z">z</dfn>, <em>unsigned</em> <em>char</em> *<dfn class="local col2 decl" id="202buf" title='buf' data-type='unsigned char *' data-ref="202buf" data-ref-filename="202buf">buf</dfn>, <em>int</em> <dfn class="local col3 decl" id="203limit" title='limit' data-type='int' data-ref="203limit" data-ref-filename="203limit">limit</dfn>);</td></tr>
<tr><th id="403">403</th><td></td></tr>
<tr><th id="404">404</th><td><i class="doc">/** Reads an unsigned binary value from `buf` into `z`, where `len` is the</i></td></tr>
<tr><th id="405">405</th><td><i class="doc">    length of the buffer. The contents of `buf` are not modified during</i></td></tr>
<tr><th id="406">406</th><td><i class="doc">    processing. */</i></td></tr>
<tr><th id="407">407</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_read_unsigned" title='mp_int_read_unsigned' data-ref="mp_int_read_unsigned" data-ref-filename="mp_int_read_unsigned">mp_int_read_unsigned</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col4 decl" id="204z" title='z' data-type='mp_int' data-ref="204z" data-ref-filename="204z">z</dfn>, <em>unsigned</em> <em>char</em> *<dfn class="local col5 decl" id="205buf" title='buf' data-type='unsigned char *' data-ref="205buf" data-ref-filename="205buf">buf</dfn>, <em>int</em> <dfn class="local col6 decl" id="206len" title='len' data-type='int' data-ref="206len" data-ref-filename="206len">len</dfn>);</td></tr>
<tr><th id="408">408</th><td></td></tr>
<tr><th id="409">409</th><td><i class="doc">/** Returns the number of bytes required to represent `z` as an unsigned binary</i></td></tr>
<tr><th id="410">410</th><td><i class="doc">    value in base 256. */</i></td></tr>
<tr><th id="411">411</th><td><a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="decl fn" id="mp_int_unsigned_len" title='mp_int_unsigned_len' data-ref="mp_int_unsigned_len" data-ref-filename="mp_int_unsigned_len">mp_int_unsigned_len</dfn>(<a class="typedef" href="#mp_int" title='mp_int' data-type='struct mpz_t *' data-ref="mp_int" data-ref-filename="mp_int">mp_int</a> <dfn class="local col7 decl" id="207z" title='z' data-type='mp_int' data-ref="207z" data-ref-filename="207z">z</dfn>);</td></tr>
<tr><th id="412">412</th><td></td></tr>
<tr><th id="413">413</th><td><i class="doc">/** Returns a pointer to a brief, human-readable, zero-terminated string</i></td></tr>
<tr><th id="414">414</th><td><i class="doc">    describing `res`. The returned string is statically allocated and must not</i></td></tr>
<tr><th id="415">415</th><td><i class="doc">    be freed by the caller. */</i></td></tr>
<tr><th id="416">416</th><td><em>const</em> <em>char</em> *<dfn class="decl fn" id="mp_error_string" title='mp_error_string' data-ref="mp_error_string" data-ref-filename="mp_error_string">mp_error_string</dfn>(<a class="typedef" href="#mp_result" title='mp_result' data-type='int' data-ref="mp_result" data-ref-filename="mp_result">mp_result</a> <dfn class="local col8 decl" id="208res" title='res' data-type='mp_result' data-ref="208res" data-ref-filename="208res">res</dfn>);</td></tr>
<tr><th id="417">417</th><td></td></tr>
<tr><th id="418">418</th><td><u>#<span data-ppcond="418">ifdef</span> <span class="macro" data-ref="_M/__cplusplus">__cplusplus</span></u></td></tr>
<tr><th id="419">419</th><td>}</td></tr>
<tr><th id="420">420</th><td><u>#<span data-ppcond="418">endif</span></u></td></tr>
<tr><th id="421">421</th><td><u>#<span data-ppcond="27">endif</span> /* end IMATH_H_ */</u></td></tr>
<tr><th id="422">422</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='../basis_reduction_tab.c.html'>llvm/polly/lib/External/isl/basis_reduction_tab.c</a><br/>Generated on <em>2021-Jul-01</em> from project llvm revision <em>12</em>