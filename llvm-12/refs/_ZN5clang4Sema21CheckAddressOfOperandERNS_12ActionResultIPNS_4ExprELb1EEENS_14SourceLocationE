<dec f='llvm/clang/include/clang/Sema/Sema.h' l='5195' type='clang::QualType clang::Sema::CheckAddressOfOperand(clang::ExprResult &amp; Operand, clang::SourceLocation OpLoc)'/>
<use f='llvm/clang/lib/Sema/SemaChecking.cpp' l='188' u='c' c='_ZL20SemaBuiltinAddressofRN5clang4SemaEPNS_8CallExprE'/>
<def f='llvm/clang/lib/Sema/SemaExpr.cpp' l='13304' ll='13521' type='clang::QualType clang::Sema::CheckAddressOfOperand(clang::ExprResult &amp; OrigOp, clang::SourceLocation OpLoc)'/>
<use f='llvm/clang/lib/Sema/SemaExpr.cpp' l='14568' u='c' c='_ZN5clang4Sema20CreateBuiltinUnaryOpENS_14SourceLocationENS_17UnaryOperatorKindEPNS_4ExprE'/>
<doc f='llvm/clang/lib/Sema/SemaExpr.cpp' l='13297'>/// CheckAddressOfOperand - The operand of &amp; must be either a function
/// designator or an lvalue designating an object. If it is an lvalue, the
/// object cannot be declared with storage class register or be a bit field.
/// Note: The usual conversions are *not* applied to the operand of the &amp;
/// operator (C99 6.3.2.1p[2-4]), and its result is never an lvalue.
/// In C++, the operand might be an overloaded function name, in which case
/// we allow the &apos;&amp;&apos; but retain the overloaded-function type.</doc>
