<dec f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1750' type='int llvm::LoopVectorizationCostModel::computePredInstDiscount(llvm::Instruction * PredInst, llvm::LoopVectorizationCostModel::ScalarCostsTy &amp; ScalarCosts, llvm::ElementCount VF)'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='6466' u='c' c='_ZN4llvm26LoopVectorizationCostModel23collectInstsToScalarizeENS_12ElementCountE'/>
<def f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='6474' ll='6587' type='int llvm::LoopVectorizationCostModel::computePredInstDiscount(llvm::Instruction * PredInst, llvm::LoopVectorizationCostModel::ScalarCostsTy &amp; ScalarCosts, llvm::ElementCount VF)'/>
<doc f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1745'>/// Returns the expected difference in cost from scalarizing the expression
  /// feeding a predicated instruction \p PredInst. The instructions to
  /// scalarize and their scalar costs are collected in \p ScalarCosts. A
  /// non-negative return value implies the expression will be scalarized.
  /// Currently, only single-use chains are considered for scalarization.</doc>
