<inh f='llvm/llvm/include/llvm/IR/PassManager.h' l='374' c='llvm::PassInfoMixin'/>
<def f='llvm/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h' l='34' ll='37'/>
<use f='llvm/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h' l='34'/>
<size>1</size>
<doc f='llvm/llvm/include/llvm/Transforms/Scalar/InstSimplifyPass.h' l='23'>/// Run instruction simplification across each instruction in the function.
///
/// Instruction simplification has useful constraints in some contexts:
/// - It will never introduce *new* instructions.
/// - There is no need to iterate to a fixed point.
///
/// Many passes use instruction simplification as a library facility, but it may
/// also be useful (in tests and other contexts) to have access to this very
/// restricted transform at a pass granularity. However, for a much more
/// powerful and comprehensive peephole optimization engine, see the
/// `instcombine` pass instead.</doc>
<fun r='_ZN4llvm16InstSimplifyPass3runERNS_8FunctionERNS_15AnalysisManagerIS1_JEEE'/>
<use f='llvm/llvm/lib/Passes/PassBuilder.cpp' l='1359' c='_ZN4llvm11PassBuilder31buildModuleOptimizationPipelineENS0_17OptimizationLevelEb'/>
<use f='llvm/llvm/lib/Passes/PassRegistry.def' l='229' c='_ZN4llvm11PassBuilder15parseModulePassERNS_11PassManagerINS_6ModuleENS_15AnalysisManagerIS2_JEEEJEEERKNS0_15PipelineElementE'/>
<use f='llvm/llvm/lib/Passes/PassRegistry.def' l='229' c='_ZN4llvm11PassBuilder14parseCGSCCPassERNS_11PassManagerINS_13LazyCallGraph3SCCENS_15AnalysisManagerIS3_JRS2_EEEJS5_RNS_17CGSCCUpdateResultEEEERKNS0_15PipelineElementE'/>
<use f='llvm/llvm/lib/Passes/PassRegistry.def' l='229' c='_ZN4llvm11PassBuilder17parseFunctionPassERNS_11PassManagerINS_8FunctionENS_15AnalysisManagerIS2_JEEEJEEERKNS0_15PipelineElementE'/>
<size>1</size>
