<def f='llvm/compiler-rt/lib/sanitizer_common/sanitizer_common_interceptors.inc' l='5519' macro='1' type='int getifaddrs(__sanitizer::__sanitizer_ifaddrs ** ifap)'/>
<use f='llvm/compiler-rt/lib/sanitizer_common/sanitizer_common_interceptors.inc' l='5549' u='a' c='_ZL28InitializeCommonInterceptorsv'/>
<doc f='llvm/compiler-rt/lib/sanitizer_common/sanitizer_common_interceptors.inc' l='5516'>// As long as getifaddrs()/freeifaddrs() use calloc()/free(), we don&apos;t need to
// intercept freeifaddrs(). If that ceases to be the case, we might need to
// intercept it to poison the memory again.</doc>
<dec f='include/ifaddrs.h' l='66' type='int getifaddrs(struct ifaddrs ** __ifap)'/>
<doc f='include/ifaddrs.h' l='60'>/* Create a linked list of `struct ifaddrs&apos; structures, one for each
   network interface on the host machine.  If successful, store the
   list in *IFAP and return 0.  On errors, return -1 and set `errno&apos;.

   The storage returned in *IFAP is allocated dynamically and can
   only be properly freed by passing it to `freeifaddrs&apos;.  */</doc>
