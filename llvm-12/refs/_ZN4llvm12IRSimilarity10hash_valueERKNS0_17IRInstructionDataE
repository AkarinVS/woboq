<def f='llvm/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h' l='175' ll='196' type='llvm::hash_code llvm::IRSimilarity::hash_value(const llvm::IRSimilarity::IRInstructionData &amp; ID)'/>
<use f='llvm/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h' l='223' u='c' c='_ZN4llvm12IRSimilarity23IRInstructionDataTraits12getHashValueEPKNS0_17IRInstructionDataE'/>
<doc f='llvm/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h' l='148'>/// Hashes \p Value based on its opcode, types, and operand types.
  /// Two IRInstructionData instances produce the same hash when they perform
  /// the same operation.
  ///
  /// As a simple example, consider the following instructions.
  ///
  /// \code
  /// %add1 = add i32 %x1, %y1
  /// %add2 = add i32 %x2, %y2
  ///
  /// %sub = sub i32 %x1, %y1
  ///
  /// %add_i64 = add i64 %x2, %y2
  /// \endcode
  ///
  /// Because the first two adds operate the same types, and are performing the
  /// same action, they will be hashed to the same value.
  ///
  /// However, the subtraction instruction is not the same as an addition, and
  /// will be hashed to a different value.
  ///
  /// Finally, the last add has a different type compared to the first two add
  /// instructions, so it will also be hashed to a different value that any of
  /// the previous instructions.
  ///
  /// \param [in] ID - The IRInstructionData instance to be hashed.
  /// \returns A hash_value of the IRInstructionData.</doc>
