<dec f='llvm/polly/lib/External/ppcg/ppcg.h' l='124' type='void compute_tagger(struct ppcg_scop * ps)'/>
<def f='llvm/polly/lib/External/ppcg/ppcg.c' l='347' ll='363' type='void compute_tagger(struct ppcg_scop * ps)'/>
<use f='llvm/polly/lib/External/ppcg/ppcg.c' l='919' u='c' c='ppcg_scop_from_pet_scop'/>
<doc f='llvm/polly/lib/External/ppcg/ppcg.c' l='337'>/* Construct a function from tagged iteration domains to the corresponding
 * untagged iteration domains with as range of the wrapped map in the domain
 * the reference tags that appear in any of the reads, writes or kills.
 * Store the result in ps-&gt;tagger.
 *
 * For example, if the statement with iteration space S[i,j]
 * contains two array references R_1[] and R_2[], then ps-&gt;tagger will contain
 *
 *	{ [S[i,j] -&gt; R_1[]] -&gt; S[i,j]; [S[i,j] -&gt; R_2[]] -&gt; S[i,j] }
 */</doc>
