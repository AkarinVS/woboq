<dec f='llvm/polly/lib/External/isl/isl_lp_private.h' l='8' type='enum isl_lp_result isl_basic_map_solve_lp(isl_basic_map * bmap, int max, isl_int * f, isl_sioimath * denom, isl_int * opt, isl_int * opt_denom, isl_vec ** sol)'/>
<def f='llvm/polly/lib/External/isl/isl_lp.c' l='66' ll='77' type='enum isl_lp_result isl_basic_map_solve_lp(isl_basic_map * bmap, int max, isl_int * f, isl_sioimath * d, isl_int * opt, isl_int * opt_denom, isl_vec ** sol)'/>
<use f='llvm/polly/lib/External/isl/isl_lp.c' l='83' u='c' c='isl_basic_set_solve_lp'/>
<use f='llvm/polly/lib/External/isl/isl_lp.c' l='133' u='c' c='isl_map_solve_lp'/>
<use f='llvm/polly/lib/External/isl/isl_lp.c' l='146' u='c' c='isl_map_solve_lp'/>
<doc f='llvm/polly/lib/External/isl/isl_lp.c' l='56'>/* Given a basic map &quot;bmap&quot; and an affine combination of the variables &quot;f&quot;
 * with denominator &quot;denom&quot;, set *opt / *opt_denom to the minimal
 * (or maximal if &quot;maximize&quot; is true) value attained by f/d over &quot;bmap&quot;,
 * assuming the basic map is not empty and the expression cannot attain
 * arbitrarily small (or large) values.
 * If opt_denom is NULL, then *opt is rounded up (or down)
 * to the nearest integer.
 * The return value reflects the nature of the result (empty, unbounded,
 * minimal or maximal value returned in *opt).
 */</doc>
<use f='llvm/polly/lib/External/isl/isl_map.c' l='9777' u='c' c='basic_set_maximal_difference_at'/>
