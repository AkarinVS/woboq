<dec f='llvm/polly/lib/External/isl/isl_equalities.h' l='24' type='isl_mat * isl_mat_parameter_compression(isl_mat * B, isl_vec * d)'/>
<def f='llvm/polly/lib/External/isl/isl_equalities.c' l='309' ll='379' type='isl_mat * isl_mat_parameter_compression(isl_mat * B, isl_vec * d)'/>
<use f='llvm/polly/lib/External/isl/isl_equalities.c' l='431' u='c' c='isl_mat_parameter_compression_ext'/>
<doc f='llvm/polly/lib/External/isl/isl_equalities.c' l='215'>/* Given a set of modulo constraints
 *
 *		c + A y = 0 mod d
 *
 * this function returns an affine transformation T,
 *
 *		y = T y&apos;
 *
 * that bijectively maps the integer vectors y&apos; to integer
 * vectors y that satisfy the modulo constraints.
 *
 * This function is inspired by Section 2.5.3
 * of B. Meister, &quot;Stating and Manipulating Periodicity in the Polytope
 * Model.  Applications to Program Analysis and Optimization&quot;.
 * However, the implementation only follows the algorithm of that
 * section for computing a particular solution and not for computing
 * a general homogeneous solution.  The latter is incomplete and
 * may remove some valid solutions.
 * Instead, we use an adaptation of the algorithm in Section 7 of
 * B. Meister, S. Verdoolaege, &quot;Polynomial Approximations in the Polytope
 * Model: Bringing the Power of Quasi-Polynomials to the Masses&quot;.
 *
 * The input is given as a matrix B = [ c A ] and a vector d.
 * Each element of the vector d corresponds to a row in B.
 * The output is a lower triangular matrix.
 * If no integer vector y satisfies the given constraints then
 * a matrix with zero columns is returned.
 *
 * We first compute a particular solution y_0 to the given set of
 * modulo constraints in particular_solution.  If no such solution
 * exists, then we return a zero-columned transformation matrix.
 * Otherwise, we compute the generic solution to
 *
 *		A y = 0 mod d
 *
 * That is we want to compute G such that
 *
 *		y = G y&apos;&apos;
 *
 * with y&apos;&apos; integer, describes the set of solutions.
 *
 * We first remove the common factors of each row.
 * In particular if gcd(A_i,d_i) != 1, then we divide the whole
 * row i (including d_i) by this common factor.  If afterwards gcd(A_i) != 1,
 * then we divide this row of A by the common factor, unless gcd(A_i) = 0.
 * In the later case, we simply drop the row (in both A and d).
 *
 * If there are no rows left in A, then G is the identity matrix. Otherwise,
 * for each row i, we now determine the lattice of integer vectors
 * that satisfies this row.  Let U_i be the unimodular extension of the
 * row A_i.  This unimodular extension exists because gcd(A_i) = 1.
 * The first component of
 *
 *		y&apos; = U_i y
 *
 * needs to be a multiple of d_i.  Let y&apos; = diag(d_i, 1, ..., 1) y&apos;&apos;.
 * Then,
 *
 *		y = U_i^{-1} diag(d_i, 1, ..., 1) y&apos;&apos;
 *
 * for arbitrary integer vectors y&apos;&apos;.  That is, y belongs to the lattice
 * generated by the columns of L_i = U_i^{-1} diag(d_i, 1, ..., 1).
 * If there is only one row, then G = L_1.
 *
 * If there is more than one row left, we need to compute the intersection
 * of the lattices.  That is, we need to compute an L such that
 *
 *		L = L_i L_i&apos;	for all i
 *
 * with L_i&apos; some integer matrices.  Let A be constructed as follows
 *
 *		A = [ L_1^{-T} L_2^{-T} ... L_k^{-T} ]
 *
 * and computed the Hermite Normal Form of A = [ H 0 ] U
 * Then,
 *
 *		L_i^{-T} = H U_{1,i}
 *
 * or
 *
 *		H^{-T} = L_i U_{1,i}^T
 *
 * In other words G = L = H^{-T}.
 * To ensure that G is lower triangular, we compute and use its Hermite
 * normal form.
 *
 * The affine transformation matrix returned is then
 *
 *		[  1   0  ]
 *		[ y_0  G  ]
 *
 * as any y = y_0 + G y&apos; with y&apos; integer is a solution to the original
 * modulo constraints.
 */</doc>
<use f='llvm/polly/lib/External/isl/isl_map_simplify.c' l='1027' u='c' c='normalize_divs'/>
