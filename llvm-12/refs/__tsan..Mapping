<def f='llvm/compiler-rt/lib/tsan/rtl/tsan_platform.h' l='58' ll='76'/>
<use f='llvm/compiler-rt/lib/tsan/rtl/tsan_platform.h' l='596' c='__tsan::MappingArchImpl'/>
<use f='llvm/compiler-rt/lib/tsan/rtl/tsan_platform.h' l='753' c='__tsan::IsAppMem'/>
<use f='llvm/compiler-rt/lib/tsan/rtl/tsan_platform.h' l='784' c='__tsan::IsShadowMem'/>
<use f='llvm/compiler-rt/lib/tsan/rtl/tsan_platform.h' l='815' c='__tsan::IsMetaMem'/>
<use f='llvm/compiler-rt/lib/tsan/rtl/tsan_platform.h' l='856' c='__tsan::MemToShadow'/>
<use f='llvm/compiler-rt/lib/tsan/rtl/tsan_platform.h' l='899' c='__tsan::MemToMeta'/>
<use f='llvm/compiler-rt/lib/tsan/rtl/tsan_platform.h' l='955' c='__tsan::ShadowToMem'/>
<use f='llvm/compiler-rt/lib/tsan/rtl/tsan_platform.h' l='994' c='__tsan::GetThreadTrace'/>
<use f='llvm/compiler-rt/lib/tsan/rtl/tsan_platform.h' l='1028' c='__tsan::GetThreadTraceHeader'/>
<size>1</size>
<doc f='llvm/compiler-rt/lib/tsan/rtl/tsan_platform.h' l='29'>/*
C/C++ on linux/x86_64 and freebsd/x86_64
0000 0000 1000 - 0080 0000 0000: main binary and/or MAP_32BIT mappings (512GB)
0040 0000 0000 - 0100 0000 0000: -
0100 0000 0000 - 2000 0000 0000: shadow
2000 0000 0000 - 3000 0000 0000: -
3000 0000 0000 - 4000 0000 0000: metainfo (memory blocks and sync objects)
4000 0000 0000 - 5500 0000 0000: -
5500 0000 0000 - 5680 0000 0000: pie binaries without ASLR or on 4.1+ kernels
5680 0000 0000 - 6000 0000 0000: -
6000 0000 0000 - 6200 0000 0000: traces
6200 0000 0000 - 7d00 0000 0000: -
7b00 0000 0000 - 7c00 0000 0000: heap
7c00 0000 0000 - 7e80 0000 0000: -
7e80 0000 0000 - 8000 0000 0000: modules and main thread stack

C/C++ on netbsd/amd64 can reuse the same mapping:
 * The address space starts from 0x1000 (option with 0x0) and ends with
   0x7f7ffffff000.
 * LoAppMem-kHeapMemEnd can be reused as it is.
 * No VDSO support.
 * No MidAppMem region.
 * No additional HeapMem region.
 * HiAppMem contains the stack, loader, shared libraries and heap.
 * Stack on NetBSD/amd64 has prereserved 128MB.
 * Heap grows downwards (top-down).
 * ASLR must be disabled per-process or globally.

*/</doc>
<smbr r='__tsan::Mapping::kMetaShadowBeg' t='const __sanitizer::uptr'/>
<smbr r='__tsan::Mapping::kMetaShadowEnd' t='const __sanitizer::uptr'/>
<smbr r='__tsan::Mapping::kTraceMemBeg' t='const __sanitizer::uptr'/>
<smbr r='__tsan::Mapping::kTraceMemEnd' t='const __sanitizer::uptr'/>
<smbr r='__tsan::Mapping::kShadowBeg' t='const __sanitizer::uptr'/>
<smbr r='__tsan::Mapping::kShadowEnd' t='const __sanitizer::uptr'/>
<smbr r='__tsan::Mapping::kHeapMemBeg' t='const __sanitizer::uptr'/>
<smbr r='__tsan::Mapping::kHeapMemEnd' t='const __sanitizer::uptr'/>
<smbr r='__tsan::Mapping::kLoAppMemBeg' t='const __sanitizer::uptr'/>
<smbr r='__tsan::Mapping::kLoAppMemEnd' t='const __sanitizer::uptr'/>
<smbr r='__tsan::Mapping::kMidAppMemBeg' t='const __sanitizer::uptr'/>
<smbr r='__tsan::Mapping::kMidAppMemEnd' t='const __sanitizer::uptr'/>
<smbr r='__tsan::Mapping::kHiAppMemBeg' t='const __sanitizer::uptr'/>
<smbr r='__tsan::Mapping::kHiAppMemEnd' t='const __sanitizer::uptr'/>
<smbr r='__tsan::Mapping::kAppMemMsk' t='const __sanitizer::uptr'/>
<smbr r='__tsan::Mapping::kAppMemXor' t='const __sanitizer::uptr'/>
<smbr r='__tsan::Mapping::kVdsoBeg' t='const __sanitizer::uptr'/>
