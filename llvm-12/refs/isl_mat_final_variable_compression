<dec f='llvm/polly/lib/External/isl/isl_equalities.h' l='20' type='isl_mat * isl_mat_final_variable_compression(isl_mat * B, int first, isl_mat ** T2)'/>
<def f='llvm/polly/lib/External/isl/isl_equalities.c' l='530' ll='608' type='isl_mat * isl_mat_final_variable_compression(isl_mat * B, int first, isl_mat ** T2)'/>
<use f='llvm/polly/lib/External/isl/isl_equalities.c' l='628' u='c' c='isl_mat_variable_compression'/>
<doc f='llvm/polly/lib/External/isl/isl_equalities.c' l='483'>/* Given a set of equalities
 *
 *		-C(y) + M x = 0
 *
 * this function computes a unimodular transformation from a lower-dimensional
 * space to the original space that bijectively maps the integer points x&apos;
 * in the lower-dimensional space to the integer points x in the original
 * space that satisfy the equalities.
 *
 * The input is given as a matrix B = [ -C M ] and the output is a
 * matrix that maps [1 x&apos;] to [1 x].
 * The number of equality constraints in B is assumed to be smaller than
 * or equal to the number of variables x.
 * &quot;first&quot; is the position of the first x variable.
 * The preceding variables are considered to be y-variables.
 * If T2 is not NULL, then *T2 is set to a matrix mapping [1 x] to [1 x&apos;].
 *
 * First compute the (left) Hermite normal form of M,
 *
 *		M [U1 U2] = M U = H = [H1 0]
 * or
 *		              M = H Q = [H1 0] [Q1]
 *                                             [Q2]
 *
 * with U, Q unimodular, Q = U^{-1} (and H lower triangular).
 * Define the transformed variables as
 *
 *		x = [U1 U2] [ x1&apos; ] = [U1 U2] [Q1] x
 *		            [ x2&apos; ]           [Q2]
 *
 * The equalities then become
 *
 *		-C(y) + H1 x1&apos; = 0   or   x1&apos; = H1^{-1} C(y) = C&apos;(y)
 *
 * If the denominator of the constant term does not divide the
 * the common denominator of the coefficients of y, then every
 * integer point is mapped to a non-integer point and then the original set
 * has no integer solutions (since the x&apos; are a unimodular transformation
 * of the x).  In this case, a zero-column matrix is returned.
 * Otherwise, the transformation is given by
 *
 *		x = U1 H1^{-1} C(y) + U2 x2&apos;
 *
 * The inverse transformation is simply
 *
 *		x2&apos; = Q2 x
 */</doc>
<use f='llvm/polly/lib/External/isl/isl_morph.c' l='512' u='c' c='isl_basic_set_variable_compression'/>
