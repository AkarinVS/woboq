<dec f='llvm/llvm/lib/Target/X86/X86InstrInfo.h' l='211' type='static bool llvm::X86InstrInfo::isDataInvariantLoad(llvm::MachineInstr &amp; MI)'/>
<doc f='llvm/llvm/lib/Target/X86/X86InstrInfo.h' l='196'>/// Returns true if the instruction has no behavior (specified or otherwise)
  /// that is based on the value loaded from memory or the value of any
  /// non-address register operands.
  ///
  /// For example, if the latency of the instruction is dependent on the
  /// particular bits set in any of the registers *or* any of the bits loaded
  /// from memory.
  ///
  /// Instructions are considered data invariant even if they set EFLAGS.
  ///
  /// A classical example of something that is inherently not data invariant is
  /// an indirect jump -- the destination is loaded into icache based on the
  /// bits set in the jump destination register.
  ///
  /// FIXME: This should become part of our instruction tables.</doc>
<def f='llvm/llvm/lib/Target/X86/X86InstrInfo.cpp' l='433' ll='621' type='static bool llvm::X86InstrInfo::isDataInvariantLoad(llvm::MachineInstr &amp; MI)'/>
<use f='llvm/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp' l='1368' u='c' c='_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass36tracePredStateThroughBlocksAndHardenERN4llvm15MachineFunctionE'/>
<use f='llvm/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp' l='1427' u='c' c='_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass36tracePredStateThroughBlocksAndHardenERN4llvm15MachineFunctionE'/>
<use f='llvm/llvm/lib/Target/X86/X86SpeculativeLoadHardening.cpp' l='1796' u='c' c='_ZN12_GLOBAL__N_131X86SpeculativeLoadHardeningPass24sinkPostLoadHardenedInstERN4llvm12MachineInstrERNS1_15SmallPtrSetImplIPS2_EE'/>
