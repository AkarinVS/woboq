<dec f='llvm/llvm/include/llvm/Bitcode/BitcodeWriter.h' l='164' type='void llvm::EmbedBitcodeInModule(llvm::Module &amp; M, llvm::MemoryBufferRef Buf, bool EmbedBitcode, bool EmbedCmdline, const std::vector&lt;uint8_t&gt; &amp; CmdArgs)'/>
<use f='llvm/clang/lib/CodeGen/BackendUtil.cpp' l='1619' u='c' c='_ZN5clang12EmbedBitcodeEPN4llvm6ModuleERKNS_14CodeGenOptionsENS0_15MemoryBufferRefE'/>
<doc f='llvm/llvm/include/llvm/Bitcode/BitcodeWriter.h' l='155'>/// If EmbedBitcode is set, save a copy of the llvm IR as data in the
  ///  __LLVM,__bitcode section (.llvmbc on non-MacOS).
  /// If available, pass the serialized module via the Buf parameter. If not,
  /// pass an empty (default-initialized) MemoryBufferRef, and the serialization
  /// will be handled by this API. The same behavior happens if the provided Buf
  /// is not bitcode (i.e. if it&apos;s invalid data or even textual LLVM assembly).
  /// If EmbedCmdline is set, the command line is also exported in
  /// the corresponding section (__LLVM,_cmdline / .llvmcmd) - even if CmdArgs
  /// were empty.</doc>
<def f='llvm/llvm/lib/Bitcode/Writer/BitcodeWriter.cpp' l='4844' ll='4935' type='void llvm::EmbedBitcodeInModule(llvm::Module &amp; M, llvm::MemoryBufferRef Buf, bool EmbedBitcode, bool EmbedCmdline, const std::vector&lt;uint8_t&gt; &amp; CmdArgs)'/>
<use f='llvm/llvm/lib/LTO/LTOBackend.cpp' l='392' u='c' c='_ZN4llvm3lto3optERKNS0_6ConfigEPNS_13TargetMachineEjRNS_6ModuleEbPNS_18ModuleSummaryIndexEPKS8_RKSt6vectorIhSaIhEE'/>
<use f='llvm/llvm/lib/LTO/LTOBackend.cpp' l='415' u='c' c='_ZL7codegenRKN4llvm3lto6ConfigEPNS_13TargetMachineESt8functionIFSt10unique_ptrINS0_18NativeObjectStreamESt14default_deleteIS8_EEjEEjRNS_6ModuleERKNS_18ModuleSummaryIndexE'/>
