<dec f='llvm/llvm/include/llvm/Transforms/Scalar/MemCpyOptimizer.h' l='65' type='bool llvm::MemCpyOptPass::processMemCpy(llvm::MemCpyInst * M, BasicBlock::iterator &amp; BBI)'/>
<def f='llvm/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp' l='1329' ll='1498' type='bool llvm::MemCpyOptPass::processMemCpy(llvm::MemCpyInst * M, BasicBlock::iterator &amp; BBI)'/>
<use f='llvm/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp' l='1649' u='c' c='_ZN4llvm13MemCpyOptPass17iterateOnFunctionERNS_8FunctionE'/>
<doc f='llvm/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp' l='1324'>/// Perform simplification of memcpy&apos;s.  If we have memcpy A
/// which copies X to Y, and memcpy B which copies Y to Z, then we can rewrite
/// B to be a memcpy from X to Z (or potentially a memmove, depending on
/// circumstances). This allows later passes to remove the first memcpy
/// altogether.</doc>
