<dec f='llvm/llvm/include/llvm/Support/TargetOpcodes.def' l='195' type='34'/>
<doc f='llvm/llvm/include/llvm/Support/TargetOpcodes.def' l='181'>/// This is a marker instruction which gets translated into a nop sled, useful
/// for inserting instrumentation instructions at runtime.
/// The patch here prepends the return instruction.
/// The same thing as in x86_64 is not possible for ARM because it has multiple
/// return instructions. Furthermore, CPU allows parametrized and even
/// conditional return instructions. In the current ARM implementation we are
/// making use of the fact that currently LLVM doesn&apos;t seem to generate
/// conditional return instructions.
/// On ARM, the same instruction can be used for popping multiple registers
/// from the stack and returning (it just pops pc register too), and LLVM
/// generates it sometimes. So we can&apos;t insert the sled between this stack
/// adjustment and the return without splitting the original instruction into 2
/// instructions. So on ARM, rather than jumping into the exit trampoline, we
/// call it, it does the tracing, preserves the stack and returns.</doc>
<use f='llvm/llvm/lib/CodeGen/XRayInstrumentation.cpp' l='132' u='r' c='_ZN12_GLOBAL__N_119XRayInstrumentation27prependRetWithPatchableExitERN4llvm15MachineFunctionEPKNS1_15TargetInstrInfoENS_22InstrumentationOptionsE'/>
<use f='llvm/llvm/lib/Target/AArch64/AArch64AsmPrinter.cpp' l='1344' c='_ZN12_GLOBAL__N_117AArch64AsmPrinter15emitInstructionEPKN4llvm12MachineInstrE'/>
<use f='llvm/llvm/lib/Target/PowerPC/PPCAsmPrinter.cpp' l='1372' c='_ZN12_GLOBAL__N_118PPCLinuxAsmPrinter15emitInstructionEPKN4llvm12MachineInstrE'/>
