<dec f='llvm/polly/lib/External/isl/isl_ast_build_expr.h' l='9' type='isl_ast_expr * isl_ast_build_expr_from_set_internal(isl_ast_build * build, isl_set * set)'/>
<def f='llvm/polly/lib/External/isl/isl_ast_build_expr.c' l='1592' ll='1639' type='isl_ast_expr * isl_ast_build_expr_from_set_internal(isl_ast_build * build, isl_set * set)'/>
<use f='llvm/polly/lib/External/isl/isl_ast_build_expr.c' l='1669' u='c' c='isl_ast_build_expr_from_set'/>
<use f='llvm/polly/lib/External/isl/isl_ast_build_expr.c' l='1928' u='c' c='add_intermediate_piece'/>
<doc f='llvm/polly/lib/External/isl/isl_ast_build_expr.c' l='1571'>/* Construct an isl_ast_expr that evaluates the conditions defining &quot;set&quot;.
 * The result is simplified in terms of build-&gt;domain.
 *
 * If &quot;set&quot; is an (obviously) empty set, then return the expression &quot;0&quot;.
 *
 * If there are multiple disjuncts in the description of the set,
 * then subsequent disjuncts are simplified in a context where
 * the previous disjuncts have been removed from build-&gt;domain.
 * In particular, constraints that ensure that there is no overlap
 * with these previous disjuncts, can be removed.
 * This is mostly useful for disjuncts that are only defined by
 * a single constraint (relative to the build domain) as the opposite
 * of that single constraint can then be removed from the other disjuncts.
 * In order not to increase the number of disjuncts in the build domain
 * after subtracting the previous disjuncts of &quot;set&quot;, the simple hull
 * is computed after taking the difference with each of these disjuncts.
 * This means that constraints that prevent overlap with a union
 * of multiple previous disjuncts are not removed.
 *
 * &quot;set&quot; lives in the internal schedule space.
 */</doc>
<use f='llvm/polly/lib/External/isl/isl_ast_codegen.c' l='1051' u='c' c='set_for_cond_from_set'/>
<use f='llvm/polly/lib/External/isl/isl_ast_graft.c' l='307' u='c' c='ast_node_insert_if'/>
