<dec f='llvm/llvm/include/llvm/CodeGen/MachineScheduler.h' l='482' type='void llvm::ScheduleDAGMILive::schedule()'/>
<inh f='llvm/llvm/lib/CodeGen/MachineScheduler.cpp' l='766' c='_ZN4llvm13ScheduleDAGMI8scheduleEv'/>
<def f='llvm/llvm/lib/CodeGen/MachineScheduler.cpp' l='1216' ll='1273' type='void llvm::ScheduleDAGMILive::schedule()'/>
<doc f='llvm/llvm/lib/CodeGen/MachineScheduler.cpp' l='1206'>/// schedule - Called back from MachineScheduler::runOnMachineFunction
/// after setting up the current scheduling region. [RegionBegin, RegionEnd)
/// only includes instructions that have DAG nodes, not scheduling boundaries.
///
/// This is a skeletal driver, with all the functionality pushed into helpers,
/// so that it can be easily extended by experimental schedulers. Generally,
/// implementing MachineSchedStrategy should be sufficient to implement a new
/// scheduling algorithm. However, if a scheduler further subclasses
/// ScheduleDAGMILive then it will want to override this virtual method in order
/// to update any specialized state.</doc>
<doc f='llvm/llvm/include/llvm/CodeGen/MachineScheduler.h' l='480'>/// Implement ScheduleDAGInstrs interface for scheduling a sequence of
  /// reorderable instructions.</doc>
<use f='llvm/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp' l='189' u='c' c='_ZN4llvm21GCNIterativeScheduler22OverrideLegacyStrategy8scheduleEv'/>
<ovr f='llvm/llvm/lib/Target/AMDGPU/GCNIterativeScheduler.cpp' l='296' c='_ZN4llvm21GCNIterativeScheduler8scheduleEv'/>
<ovr f='llvm/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp' l='298' c='_ZN4llvm20GCNScheduleDAGMILive8scheduleEv'/>
<use f='llvm/llvm/lib/Target/AMDGPU/GCNSchedStrategy.cpp' l='323' u='c' c='_ZN4llvm20GCNScheduleDAGMILive8scheduleEv'/>
<ovr f='llvm/llvm/lib/Target/AMDGPU/SIMachineScheduler.cpp' l='1899' c='_ZN4llvm15SIScheduleDAGMI8scheduleEv'/>
<ovr f='llvm/llvm/lib/Target/Hexagon/HexagonMachineScheduler.cpp' l='191' c='_ZN4llvm20VLIWMachineScheduler8scheduleEv'/>
