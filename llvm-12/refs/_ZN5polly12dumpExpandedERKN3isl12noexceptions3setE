<dec f='llvm/polly/include/polly/Support/ISLTools.h' l='586' type='void polly::dumpExpanded(const isl::set &amp; Set)'/>
<doc f='llvm/polly/include/polly/Support/ISLTools.h' l='548'>/// @}

/// Dump all points of the argument to llvm::errs().
///
/// Before being printed by dumpPw(), the argument&apos;s pieces are expanded to
/// contain only single points. If a dimension is unbounded, it keeps its
/// representation.
///
/// This is useful for debugging reduced cases where parameters are set to
/// constants to keep the example simple. Such sets can still contain
/// existential dimensions which makes the polyhedral hard to compare.
///
/// Example:
///   { [MemRef_A[i0] -&gt; [i1]] : (exists (e0 = floor((1 + i1)/3): i0 = 1 and 3e0
///   &lt;= i1 and 3e0 &gt;= -1 + i1 and i1 &gt;= 15 and i1 &lt;= 25)) or (exists (e0 =
///   floor((i1)/3): i0 = 0 and 3e0 &lt; i1 and 3e0 &gt;= -2 + i1 and i1 &gt; 0 and i1 &lt;=
///   11)) }
///
/// dumpExpanded:
/// {
///   [MemRef_A[0] -&gt;[1]];
///   [MemRef_A[0] -&gt;[2]];
///   [MemRef_A[0] -&gt;[4]];
///   [MemRef_A[0] -&gt;[5]];
///   [MemRef_A[0] -&gt;[7]];
///   [MemRef_A[0] -&gt;[8]];
///   [MemRef_A[0] -&gt;[10]];
///   [MemRef_A[0] -&gt;[11]];
///   [MemRef_A[1] -&gt;[15]];
///   [MemRef_A[1] -&gt;[16]];
///   [MemRef_A[1] -&gt;[18]];
///   [MemRef_A[1] -&gt;[19]];
///   [MemRef_A[1] -&gt;[21]];
///   [MemRef_A[1] -&gt;[22]];
///   [MemRef_A[1] -&gt;[24]];
///   [MemRef_A[1] -&gt;[25]]
/// }
/// @{</doc>
