<dec f='llvm/llvm/include/llvm/ADT/APInt.h' l='1875' type='llvm::APInt llvm::APInt::multiplicativeInverse(const llvm::APInt &amp; modulo) const'/>
<doc f='llvm/llvm/include/llvm/ADT/APInt.h' l='1874'>/// \returns the multiplicative inverse for a given modulo.</doc>
<use f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='987' u='c' c='_ZL19BinomialCoefficientPKN4llvm4SCEVEjRNS_15ScalarEvolutionEPNS_4TypeE'/>
<use f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='8753' u='c' c='_ZL28SolveLinEquationWithOverflowRKN4llvm5APIntEPKNS_4SCEVERNS_15ScalarEvolutionE'/>
<use f='llvm/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp' l='5462' u='c' c='_ZNK4llvm14TargetLowering17prepareUREMEqFoldENS_3EVTENS_7SDValueES2_NS_3ISD8CondCodeERNS0_15DAGCombinerInfoERKNS_5SDLocERNS_15SmallVectorImplIPNS_6SDNodeEEE'/>
<use f='llvm/llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp' l='5698' u='c' c='_ZNK4llvm14TargetLowering17prepareSREMEqFoldENS_3EVTENS_7SDValueES2_NS_3ISD8CondCodeERNS0_15DAGCombinerInfoERKNS_5SDLocERNS_15SmallVectorImplIPNS_6SDNodeEEE'/>
<def f='llvm/llvm/lib/Support/APInt.cpp' l='1179' ll='1219' type='llvm::APInt llvm::APInt::multiplicativeInverse(const llvm::APInt &amp; modulo) const'/>
<doc f='llvm/llvm/lib/Support/APInt.cpp' l='1172'>/// Computes the multiplicative inverse of this APInt for a given modulo. The
/// iterative extended Euclidean algorithm is used to solve for this value,
/// however we simplify it to speed up calculating only the inverse, and take
/// advantage of div+rem calculations. We also use some tricks to avoid copying
/// (potentially large) APInts around.
/// WARNING: a value of &apos;0&apos; may be returned,
///          signifying that no multiplicative inverse exists!</doc>
<use f='llvm/llvm/unittests/ADT/APIntTest.cpp' l='2826' u='c' c='_ZN12_GLOBAL__N_145APIntTest_MultiplicativeInverseExaustive_Test8TestBodyEv'/>
