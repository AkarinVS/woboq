<dec f='llvm/polly/include/polly/Support/GICHelper.h' l='54' type='isl_val * polly::isl_valFromAPInt(isl_ctx * Ctx, const llvm::APInt Int, bool IsSigned)'/>
<use f='llvm/polly/include/polly/Support/GICHelper.h' l='88' u='c' c='_ZN5polly12valFromAPIntEP7isl_ctxN4llvm5APIntEb'/>
<doc f='llvm/polly/include/polly/Support/GICHelper.h' l='25'>/// Translate an llvm::APInt to an isl_val.
///
/// Translate the bitsequence without sign information as provided by APInt into
/// a signed isl_val type. Depending on the value of @p IsSigned @p Int is
/// interpreted as unsigned value or as signed value in two&apos;s complement
/// representation.
///
/// Input IsSigned                 Output
///
///     0        0           -&gt;    0
///     1        0           -&gt;    1
///    00        0           -&gt;    0
///    01        0           -&gt;    1
///    10        0           -&gt;    2
///    11        0           -&gt;    3
///
///     0        1           -&gt;    0
///     1        1           -&gt;   -1
///    00        1           -&gt;    0
///    01        1           -&gt;    1
///    10        1           -&gt;   -2
///    11        1           -&gt;   -1
///
/// @param Ctx      The isl_ctx to create the isl_val in.
/// @param Int      The integer value to translate.
/// @param IsSigned If the APInt should be interpreted as signed or unsigned
///                 value.
///
/// @return The isl_val corresponding to @p Int.</doc>
<def f='llvm/polly/lib/Support/GICHelper.cpp' l='19' ll='49' type='isl_val * polly::isl_valFromAPInt(isl_ctx * Ctx, const llvm::APInt Int, bool IsSigned)'/>
<use f='llvm/polly/lib/Support/SCEVAffinator.cpp' l='261' u='c' c='_ZN5polly13SCEVAffinator13visitConstantEPKN4llvm12SCEVConstantE'/>
