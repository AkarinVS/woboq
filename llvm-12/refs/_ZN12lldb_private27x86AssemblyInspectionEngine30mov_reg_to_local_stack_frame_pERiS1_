<dec f='llvm/lldb/source/Plugins/UnwindAssembly/x86/x86AssemblyInspectionEngine.h' l='115' type='bool lldb_private::x86AssemblyInspectionEngine::mov_reg_to_local_stack_frame_p(int &amp; regno, int &amp; rbp_offset)'/>
<def f='llvm/lldb/source/Plugins/UnwindAssembly/x86/x86AssemblyInspectionEngine.cpp' l='622' ll='668' type='bool lldb_private::x86AssemblyInspectionEngine::mov_reg_to_local_stack_frame_p(int &amp; regno, int &amp; rbp_offset)'/>
<use f='llvm/lldb/source/Plugins/UnwindAssembly/x86/x86AssemblyInspectionEngine.cpp' l='1150' u='c' c='_ZN12lldb_private27x86AssemblyInspectionEngine36GetNonCallSiteUnwindPlanFromAssemblyEPhmRNS_12AddressRangeERNS_10UnwindPlanE'/>
<use f='llvm/lldb/source/Plugins/UnwindAssembly/x86/x86AssemblyInspectionEngine.cpp' l='1603' u='c' c='_ZN12lldb_private27x86AssemblyInspectionEngine31FindFirstNonPrologueInstructionEPhmRm'/>
<doc f='llvm/lldb/source/Plugins/UnwindAssembly/x86/x86AssemblyInspectionEngine.cpp' l='611'>// Look for an instruction sequence storing a nonvolatile register on to the
// stack frame.

//  movq %rax, -0x10(%rbp) [0x48 0x89 0x45 0xf0]
//  movl %eax, -0xc(%ebp)  [0x89 0x45 0xf4]

// The offset value returned in rbp_offset will be positive -- but it must be
// subtraced from the frame base register to get the actual location.  The
// positive value returned for the offset is a convention used elsewhere for
// CFA offsets et al.</doc>
