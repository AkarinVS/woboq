<def f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='1263' ll='1267' type='unsigned int llvm::TargetInstrInfo::getOpcodeAfterMemoryUnfold(unsigned int Opc, bool UnfoldLoad, bool UnfoldStore, unsigned int * LoadRegIndex = nullptr) const'/>
<doc f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='1257'>/// Returns the opcode of the would be new
  /// instruction after load / store are unfolded from an instruction of the
  /// specified opcode. It returns zero if the specified unfolding is not
  /// possible. If LoadRegIndex is non-null, it is filled in with the operand
  /// index of the operand which will hold the register holding the loaded
  /// value.</doc>
<use f='llvm/llvm/lib/CodeGen/MachineLICM.cpp' l='1332' u='c' c='_ZN12_GLOBAL__N_115MachineLICMBase20ExtractHoistableLoadEPN4llvm12MachineInstrE'/>
<use f='llvm/llvm/lib/CodeGen/TwoAddressInstructionPass.cpp' l='1207' u='c' c='_ZN12_GLOBAL__N_125TwoAddressInstructionPass23tryInstructionTransformERN4llvm26MachineInstrBundleIteratorINS1_12MachineInstrELb0EEES5_jjjb'/>
<ovr f='llvm/llvm/lib/Target/X86/X86InstrInfo.cpp' l='6521' c='_ZNK4llvm12X86InstrInfo26getOpcodeAfterMemoryUnfoldEjbbPj'/>
