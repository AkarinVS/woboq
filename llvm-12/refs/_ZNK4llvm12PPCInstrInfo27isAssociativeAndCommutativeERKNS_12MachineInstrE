<dec f='llvm/llvm/lib/Target/PowerPC/PPCInstrInfo.h' l='375' type='bool llvm::PPCInstrInfo::isAssociativeAndCommutative(const llvm::MachineInstr &amp; Inst) const'/>
<inh f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='1111' c='_ZNK4llvm15TargetInstrInfo27isAssociativeAndCommutativeERKNS_12MachineInstrE'/>
<def f='llvm/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp' l='252' ll='285' type='bool llvm::PPCInstrInfo::isAssociativeAndCommutative(const llvm::MachineInstr &amp; Inst) const'/>
<doc f='llvm/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp' l='247'>// This function does not list all associative and commutative operations, but
// only those worth feeding through the machine combiner in an attempt to
// reduce the critical path. Mostly, this means floating-point operations,
// because they have high latencies(&gt;=5) (compared to other operations, such as
// and/or, which are also associative and commutative, but have low latencies).</doc>
