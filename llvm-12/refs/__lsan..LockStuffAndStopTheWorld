<dec f='llvm/compiler-rt/lib/lsan/lsan_common.h' l='149' type='void __lsan::LockStuffAndStopTheWorld(__sanitizer::StopTheWorldCallback callback, __lsan::CheckForLeaksParam * argument)'/>
<doc f='llvm/compiler-rt/lib/lsan/lsan_common.h' l='147'>// Run stoptheworld while holding any platform-specific locks, as well as the
// allocator and thread registry locks.</doc>
<use f='llvm/compiler-rt/lib/lsan/lsan_common.cpp' l='710' u='c' c='__lsan::CheckForLeaks'/>
<def f='llvm/compiler-rt/lib/lsan/lsan_common_linux.cpp' l='142' ll='146' type='void __lsan::LockStuffAndStopTheWorld(__sanitizer::StopTheWorldCallback callback, __lsan::CheckForLeaksParam * argument)'/>
<doc f='llvm/compiler-rt/lib/lsan/lsan_common_linux.cpp' l='134'>// LSan calls dl_iterate_phdr() from the tracer task. This may deadlock: if one
// of the threads is frozen while holding the libdl lock, the tracer will hang
// in dl_iterate_phdr() forever.
// Luckily, (a) the lock is reentrant and (b) libc can&apos;t distinguish between the
// tracer task and the thread that spawned it. Thus, if we run the tracer task
// while holding the libdl lock in the parent thread, we can safely reenter it
// in the tracer. The solution is to run stoptheworld from a dl_iterate_phdr()
// callback in the parent thread.</doc>
