<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='152'/>
<def f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='182' ll='196'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='191'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='193'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='194'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='198' c='sol_free'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='221' c='sol_push_sol'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='328' c='sol_push_sol_mat'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='360' c='sol_pop_one'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='376' c='sol_domain'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='413' c='swap_initial'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='433' c='combine_initial_into_second'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='496' c='combine_initial_if_equal'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='538' c='sol_pop'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='574' c='sol_dec_level'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='599' c='sol_inc_level'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='672' c='sol_add'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='762'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='767' c='sol_map_free'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='797' c='sol_map_add_empty_wrap'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='828' c='sol_map_add_wrap'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='3679' c='sol_init'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='3703' c='sol_map_init'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='3840' c='row_sign'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='3910' c='find_solutions'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='3926' c='find_in_pos'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='3954' c='no_sol_in_strict'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='4092' c='find_solutions'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='4213' c='sol_has_mergeable_solutions'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='4244' c='find_solutions_main'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='4419' c='basic_map_partial_lexopt_base_sol'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='4422' c='basic_map_partial_lexopt_base_sol'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='4426' c='basic_map_partial_lexopt_base_sol'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='4471' c='basic_map_partial_lexopt_base'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='5664'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='5669' c='sol_pma_free'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='5716' c='sol_pma_add_empty_wrap'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='5722' c='sol_pma_add_wrap'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='5735' c='sol_pma_init'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='5783' c='basic_map_partial_lexopt_base_pw_multi_aff'/>
<size>88</size>
<doc f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='155'>/* isl_sol is an interface for constructing a solution to
 * a parametric integer linear programming problem.
 * Every time the algorithm reaches a state where a solution
 * can be read off from the tableau, the function &quot;add&quot; is called
 * on the isl_sol passed to find_solutions_main.  In a state where
 * the tableau is empty, &quot;add_empty&quot; is called instead.
 * &quot;free&quot; is called to free the implementation specific fields, if any.
 *
 * &quot;error&quot; is set if some error has occurred.  This flag invalidates
 * the remainder of the data structure.
 * If &quot;rational&quot; is set, then a rational optimization is being performed.
 * &quot;level&quot; is the current level in the tree with nodes for each
 * split in the context.
 * If &quot;max&quot; is set, then a maximization problem is being solved, rather than
 * a minimization problem, which means that the variables in the
 * tableau have value &quot;M - x&quot; rather than &quot;M + x&quot;.
 * &quot;n_out&quot; is the number of output dimensions in the input.
 * &quot;space&quot; is the space in which the solution (and also the input) lives.
 *
 * The context tableau is owned by isl_sol and is updated incrementally.
 *
 * There are currently two implementations of this interface,
 * isl_sol_map, which simply collects the solutions in an isl_map
 * and (optionally) the parts of the context where there is no solution
 * in an isl_set, and
 * isl_sol_pma, which collects an isl_pw_multi_aff instead.
 */</doc>
