<dec f='llvm/lldb/include/lldb/Utility/Scalar.h' l='204' type='const lldb_private::Scalar lldb_private::operator+(const lldb_private::Scalar &amp; lhs, const lldb_private::Scalar &amp; rhs)'/>
<dec f='llvm/lldb/include/lldb/Utility/Scalar.h' l='235' type='const lldb_private::Scalar lldb_private::operator+(const lldb_private::Scalar &amp; lhs, const lldb_private::Scalar &amp; rhs)'/>
<doc f='llvm/lldb/include/lldb/Utility/Scalar.h' l='222'>// Split out the operators into a format where the compiler will be able to
// implicitly convert numbers into Scalar objects.
//
// This allows code like:
//      Scalar two(2);
//      Scalar four = two * 2;
//      Scalar eight = 2 * four;    // This would cause an error if the
//                                  // operator* was implemented as a
//                                  // member function.
// SEE:
//  Item 19 of &quot;Effective C++ Second Edition&quot; by Scott Meyers
//  Differentiate among members functions, non-member functions, and
//  friend functions</doc>
<use f='llvm/lldb/source/Expression/IRInterpreter.cpp' l='743' u='c' c='_ZN13IRInterpreter9InterpretERN4llvm6ModuleERNS0_8FunctionENS0_8ArrayRefImEERN12lldb_private15IRExecutionUnitERNS7_6StatusEmmRNS7_16ExecutionContextE'/>
<use f='llvm/lldb/source/Expression/IRInterpreter.cpp' l='1012' u='c' c='_ZN13IRInterpreter9InterpretERN4llvm6ModuleERNS0_8FunctionENS0_8ArrayRefImEERN12lldb_private15IRExecutionUnitERNS7_6StatusEmmRNS7_16ExecutionContextE'/>
<def f='llvm/lldb/source/Utility/Scalar.cpp' l='512' ll='516' type='const lldb_private::Scalar lldb_private::operator+(const lldb_private::Scalar &amp; lhs, const lldb_private::Scalar &amp; rhs)'/>
