<dec f='llvm/polly/include/polly/ScopInfo.h' l='622' type='isl::set polly::MemoryAccess::assumeNoOutOfBound()'/>
<use f='llvm/polly/lib/Analysis/ScopBuilder.cpp' l='2517' u='c' c='_ZN5polly11ScopBuilder19assumeNoOutOfBoundsEv'/>
<def f='llvm/polly/lib/Analysis/ScopInfo.cpp' l='669' ll='701' type='isl::set polly::MemoryAccess::assumeNoOutOfBound()'/>
<doc f='llvm/polly/lib/Analysis/ScopInfo.cpp' l='648'>// Formalize no out-of-bound access assumption
//
// When delinearizing array accesses we optimistically assume that the
// delinearized accesses do not access out of bound locations (the subscript
// expression of each array evaluates for each statement instance that is
// executed to a value that is larger than zero and strictly smaller than the
// size of the corresponding dimension). The only exception is the outermost
// dimension for which we do not need to assume any upper bound.  At this point
// we formalize this assumption to ensure that at code generation time the
// relevant run-time checks can be generated.
//
// To find the set of constraints necessary to avoid out of bound accesses, we
// first build the set of data locations that are not within array bounds. We
// then apply the reverse access relation to obtain the set of iterations that
// may contain invalid accesses and reduce this set of iterations to the ones
// that are actually executed by intersecting them with the domain of the
// statement. If we now project out all loop dimensions, we obtain a set of
// parameters that may cause statement instances to be executed that may
// possibly yield out of bound memory accesses. The complement of these
// constraints is the set of constraints that needs to be assumed to ensure such
// statement instances are never executed.</doc>
