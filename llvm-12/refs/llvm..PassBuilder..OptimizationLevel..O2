<dec f='llvm/llvm/include/llvm/Passes/PassBuilder.h' l='218' type='const llvm::PassBuilder::OptimizationLevel'/>
<use f='llvm/clang/lib/CodeGen/BackendUtil.cpp' l='1047' u='r' c='_ZL10mapToLevelRKN5clang14CodeGenOptionsE'/>
<doc f='llvm/llvm/include/llvm/Passes/PassBuilder.h' l='202'>/// Optimize for fast execution as much as possible without triggering
    /// significant incremental compile time or code size growth.
    ///
    /// The key idea is that optimizations at this level should &quot;pay for
    /// themselves&quot;. So if an optimization increases compile time by 5% or
    /// increases code size by 5% for a particular benchmark, that benchmark
    /// should also be one which sees a 5% runtime improvement. If the compile
    /// time or code size penalties happen on average across a diverse range of
    /// LLVM users&apos; benchmarks, then the improvements should as well.
    ///
    /// And no matter what, the compile time needs to not grow superlinearly
    /// with the size of input to LLVM so that users can control the runtime of
    /// the optimizer in this mode.
    ///
    /// This is expected to be a good default optimization level for the vast
    /// majority of users.</doc>
<use f='llvm/llvm/lib/LTO/LTOBackend.cpp' l='273' u='r' c='_ZL14runNewPMPassesRKN4llvm3lto6ConfigERNS_6ModuleEPNS_13TargetMachineEjbPNS_18ModuleSummaryIndexEPKS8_'/>
<def f='llvm/llvm/lib/Passes/PassBuilder.cpp' l='320' ll='322' type='const PassBuilder::OptimizationLevel'/>
<use f='llvm/llvm/lib/Passes/PassBuilder.cpp' l='980' u='r' c='_ZN4llvm11PassBuilder20buildInlinerPipelineENS0_17OptimizationLevelENS_18ThinOrFullLTOPhaseE'/>
<use f='llvm/llvm/lib/Passes/PassBuilder.cpp' l='2457' u='r' c='_ZN4llvm11PassBuilder15parseModulePassERNS_11PassManagerINS_6ModuleENS_15AnalysisManagerIS2_JEEEJEEERKNS0_15PipelineElementE'/>
