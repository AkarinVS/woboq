<dec f='llvm/llvm/include/llvm/Analysis/ScalarEvolution.h' l='2162' type='bool llvm::PredicatedScalarEvolution::areAddRecsEqualWithPreds(const llvm::SCEVAddRecExpr * AR1, const llvm::SCEVAddRecExpr * AR2) const'/>
<doc f='llvm/llvm/include/llvm/Analysis/ScalarEvolution.h' l='2160'>/// Check if \p AR1 and \p AR2 are equal, while taking into account
  /// Equal predicates in Preds.</doc>
<use f='llvm/llvm/lib/Analysis/IVDescriptors.cpp' l='1087' u='c' c='_ZL23getCastsForInductionPHIRN4llvm25PredicatedScalarEvolutionEPKNS_11SCEVUnknownEPKNS_14SCEVAddRecExprERNS_15SmallVectorImplIPNS_11InstructionEEE'/>
<def f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='5014' ll='5030' type='bool llvm::PredicatedScalarEvolution::areAddRecsEqualWithPreds(const llvm::SCEVAddRecExpr * AR1, const llvm::SCEVAddRecExpr * AR2) const'/>
<doc f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='5008'>// FIXME: This utility is currently required because the Rewriter currently
// does not rewrite this expression:
// {0, +, (sext ix (trunc iy to ix) to iy)}
// into {0, +, %step},
// even when the following Equal predicate exists:
// &quot;%step == (sext ix (trunc iy to ix) to iy)&quot;.</doc>
