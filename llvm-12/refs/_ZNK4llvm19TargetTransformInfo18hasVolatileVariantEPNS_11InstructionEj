<dec f='llvm/llvm/include/llvm/Analysis/TargetTransformInfo.h' l='681' type='bool llvm::TargetTransformInfo::hasVolatileVariant(llvm::Instruction * I, unsigned int AddrSpace) const'/>
<doc f='llvm/llvm/include/llvm/Analysis/TargetTransformInfo.h' l='676'>/// Return true if the given instruction (assumed to be a memory access
  /// instruction) has a volatile variant. If that&apos;s the case then we can avoid
  /// addrspacecast to generic AS for volatile loads/stores. Default
  /// implementation returns false, which prevents address space inference for
  /// volatile loads/stores.</doc>
<def f='llvm/llvm/lib/Analysis/TargetTransformInfo.cpp' l='462' ll='465' type='bool llvm::TargetTransformInfo::hasVolatileVariant(llvm::Instruction * I, unsigned int AddrSpace) const'/>
<use f='llvm/llvm/lib/Transforms/Scalar/InferAddressSpaces.cpp' l='909' u='c' c='_ZL32isSimplePointerUseValidToReplaceRKN4llvm19TargetTransformInfoERNS_3UseEj'/>
