<dec f='llvm/lld/wasm/InputFiles.h' l='160' type='void lld::wasm::ObjFile::synthesizeTableSymbols()'/>
<def f='llvm/lld/wasm/InputFiles.cpp' l='332' ll='376' type='void lld::wasm::ObjFile::synthesizeTableSymbols()'/>
<use f='llvm/lld/wasm/InputFiles.cpp' l='514' u='c' c='_ZN3lld4wasm7ObjFile5parseEb'/>
<doc f='llvm/lld/wasm/InputFiles.cpp' l='313'>// Since LLVM 12, we expect that if an input file defines or uses a table, it
// declares the tables using symbols and records each use with a relocation.
// This way when the linker combines inputs, it can collate the tables used by
// the inputs, assigning them distinct table numbers, and renumber all the uses
// as appropriate.  At the same time, the linker has special logic to build the
// indirect function table if it is needed.
//
// However, object files produced by LLVM 11 and earlier neither write table
// symbols nor record relocations, and yet still use tables via call_indirect,
// and via function pointer bitcasts.  We can detect these object files, as they
// declare tables as imports or define them locally, but don&apos;t have table
// symbols.  synthesizeTableSymbols serves as a shim when loading these older
// input files, defining the missing symbols to allow the indirect function
// table to be built.
//
// Table uses in these older files won&apos;t be relocated, as they have no
// relocations.  In practice this isn&apos;t a problem, as these object files
// typically just declare a single table named __indirect_function_table and
// having table number 0, so relocation would be idempotent anyway.</doc>
