<dec f='llvm/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObject.h' l='191' type='void clang::ento::FieldChainInfo::printNoteMsg(llvm::raw_ostream &amp; Out) const'/>
<use f='llvm/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp' l='271' u='c' c='_ZN5clang4ento23FindUninitializedFields17addFieldToUninitsENS0_14FieldChainInfoEPKNS0_9MemRegionE'/>
<def f='llvm/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp' l='424' ll='440' type='void clang::ento::FieldChainInfo::printNoteMsg(llvm::raw_ostream &amp; Out) const'/>
<doc f='llvm/clang/lib/StaticAnalyzer/Checkers/UninitializedObject/UninitializedObjectChecker.cpp' l='411'>// FIXME: This function constructs an incorrect string in the following case:
//
//   struct Base { int x; };
//   struct D1 : Base {}; struct D2 : Base {};
//
//   struct MostDerived : D1, D2 {
//     MostDerived() {}
//   }
//
// A call to MostDerived::MostDerived() will cause two notes that say
// &quot;uninitialized field &apos;this-&gt;x&apos;&quot;, but we can&apos;t refer to &apos;x&apos; directly,
// we need an explicit namespace resolution whether the uninit field was
// &apos;D1::x&apos; or &apos;D2::x&apos;.</doc>
