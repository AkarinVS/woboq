<dec f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='736' type='llvm::Value * llvm::InnerLoopVectorizer::emitTransformedIndex(IRBuilder&lt;&gt; &amp; B, llvm::Value * Index, llvm::ScalarEvolution * SE, const llvm::DataLayout &amp; DL, const llvm::InductionDescriptor &amp; ID) const'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='2187' u='c' c='_ZN4llvm19InnerLoopVectorizer21widenIntOrFpInductionEPNS_7PHINodeEPNS_5ValueEPNS_9TruncInstE'/>
<def f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='3235' ll='3333' type='llvm::Value * llvm::InnerLoopVectorizer::emitTransformedIndex(IRBuilder&lt;&gt; &amp; B, llvm::Value * Index, llvm::ScalarEvolution * SE, const llvm::DataLayout &amp; DL, const llvm::InductionDescriptor &amp; ID) const'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='3419' u='c' c='_ZN4llvm19InnerLoopVectorizer27createInductionResumeValuesEPNS_4LoopEPNS_5ValueESt4pairIPNS_10BasicBlockES4_E'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='3430' u='c' c='_ZN4llvm19InnerLoopVectorizer27createInductionResumeValuesEPNS_4LoopEPNS_5ValueESt4pairIPNS_10BasicBlockES4_E'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='3643' u='c' c='_ZN4llvm19InnerLoopVectorizer12fixupIVUsersEPNS_7PHINodeERKNS_19InductionDescriptorEPNS_5ValueES7_PNS_10BasicBlockE'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='4694' u='c' c='_ZN4llvm19InnerLoopVectorizer19widenPHIInstructionEPNS_11InstructionEPNS_20RecurrenceDescriptorEPNS_5ValueEjNS_12ElementCountE'/>
<doc f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='730'>/// Compute the transformed value of Index at offset StartValue using step
  /// StepValue.
  /// For integer induction, returns StartValue + Index * StepValue.
  /// For pointer induction, returns StartValue[Index * StepValue].
  /// FIXME: The newly created binary instructions should contain nsw/nuw
  /// flags, which can be found from the original scalar operations.</doc>
