<dec f='llvm/llvm/include/llvm/Transforms/Utils/FunctionComparator.h' l='105' type='static llvm::FunctionComparator::FunctionHash llvm::FunctionComparator::functionHash(llvm::Function &amp; )'/>
<use f='llvm/llvm/lib/Transforms/IPO/MergeFunctions.cpp' l='183' u='c' c='_ZN12_GLOBAL__N_112FunctionNodeC1EPN4llvm8FunctionE'/>
<use f='llvm/llvm/lib/Transforms/IPO/MergeFunctions.cpp' l='419' u='c' c='_ZN12_GLOBAL__N_114MergeFunctions11runOnModuleERN4llvm6ModuleE'/>
<def f='llvm/llvm/lib/Transforms/Utils/FunctionComparator.cpp' l='948' ll='976' type='static FunctionComparator::FunctionHash llvm::FunctionComparator::functionHash(llvm::Function &amp; F)'/>
<doc f='llvm/llvm/lib/Transforms/Utils/FunctionComparator.cpp' l='938'>// A function hash is calculated by considering only the number of arguments and
// whether a function is varargs, the order of basic blocks (given by the
// successors of each basic block in depth first order), and the order of
// opcodes of each instruction within each of these basic blocks. This mirrors
// the strategy compare() uses to compare functions by walking the BBs in depth
// first order and comparing each instruction in sequence. Because this hash
// does not look at the operands, it is insensitive to things such as the
// target of calls and the constants used in the function, which makes it useful
// when possibly merging functions which are the same modulo constants and call
// targets.</doc>
