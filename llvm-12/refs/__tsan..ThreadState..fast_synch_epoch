<dec f='llvm/compiler-rt/lib/tsan/rtl/tsan_rtl.h' l='378' type='__sanitizer::u64'/>
<offset>64</offset>
<doc f='llvm/compiler-rt/lib/tsan/rtl/tsan_rtl.h' l='367'>// Synch epoch represents the threads&apos;s epoch before the last synchronization
  // action. It allows to reduce number of shadow state updates.
  // For example, fast_synch_epoch=100, last write to addr X was at epoch=150,
  // if we are processing write to X from the same thread at epoch=200,
  // we do nothing, because both writes happen in the same &apos;synch epoch&apos;.
  // That is, if another memory access does not race with the former write,
  // it does not race with the latter as well.
  // QUESTION: can we can squeeze this into ThreadState::Fast?
  // E.g. ThreadState::Fast is a 44-bit, 32 are taken by synch_epoch and 12 are
  // taken by epoch between synchs.
  // This way we can save one load from tls.</doc>
<use f='llvm/compiler-rt/lib/tsan/rtl/tsan_rtl.cpp' l='877' u='r' c='__tsan::MemoryAccess'/>
<use f='llvm/compiler-rt/lib/tsan/rtl/tsan_rtl.cpp' l='902' u='r' c='__tsan::MemoryAccessImpl'/>
<use f='llvm/compiler-rt/lib/tsan/rtl/tsan_rtl_mutex.cpp' l='503' u='w' c='__tsan::ReleaseStoreAcquireImpl'/>
<use f='llvm/compiler-rt/lib/tsan/rtl/tsan_rtl_mutex.cpp' l='512' u='w' c='__tsan::ReleaseImpl'/>
<use f='llvm/compiler-rt/lib/tsan/rtl/tsan_rtl_mutex.cpp' l='521' u='w' c='__tsan::ReleaseStoreImpl'/>
<use f='llvm/compiler-rt/lib/tsan/rtl/tsan_rtl_mutex.cpp' l='530' u='w' c='__tsan::AcquireReleaseImpl'/>
<use f='llvm/compiler-rt/lib/tsan/rtl/tsan_rtl_thread.cpp' l='116' u='w' c='__tsan::ThreadContext::OnStarted'/>
