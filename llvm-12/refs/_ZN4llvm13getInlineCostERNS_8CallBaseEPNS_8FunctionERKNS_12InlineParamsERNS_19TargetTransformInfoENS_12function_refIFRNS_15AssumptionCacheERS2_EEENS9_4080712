<dec f='llvm/llvm/include/llvm/Analysis/InlineCost.h' l='240' type='llvm::InlineCost llvm::getInlineCost(llvm::CallBase &amp; Call, llvm::Function * Callee, const llvm::InlineParams &amp; Params, llvm::TargetTransformInfo &amp; CalleeTTI, function_ref&lt;llvm::AssumptionCache &amp;(llvm::Function &amp;)&gt; GetAssumptionCache, function_ref&lt;const llvm::TargetLibraryInfo &amp;(llvm::Function &amp;)&gt; GetTLI, function_ref&lt;llvm::BlockFrequencyInfo &amp;(llvm::Function &amp;)&gt; GetBFI = nullptr, llvm::ProfileSummaryInfo * PSI = nullptr, llvm::OptimizationRemarkEmitter * ORE = nullptr)'/>
<doc f='llvm/llvm/include/llvm/Analysis/InlineCost.h' l='234'>/// Get an InlineCost with the callee explicitly specified.
/// This allows you to calculate the cost of inlining a function via a
/// pointer. This behaves exactly as the version with no explicit callee
/// parameter in all other respects.
//</doc>
<use f='llvm/llvm/lib/Analysis/InlineCost.cpp' l='2478' u='c' c='_ZN4llvm13getInlineCostERNS_8CallBaseERKNS_12InlineParamsERNS_19TargetTransformInfoENS_12function_refIFRNS_15AssumptionCacheERNS_8FunctionEEEENS7_IFRK1401667'/>
<def f='llvm/llvm/lib/Analysis/InlineCost.cpp' l='2584' ll='2618' type='llvm::InlineCost llvm::getInlineCost(llvm::CallBase &amp; Call, llvm::Function * Callee, const llvm::InlineParams &amp; Params, llvm::TargetTransformInfo &amp; CalleeTTI, function_ref&lt;llvm::AssumptionCache &amp;(llvm::Function &amp;)&gt; GetAssumptionCache, function_ref&lt;const llvm::TargetLibraryInfo &amp;(llvm::Function &amp;)&gt; GetTLI, function_ref&lt;llvm::BlockFrequencyInfo &amp;(llvm::Function &amp;)&gt; GetBFI = nullptr, llvm::ProfileSummaryInfo * PSI = nullptr, llvm::OptimizationRemarkEmitter * ORE = nullptr)'/>
<use f='llvm/llvm/lib/Transforms/IPO/SampleProfile.cpp' l='1475' u='c' c='_ZN12_GLOBAL__N_119SampleProfileLoader21shouldInlineCandidateERNS_15InlineCandidateE'/>
