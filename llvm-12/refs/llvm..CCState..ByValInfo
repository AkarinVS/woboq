<def f='llvm/llvm/include/llvm/CodeGen/CallingConvLower.h' l='234' ll='242'/>
<use f='llvm/llvm/include/llvm/CodeGen/CallingConvLower.h' l='243'/>
<use f='llvm/llvm/include/llvm/CodeGen/CallingConvLower.h' l='482' c='_ZNK4llvm7CCState18getInRegsParamInfoEjRjS1_'/>
<use f='llvm/llvm/include/llvm/CodeGen/CallingConvLower.h' l='489' c='_ZN4llvm7CCState18addInRegsParamInfoEjj'/>
<size>8</size>
<doc f='llvm/llvm/include/llvm/CodeGen/CallingConvLower.h' l='207'>// ByValInfo and SmallVector&lt;ByValInfo, 4&gt; ByValRegs:
  //
  // Vector of ByValInfo instances (ByValRegs) is introduced for byval registers
  // tracking.
  // Or, in another words it tracks byval parameters that are stored in
  // general purpose registers.
  //
  // For 4 byte stack alignment,
  // instance index means byval parameter number in formal
  // arguments set. Assume, we have some &quot;struct_type&quot; with size = 4 bytes,
  // then, for function &quot;foo&quot;:
  //
  // i32 foo(i32 %p, %struct_type* %r, i32 %s, %struct_type* %t)
  //
  // ByValRegs[0] describes how &quot;%r&quot; is stored (Begin == r1, End == r2)
  // ByValRegs[1] describes how &quot;%t&quot; is stored (Begin == r3, End == r4).
  //
  // In case of 8 bytes stack alignment,
  // In function shown above, r3 would be wasted according to AAPCS rules.
  // ByValRegs vector size still would be 2,
  // while &quot;%t&quot; goes to the stack: it wouldn&apos;t be described in ByValRegs.
  //
  // Supposed use-case for this collection:
  // 1. Initially ByValRegs is empty, InRegsParamsProcessed is 0.
  // 2. HandleByVal fillups ByValRegs.
  // 3. Argument analysis (LowerFormatArguments, for example). After
  // some byval argument was analyzed, InRegsParamsProcessed is increased.</doc>
<fun r='_ZN4llvm7CCState9ByValInfoC1Ejj'/>
<mbr r='llvm::CCState::ByValInfo::Begin' o='0' t='unsigned int'/>
<mbr r='llvm::CCState::ByValInfo::End' o='32' t='unsigned int'/>
