<dec f='llvm/llvm/lib/Target/AArch64/AArch64InstrInfo.h' l='128' type='bool llvm::AArch64InstrInfo::getMemOperandWithOffsetWidth(const llvm::MachineInstr &amp; MI, const llvm::MachineOperand *&amp; BaseOp, int64_t &amp; Offset, bool &amp; OffsetIsScalable, unsigned int &amp; Width, const llvm::TargetRegisterInfo * TRI) const'/>
<doc f='llvm/llvm/lib/Target/AArch64/AArch64InstrInfo.h' l='124'>/// If \p OffsetIsScalable is set to &apos;true&apos;, the offset is scaled by `vscale`.
  /// This is true for some SVE instructions like ldr/str that have a
  /// &apos;reg + imm&apos; addressing mode where the immediate is an index to the
  /// scalable vector located at &apos;reg + imm * vscale x #bytes&apos;.</doc>
<use f='llvm/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp' l='1071' u='c' c='_ZNK4llvm16AArch64InstrInfo31areMemAccessesTriviallyDisjointERKNS_12MachineInstrES3_'/>
<use f='llvm/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp' l='1073' u='c' c='_ZNK4llvm16AArch64InstrInfo31areMemAccessesTriviallyDisjointERKNS_12MachineInstrES3_'/>
<use f='llvm/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp' l='2270' u='c' c='_ZNK4llvm16AArch64InstrInfo29getMemOperandsWithOffsetWidthERKNS_12MachineInstrERNS_15SmallVectorImplIPKNS_14MachineOperandEEERlRbRjPKNS_18TargetRegisterInfoE'/>
<def f='llvm/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp' l='2295' ll='2341' type='bool llvm::AArch64InstrInfo::getMemOperandWithOffsetWidth(const llvm::MachineInstr &amp; LdSt, const llvm::MachineOperand *&amp; BaseOp, int64_t &amp; Offset, bool &amp; OffsetIsScalable, unsigned int &amp; Width, const llvm::TargetRegisterInfo * TRI) const'/>
<use f='llvm/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp' l='6763' u='c' c='_ZNK4llvm16AArch64InstrInfo16fixupPostOutlineERNS_17MachineBasicBlockE'/>
