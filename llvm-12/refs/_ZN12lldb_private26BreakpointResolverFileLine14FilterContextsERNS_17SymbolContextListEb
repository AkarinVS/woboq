<dec f='llvm/lldb/include/lldb/Breakpoint/BreakpointResolverFileLine.h' l='60' type='void lldb_private::BreakpointResolverFileLine::FilterContexts(lldb_private::SymbolContextList &amp; sc_list, bool is_relative)'/>
<def f='llvm/lldb/source/Breakpoint/BreakpointResolverFileLine.cpp' l='120' ll='205' type='void lldb_private::BreakpointResolverFileLine::FilterContexts(lldb_private::SymbolContextList &amp; sc_list, bool is_relative)'/>
<use f='llvm/lldb/source/Breakpoint/BreakpointResolverFileLine.cpp' l='243' u='c' c='_ZN12lldb_private26BreakpointResolverFileLine14SearchCallbackERNS_12SearchFilterERNS_13SymbolContextEPNS_7AddressE'/>
<doc f='llvm/lldb/source/Breakpoint/BreakpointResolverFileLine.cpp' l='113'>// Filter the symbol context list to remove contexts where the line number was
// moved into a new function. We do this conservatively, so if e.g. we cannot
// resolve the function in the context (which can happen in case of line-table-
// only debug info), we leave the context as is. The trickiest part here is
// handling inlined functions -- in this case we need to make sure we look at
// the declaration line of the inlined function, NOT the function it was
// inlined into.</doc>
