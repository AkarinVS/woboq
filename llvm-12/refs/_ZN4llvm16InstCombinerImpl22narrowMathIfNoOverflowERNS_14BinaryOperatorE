<dec f='llvm/llvm/lib/Transforms/InstCombine/InstCombineInternal.h' l='322' type='llvm::Instruction * llvm::InstCombinerImpl::narrowMathIfNoOverflow(llvm::BinaryOperator &amp; I)'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp' l='1395' u='c' c='_ZN4llvm16InstCombinerImpl8visitAddERNS_14BinaryOperatorE'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp' l='1739' u='c' c='_ZN4llvm16InstCombinerImpl8visitSubERNS_14BinaryOperatorE'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp' l='378' u='c' c='_ZN4llvm16InstCombinerImpl8visitMulERNS_14BinaryOperatorE'/>
<def f='llvm/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp' l='1763' ll='1814' type='llvm::Instruction * llvm::InstCombinerImpl::narrowMathIfNoOverflow(llvm::BinaryOperator &amp; BO)'/>
<doc f='llvm/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp' l='1760'>/// Try to narrow the width of a binop if at least 1 operand is an extend of
/// of a value. This requires a potentially expensive known bits check to make
/// sure the narrow op does not overflow.</doc>
