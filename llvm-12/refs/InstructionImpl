<use f='llvm/lldb/include/lldb/API/SBInstruction.h' l='84'/>
<def f='llvm/lldb/source/API/SBInstruction.cpp' l='51' ll='64'/>
<use f='llvm/lldb/source/API/SBInstruction.cpp' l='75' c='_ZN4lldb13SBInstructionC1ERKSt10shared_ptrIN12lldb_private12DisassemblerEERKS1_INS2_11InstructionEE'/>
<use f='llvm/lldb/source/API/SBInstruction.cpp' l='234' c='_ZN4lldb13SBInstruction9SetOpaqueERKSt10shared_ptrIN12lldb_private12DisassemblerEERKS1_INS2_11InstructionEE'/>
<size>32</size>
<doc f='llvm/lldb/source/API/SBInstruction.cpp' l='33'>// We recently fixed a leak in one of the Instruction subclasses where the
// instruction will only hold a weak reference to the disassembler to avoid a
// cycle that was keeping both objects alive (leak) and we need the
// InstructionImpl class to make sure our public API behaves as users would
// expect. Calls in our public API allow clients to do things like:
//
// 1  lldb::SBInstruction inst;
// 2  inst = target.ReadInstructions(pc, 1).GetInstructionAtIndex(0)
// 3  if (inst.DoesBranch())
// 4  ...
//
// There was a temporary lldb::DisassemblerSP object created in the
// SBInstructionList that was returned by lldb.target.ReadInstructions() that
// will go away after line 2 but the &quot;inst&quot; object should be able to still
// answer questions about itself. So we make sure that any SBInstruction
// objects that are given out have a strong reference to the disassembler and
// the instruction so that the object can live and successfully respond to all
// queries.</doc>
<fun r='_ZN15InstructionImplC1ERKSt10shared_ptrIN12lldb_private12DisassemblerEERKS0_INS1_11InstructionEE'/>
<fun r='_ZNK15InstructionImpl5GetSPEv'/>
<fun r='_ZNK15InstructionImpl7IsValidEv'/>
<mbr r='InstructionImpl::m_disasm_sp' o='0' t='lldb::DisassemblerSP'/>
<mbr r='InstructionImpl::m_inst_sp' o='128' t='lldb::InstructionSP'/>
