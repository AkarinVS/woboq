<inh f='llvm/llvm/include/llvm/IR/PassManager.h' l='374' c='llvm::PassInfoMixin'/>
<def f='llvm/llvm/include/llvm/Analysis/CGSCCPassManager.h' l='516' ll='534'/>
<use f='llvm/llvm/include/llvm/Analysis/CGSCCPassManager.h' l='516'/>
<use f='llvm/llvm/include/llvm/Analysis/CGSCCPassManager.h' l='539' c='_ZN4llvm27createDevirtSCCRepeatedPassET_i'/>
<use f='llvm/llvm/include/llvm/Analysis/CGSCCPassManager.h' l='544' c='_ZN4llvm27createDevirtSCCRepeatedPassET_i'/>
<size>16</size>
<doc f='llvm/llvm/include/llvm/Analysis/CGSCCPassManager.h' l='502'>/// A helper that repeats an SCC pass each time an indirect call is refined to
/// a direct call by that pass.
///
/// While the CGSCC pass manager works to re-visit SCCs and RefSCCs as they
/// change shape, we may also want to repeat an SCC pass if it simply refines
/// an indirect call to a direct call, even if doing so does not alter the
/// shape of the graph. Note that this only pertains to direct calls to
/// functions where IPO across the SCC may be able to compute more precise
/// results. For intrinsics, we assume scalar optimizations already can fully
/// reason about them.
///
/// This repetition has the potential to be very large however, as each one
/// might refine a single call site. As a consequence, in practice we use an
/// upper bound on the number of repetitions to limit things.</doc>
<fun r='_ZN4llvm21DevirtSCCRepeatedPassC1ESt10unique_ptrINS_6detail11PassConceptINS_13LazyCallGraph3SCCENS_15AnalysisManagerIS5_JRS4_EEEJS7_RNS_17CGSCCUpdateR5625609'/>
<fun r='_ZN4llvm21DevirtSCCRepeatedPass3runERNS_13LazyCallGraph3SCCERNS_15AnalysisManagerIS2_JRS1_EEES5_RNS_17CGSCCUpdateResultE'/>
<mbr r='llvm::DevirtSCCRepeatedPass::Pass' o='0' t='std::unique_ptr&lt;PassConceptT&gt;'/>
<mbr r='llvm::DevirtSCCRepeatedPass::MaxIterations' o='64' t='int'/>
