<def f='llvm/lldb/include/lldb/Symbol/SymbolFile.h' l='100' ll='107' type='uint32_t lldb_private::SymbolFile::GetAbilities()'/>
<doc f='llvm/lldb/include/lldb/Symbol/SymbolFile.h' l='73'>/// Get a mask of what this symbol file supports for the object file
  /// that it was constructed with.
  ///
  /// Each symbol file gets to respond with a mask of abilities that
  /// it supports for each object file. This happens when we are
  /// trying to figure out which symbol file plug-in will get used
  /// for a given object file. The plug-in that responds with the
  /// best mix of &quot;SymbolFile::Abilities&quot; bits set, will get chosen to
  /// be the symbol file parser. This allows each plug-in to check for
  /// sections that contain data a symbol file plug-in would need. For
  /// example the DWARF plug-in requires DWARF sections in a file that
  /// contain debug information. If the DWARF plug-in doesn&apos;t find
  /// these sections, it won&apos;t respond with many ability bits set, and
  /// we will probably fall back to the symbol table SymbolFile plug-in
  /// which uses any information in the symbol table. Also, plug-ins
  /// might check for some specific symbols in a symbol table in the
  /// case where the symbol table contains debug information (STABS
  /// and COFF). Not a lot of work should happen in these functions
  /// as the plug-in might not get selected due to another plug-in
  /// having more abilities. Any initialization work should be saved
  /// for &quot;void SymbolFile::InitializeObject()&quot; which will get called
  /// on the SymbolFile object with the best set of abilities.
  ///
  /// \return
  ///     A uint32_t mask containing bits from the SymbolFile::Abilities
  ///     enumeration. Any bits that are set represent an ability that
  ///     this symbol plug-in can parse from the object file.</doc>
<use f='llvm/lldb/source/Symbol/SymbolFile.cpp' l='70' u='c' c='_ZN12lldb_private10SymbolFile10FindPluginESt10shared_ptrINS_10ObjectFileEE'/>
