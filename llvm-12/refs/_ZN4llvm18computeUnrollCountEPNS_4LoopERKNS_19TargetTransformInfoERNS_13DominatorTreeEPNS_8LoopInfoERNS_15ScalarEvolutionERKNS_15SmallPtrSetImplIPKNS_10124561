<dec f='llvm/llvm/include/llvm/Transforms/Utils/UnrollLoop.h' l='106' type='bool llvm::computeUnrollCount(llvm::Loop * L, const llvm::TargetTransformInfo &amp; TTI, llvm::DominatorTree &amp; DT, llvm::LoopInfo * LI, llvm::ScalarEvolution &amp; SE, const SmallPtrSetImpl&lt;const llvm::Value *&gt; &amp; EphValues, llvm::OptimizationRemarkEmitter * ORE, unsigned int &amp; TripCount, unsigned int MaxTripCount, bool MaxOrZero, unsigned int &amp; TripMultiple, unsigned int LoopSize, TargetTransformInfo::UnrollingPreferences &amp; UP, TargetTransformInfo::PeelingPreferences &amp; PP, bool &amp; UseUpperBound)'/>
<use f='llvm/llvm/lib/Transforms/Scalar/LoopUnrollAndJamPass.cpp' l='171' u='c' c='_ZL24computeUnrollAndJamCountPN4llvm4LoopES1_RKNS_19TargetTransformInfoERNS_13DominatorTreeEPNS_8LoopInfoERNS_15ScalarEvolutionERKNS_15SmallPtrSetImpl6047353'/>
<def f='llvm/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp' l='746' ll='1021' type='bool llvm::computeUnrollCount(llvm::Loop * L, const llvm::TargetTransformInfo &amp; TTI, llvm::DominatorTree &amp; DT, llvm::LoopInfo * LI, llvm::ScalarEvolution &amp; SE, const SmallPtrSetImpl&lt;const llvm::Value *&gt; &amp; EphValues, llvm::OptimizationRemarkEmitter * ORE, unsigned int &amp; TripCount, unsigned int MaxTripCount, bool MaxOrZero, unsigned int &amp; TripMultiple, unsigned int LoopSize, TargetTransformInfo::UnrollingPreferences &amp; UP, TargetTransformInfo::PeelingPreferences &amp; PP, bool &amp; UseUpperBound)'/>
<use f='llvm/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp' l='1132' u='c' c='_ZL15tryToUnrollLoopPN4llvm4LoopERNS_13DominatorTreeEPNS_8LoopInfoERNS_15ScalarEvolutionERKNS_19TargetTransformInfoERNS_15AssumptionCacheERNS_25Optimi16672969'/>
<doc f='llvm/llvm/lib/Transforms/Scalar/LoopUnrollPass.cpp' l='738'>// Returns true if unroll count was set explicitly.
// Calculates unroll count and writes it to UP.Count.
// Unless IgnoreUser is true, will also use metadata and command-line options
// that are specific to to the LoopUnroll pass (which, for instance, are
// irrelevant for the LoopUnrollAndJam pass).
// FIXME: This function is used by LoopUnroll and LoopUnrollAndJam, but consumes
// many LoopUnroll-specific options. The shared functionality should be
// refactored into it own function.</doc>
