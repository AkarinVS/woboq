<def f='llvm/polly/include/polly/Support/GICHelper.h' l='347' ll='412'/>
<use f='llvm/polly/lib/Analysis/DependenceInfo.cpp' l='371' c='_ZN5polly11Dependences20calculateDependencesERNS_4ScopE'/>
<size>32</size>
<doc f='llvm/polly/include/polly/Support/GICHelper.h' l='335'>/// Scoped limit of ISL operations.
///
/// Limits the number of ISL operations during the lifetime of this object. The
/// idea is to use this as an RAII guard for the scope where the code is aware
/// that ISL can return errors even when all input is valid. After leaving the
/// scope, it will return to the error setting as it was before. That also means
/// that the error setting should not be changed while in that scope.
///
/// Such scopes are not allowed to be nested because the previous operations
/// counter cannot be reset to the previous state, or one that adds the
/// operations while being in the nested scope. Use therefore is only allowed
/// while currently a no operations-limit is active.</doc>
<mbr r='polly::IslMaxOperationsGuard::IslCtx' o='0' t='isl_ctx *'/>
<mbr r='polly::IslMaxOperationsGuard::LocalMaxOps' o='64' t='unsigned long'/>
<mbr r='polly::IslMaxOperationsGuard::TopLevelScope' o='128' t='polly::IslQuotaScope'/>
<fun r='_ZN5polly21IslMaxOperationsGuardC1EP7isl_ctxmb'/>
<fun r='_ZN5polly21IslMaxOperationsGuard5enterEb'/>
<fun r='_ZNK5polly21IslMaxOperationsGuard16hasQuotaExceededEv'/>
<use f='llvm/polly/lib/Analysis/ScopBuilder.cpp' l='3446' c='_ZN5polly11ScopBuilder16buildAliasGroupsEv'/>
<size>32</size>
<use f='llvm/polly/lib/Transform/DeLICM.cpp' l='1200' c='_ZN12_GLOBAL__N_110DeLICMImpl11computeZoneEv'/>
<size>32</size>
<use f='llvm/polly/lib/Transform/ForwardOpTree.cpp' l='205'/>
<use f='llvm/polly/lib/Transform/ForwardOpTree.cpp' l='342' c='_ZN12_GLOBAL__N_117ForwardOpTreeImplC1EPN5polly4ScopEPN4llvm8LoopInfoERNS1_21IslMaxOperationsGuardE'/>
<use f='llvm/polly/lib/Transform/ForwardOpTree.cpp' l='1062' c='_ZN12_GLOBAL__N_113ForwardOpTree9runOnScopERN5polly4ScopE'/>
<size>32</size>
