<dec f='llvm/llvm/include/llvm/Transforms/Utils/ModuleUtils.h' l='65' type='std::pair&lt;Function *, FunctionCallee&gt; llvm::getOrCreateSanitizerCtorAndInitFunctions(llvm::Module &amp; M, llvm::StringRef CtorName, llvm::StringRef InitName, ArrayRef&lt;llvm::Type *&gt; InitArgTypes, ArrayRef&lt;llvm::Value *&gt; InitArgs, function_ref&lt;void (llvm::Function *, llvm::FunctionCallee)&gt; FunctionsCreatedCallback, llvm::StringRef VersionCheckName = llvm::StringRef())'/>
<doc f='llvm/llvm/include/llvm/Transforms/Utils/ModuleUtils.h' l='58'>/// Creates sanitizer constructor function lazily. If a constructor and init
/// function already exist, this function returns it. Otherwise it calls \c
/// createSanitizerCtorAndInitFunctions. The FunctionsCreatedCallback is invoked
/// in that case, passing the new Ctor and Init function.
///
/// \return Returns pair of pointers to constructor, and init functions
/// respectively.</doc>
<use f='llvm/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp' l='375' u='c' c='_ZN12_GLOBAL__N_118HWAddressSanitizer22createHwasanCtorComdatEv'/>
<use f='llvm/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp' l='613' u='c' c='_ZN12_GLOBAL__N_116insertModuleCtorERN4llvm6ModuleE'/>
<use f='llvm/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp' l='190' u='c' c='_ZN12_GLOBAL__N_116insertModuleCtorERN4llvm6ModuleE'/>
<def f='llvm/llvm/lib/Transforms/Utils/ModuleUtils.cpp' l='152' ll='173' type='std::pair&lt;Function *, FunctionCallee&gt; llvm::getOrCreateSanitizerCtorAndInitFunctions(llvm::Module &amp; M, llvm::StringRef CtorName, llvm::StringRef InitName, ArrayRef&lt;llvm::Type *&gt; InitArgTypes, ArrayRef&lt;llvm::Value *&gt; InitArgs, function_ref&lt;void (llvm::Function *, llvm::FunctionCallee)&gt; FunctionsCreatedCallback, llvm::StringRef VersionCheckName = llvm::StringRef())'/>
