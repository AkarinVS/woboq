<dec f='llvm/llvm/include/llvm/Transforms/Utils/LoopPeel.h' l='23' type='bool llvm::peelLoop(llvm::Loop * L, unsigned int PeelCount, llvm::LoopInfo * LI, llvm::ScalarEvolution * SE, llvm::DominatorTree * DT, llvm::AssumptionCache * AC, bool PreserveLCSSA)'/>
<use f='llvm/llvm/lib/Transforms/Scalar/LoopFuse.cpp' l='766' u='c' c='_ZN12_GLOBAL__N_19LoopFuser19peelFusionCandidateERNS_15FusionCandidateERKS1_j'/>
<def f='llvm/llvm/lib/Transforms/Utils/LoopPeel.cpp' l='669' ll='862' type='bool llvm::peelLoop(llvm::Loop * L, unsigned int PeelCount, llvm::LoopInfo * LI, llvm::ScalarEvolution * SE, llvm::DominatorTree * DT, llvm::AssumptionCache * AC, bool PreserveLCSSA)'/>
<doc f='llvm/llvm/lib/Transforms/Utils/LoopPeel.cpp' l='660'>/// Peel off the first \p PeelCount iterations of loop \p L.
///
/// Note that this does not peel them off as a single straight-line block.
/// Rather, each iteration is peeled off separately, and needs to check the
/// exit condition.
/// For loops that dynamically execute \p PeelCount iterations or less
/// this provides a benefit, since the peeled off iterations, which account
/// for the bulk of dynamic execution, can be further simplified by scalar
/// optimizations.</doc>
<use f='llvm/llvm/lib/Transforms/Utils/LoopUnroll.cpp' l='349' u='c' c='_ZN4llvm10UnrollLoopEPNS_4LoopENS_17UnrollLoopOptionsEPNS_8LoopInfoEPNS_15ScalarEvolutionEPNS_13DominatorTreeEPNS_15AssumptionCacheEPKNS_19TargetTrans5476875'/>
