<def f='llvm/polly/lib/External/isl/isl_tab.h' l='128' ll='133'/>
<use f='llvm/polly/lib/External/isl/isl_tab.h' l='153'/>
<doc f='llvm/polly/lib/External/isl/isl_tab.h' l='67'>/* The tableau maintains equality relations.
 * Each column and each row is associated to a variable or a constraint.
 * The &quot;value&quot; of an inequality constraint is the value of the corresponding
 * slack variable.
 * The &quot;row_var&quot; and &quot;col_var&quot; arrays map column and row indices
 * to indices in the &quot;var&quot; and &quot;con&quot; arrays.  The elements of these
 * arrays maintain extra information about the variables and the constraints.
 * Each row expresses the corresponding row variable as an affine expression
 * of the column variables.
 * The first two columns in the matrix contain the common denominator of
 * the row and the numerator of the constant term.
 * If &quot;M&quot; is set, then the third column represents the &quot;big parameter&quot;.
 * The third (M = 0) or fourth (M = 1) column
 * in the matrix is called column 0 with respect to the col_var array.
 * The sample value of the tableau is the value that assigns zero
 * to all the column variables and the constant term of each affine
 * expression to the corresponding row variable.
 * The operations on the tableau maintain the property that the sample
 * value satisfies the non-negativity constraints (usually on the slack
 * variables).
 *
 * The big parameter represents an arbitrarily big (and divisible)
 * positive number.  If present, then the sign of a row is determined
 * lexicographically, with the sign of the big parameter coefficient
 * considered first.  The big parameter is only used while
 * solving PILP problems.
 *
 * The first n_dead column variables have their values fixed to zero.
 * The corresponding tab_vars are flagged &quot;is_zero&quot;.
 * Some of the rows that have have zero coefficients in all but
 * the dead columns are also flagged &quot;is_zero&quot;.
 *
 * The first n_redundant rows correspond to inequality constraints
 * that are always satisfied for any value satisfying the non-redundant
 * rows.  The corresponding tab_vars are flagged &quot;is_redundant&quot;.
 * A row variable that is flagged &quot;is_zero&quot; is also flagged &quot;is_redundant&quot;
 * since the constraint has been reduced to 0 = 0 and is therefore always
 * satisfied.
 *
 * There are &quot;n_var&quot; variables in total.  The first &quot;n_param&quot; of these
 * are called parameters and the last &quot;n_div&quot; of these are called divs.
 * The basic tableau operations makes no distinction between different
 * kinds of variables.  These special variables are only used while
 * solving PILP problems.
 *
 * Dead columns and redundant rows are detected on the fly.
 * However, the basic operations do not ensure that all dead columns
 * or all redundant rows are detected.
 * isl_tab_detect_implicit_equalities and isl_tab_detect_redundant can be used
 * to perform an exhaustive search for dead columns and redundant rows.
 *
 * The samples matrix contains &quot;n_sample&quot; integer points that have at some
 * point been elements satisfying the tableau.  The first &quot;n_outside&quot;
 * of them no longer satisfy the tableau.  They are kept because they
 * can be reinstated during rollback when the constraint that cut them
 * out is removed.  These samples are only maintained for the context
 * tableau while solving PILP problems.
 *
 * If &quot;preserve&quot; is set, then we want to keep all constraints in the
 * tableau, even if they turn out to be redundant.
 */</doc>
<use f='llvm/polly/lib/External/isl/isl_tab.c' l='137' c='isl_tab_extend_cons'/>
<use f='llvm/polly/lib/External/isl/isl_tab.c' l='139' c='isl_tab_extend_cons'/>
<use f='llvm/polly/lib/External/isl/isl_tab.c' l='139' c='isl_tab_extend_cons'/>
<use f='llvm/polly/lib/External/isl/isl_tab.c' l='260' c='isl_tab_dup'/>
<use f='llvm/polly/lib/External/isl/isl_tab.c' l='260' c='isl_tab_dup'/>
<use f='llvm/polly/lib/External/isl/isl_tab.c' l='773' c='swap_rows'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='89'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='2326' c='tab_for_lexmin'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='2326' c='tab_for_lexmin'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='2543' c='tab_ineq_sign'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='2549' c='tab_ineq_sign'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='2580' c='context_lex_ineq_sign'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='3233' c='context_gbr_ineq_sign'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='3839' c='row_sign'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='3843' c='row_sign'/>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='4110' c='find_solutions'/>
