<dec f='llvm/llvm/lib/Target/X86/X86InstrInfo.h' l='526' type='llvm::MachineInstr * llvm::X86InstrInfo::optimizeLoadInstr(llvm::MachineInstr &amp; MI, const llvm::MachineRegisterInfo * MRI, llvm::Register &amp; FoldAsLoadDefReg, llvm::MachineInstr *&amp; DefMI) const'/>
<doc f='llvm/llvm/lib/Target/X86/X86InstrInfo.h' l='519'>/// optimizeLoadInstr - Try to remove the load by folding it to a register
  /// operand at the use. We fold the load instructions if and only if the
  /// def and use are in the same BB. We only look at one load and see
  /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register
  /// defined by the load we are trying to fold. DefMI returns the machine
  /// instruction that defines FoldAsLoadDefReg, and the function returns
  /// the machine instruction generated due to folding.</doc>
<inh f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='1525' c='_ZNK4llvm15TargetInstrInfo17optimizeLoadInstrERNS_12MachineInstrEPKNS_19MachineRegisterInfoERNS_8RegisterERPS1_'/>
<def f='llvm/llvm/lib/Target/X86/X86InstrInfo.cpp' l='4417' ll='4452' type='llvm::MachineInstr * llvm::X86InstrInfo::optimizeLoadInstr(llvm::MachineInstr &amp; MI, const llvm::MachineRegisterInfo * MRI, llvm::Register &amp; FoldAsLoadDefReg, llvm::MachineInstr *&amp; DefMI) const'/>
<doc f='llvm/llvm/lib/Target/X86/X86InstrInfo.cpp' l='4413'>/// Try to remove the load by folding it to a register
/// operand at the use. We fold the load instructions if load defines a virtual
/// register, the virtual register is used once in the same BB, and the
/// instructions in-between do not load or store, and have no side effects.</doc>
