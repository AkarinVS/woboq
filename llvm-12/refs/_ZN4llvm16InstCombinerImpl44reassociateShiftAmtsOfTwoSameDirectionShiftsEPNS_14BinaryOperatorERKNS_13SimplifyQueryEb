<dec f='llvm/llvm/lib/Transforms/InstCombine/InstCombineInternal.h' l='111' type='llvm::Value * llvm::InstCombinerImpl::reassociateShiftAmtsOfTwoSameDirectionShifts(llvm::BinaryOperator * Sh0, const llvm::SimplifyQuery &amp; SQ, bool AnalyzeForSignBitExtraction = false)'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp' l='1342' u='c' c='_ZN4llvm16InstCombinerImpl15foldSignBitTestERNS_8ICmpInstE'/>
<def f='llvm/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp' l='35' ll='160' type='llvm::Value * llvm::InstCombinerImpl::reassociateShiftAmtsOfTwoSameDirectionShifts(llvm::BinaryOperator * Sh0, const llvm::SimplifyQuery &amp; SQ, bool AnalyzeForSignBitExtraction = false)'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp' l='392' u='c' c='_ZN4llvm16InstCombinerImpl21commonShiftTransformsERNS_14BinaryOperatorE'/>
<doc f='llvm/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp' l='24'>// Given pattern:
//   (x shiftopcode Q) shiftopcode K
// we should rewrite it as
//   x shiftopcode (Q+K)  iff (Q+K) u&lt; bitwidth(x) and
//
// This is valid for any shift, but they must be identical, and we must be
// careful in case we have (zext(Q)+zext(K)) and look past extensions,
// (Q+K) must not overflow or else (Q+K) u&lt; bitwidth(x) is bogus.
//
// AnalyzeForSignBitExtraction indicates that we will only analyze whether this
// pattern has any 2 right-shifts that sum to 1 less than original bit width.</doc>
