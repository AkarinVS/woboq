<dec f='llvm/llvm/include/llvm/Transforms/Scalar/LICM.h' l='42' type='cl::opt&lt;unsigned int&gt;'/>
<use f='llvm/llvm/include/llvm/Transforms/Scalar/LICM.h' l='52' u='m' c='_ZN4llvm8LICMPassC1Ev'/>
<use f='llvm/llvm/lib/Passes/PassBuilder.cpp' l='284' u='m' c='_ZN4llvm21PipelineTuningOptionsC1Ev'/>
<use f='llvm/llvm/lib/Transforms/IPO/PassManagerBuilder.cpp' l='193' u='m' c='_ZN4llvm18PassManagerBuilderC1Ev'/>
<def f='llvm/llvm/lib/Transforms/Scalar/LICM.cpp' l='136' ll='139' type='cl::opt&lt;unsigned int&gt;'/>
<use f='llvm/llvm/lib/Transforms/Scalar/LICM.cpp' l='214' u='m' c='_ZN12_GLOBAL__N_114LegacyLICMPassC1Ejj'/>
<use f='llvm/llvm/lib/Transforms/Scalar/LICM.cpp' l='314' u='m' c='_ZN4llvm21SinkAndHoistLICMFlagsC1EbPNS_4LoopEPNS_9MemorySSAE'/>
<doc f='llvm/llvm/lib/Transforms/Scalar/LICM.cpp' l='127'>// Experimental option to allow imprecision in LICM in pathological cases, in
// exchange for faster compile. This is to be removed if MemorySSA starts to
// address the same issue. This flag applies only when LICM uses MemorySSA
// instead on AliasSetTracker. LICM calls MemorySSAWalker&apos;s
// getClobberingMemoryAccess, up to the value of the Cap, getting perfect
// accuracy. Afterwards, LICM will call into MemorySSA&apos;s getDefiningAccess,
// which may not be precise, since optimizeUses is capped. The result is
// correct, but we may not get as &quot;far up&quot; as possible to get which access is
// clobbering the one queried.</doc>
