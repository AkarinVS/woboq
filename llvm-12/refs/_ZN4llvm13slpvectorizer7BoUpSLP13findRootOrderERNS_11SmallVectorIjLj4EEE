<def f='llvm/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp' l='667' ll='727' type='void llvm::slpvectorizer::BoUpSLP::findRootOrder(llvm::slpvectorizer::BoUpSLP::OrdersType &amp; Order)'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp' l='2807' u='c' c='_ZN4llvm13slpvectorizer7BoUpSLP13buildTree_recENS_8ArrayRefIPNS_5ValueEEEjRKNS1_8EdgeInfoE'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp' l='2890' u='c' c='_ZN4llvm13slpvectorizer7BoUpSLP13buildTree_recENS_8ArrayRefIPNS_5ValueEEEjRKNS1_8EdgeInfoE'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp' l='3170' u='c' c='_ZN4llvm13slpvectorizer7BoUpSLP13buildTree_recENS_8ArrayRefIPNS_5ValueEEEjRKNS1_8EdgeInfoE'/>
<doc f='llvm/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp' l='654'>/// Builds the correct order for root instructions.
  /// If some leaves have the same instructions to be vectorized, we may
  /// incorrectly evaluate the best order for the root node (it is built for the
  /// vector of instructions without repeated instructions and, thus, has less
  /// elements than the root node). This function builds the correct order for
  /// the root node.
  /// For example, if the root node is \&lt;a+b, a+c, a+d, f+e\&gt;, then the leaves
  /// are \&lt;a, a, a, f\&gt; and \&lt;b, c, d, e\&gt;. When we try to vectorize the first
  /// leaf, it will be shrink to \&lt;a, b\&gt;. If instructions in this leaf should
  /// be reordered, the best order will be \&lt;1, 0\&gt;. We need to extend this
  /// order for the root node. For the root node this order should look like
  /// \&lt;3, 0, 1, 2\&gt;. This function extends the order for the reused
  /// instructions.</doc>
