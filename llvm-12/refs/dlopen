<dec f='include/dlfcn.h' l='56' type='void * dlopen(const char * __file, int __mode)'/>
<doc f='include/dlfcn.h' l='54'>/* Open the shared object FILE and map it in; return a handle that can be
   passed to `dlsym&apos; to get symbol values from it.  */</doc>
<def f='llvm/compiler-rt/lib/sanitizer_common/sanitizer_common_interceptors.inc' l='6246' macro='1' type='void * dlopen(const char * filename, int flag)'/>
<use f='llvm/compiler-rt/lib/sanitizer_common/sanitizer_common_interceptors.inc' l='6266' u='a' c='_ZL28InitializeCommonInterceptorsv'/>
<def f='llvm/compiler-rt/lib/cfi/cfi.cpp' l='423' macro='1' type='void * dlopen(const char * filename, int flag)'/>
<use f='llvm/compiler-rt/lib/cfi/cfi.cpp' l='447' u='a' c='_ZL29EnsureInterceptorsInitializedv'/>
<doc f='llvm/compiler-rt/lib/cfi/cfi.cpp' l='415'>// Setup shadow for dlopen()ed libraries.
// The actual shadow setup happens after dlopen() returns, which means that
// a library can not be a target of any CFI checks while its constructors are
// running. It&apos;s unclear how to fix this without some extra help from libc.
// In glibc, mmap inside dlopen is not interceptable.
// Maybe a seccomp-bpf filter?
// We could insert a high-priority constructor into the library, but that would
// not help with the uninstrumented libraries.</doc>
<use f='llvm/compiler-rt/lib/dfsan/dfsan_custom.cpp' l='389' u='c' c='__dfsw_dlopen'/>
<use f='llvm/llvm/lib/Support/Unix/DynamicLibrary.inc' l='28' u='c' c='_ZN4llvm3sys14DynamicLibrary9HandleSet6DLOpenEPKcPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE'/>
