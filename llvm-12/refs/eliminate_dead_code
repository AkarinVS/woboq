<dec f='llvm/polly/lib/External/ppcg/ppcg.h' l='126' type='void eliminate_dead_code(struct ppcg_scop * ps)'/>
<def f='llvm/polly/lib/External/ppcg/ppcg.c' l='772' ll='815' type='void eliminate_dead_code(struct ppcg_scop * ps)'/>
<use f='llvm/polly/lib/External/ppcg/ppcg.c' l='921' u='c' c='ppcg_scop_from_pet_scop'/>
<doc f='llvm/polly/lib/External/ppcg/ppcg.c' l='751'>/* Eliminate dead code from ps-&gt;domain.
 *
 * In particular, intersect both ps-&gt;domain and the domain of
 * ps-&gt;schedule with the (parts of) iteration
 * domains that are needed to produce the output or for statement
 * iterations that call functions.
 * Also intersect the range of the dataflow dependences with
 * this domain such that the removed instances will no longer
 * be considered as targets of dataflow.
 *
 * We start with the iteration domains that call functions
 * and the set of iterations that last write to an array
 * (except those that are later killed).
 *
 * Then we add those statement iterations that produce
 * something needed by the &quot;live&quot; statements iterations.
 * We keep doing this until no more statement iterations can be added.
 * To ensure that the procedure terminates, we compute the affine
 * hull of the live iterations (bounded to the original iteration
 * domains) each time we have added extra iterations.
 */</doc>
