<def f='llvm/compiler-rt/lib/lsan/lsan_common.cpp' l='537' ll='545' type='void __lsan::ProcessPC(__lsan::Frontier * frontier)'/>
<use f='llvm/compiler-rt/lib/lsan/lsan_common.cpp' l='563' u='c' c='__lsan::ClassifyAllChunks'/>
<doc f='llvm/compiler-rt/lib/lsan/lsan_common.cpp' l='517'>// On Linux, treats all chunks allocated from ld-linux.so as reachable, which
// covers dynamically allocated TLS blocks, internal dynamic loader&apos;s loaded
// modules accounting etc.
// Dynamic TLS blocks contain the TLS variables of dynamically loaded modules.
// They are allocated with a __libc_memalign() call in allocate_and_init()
// (elf/dl-tls.c). Glibc won&apos;t tell us the address ranges occupied by those
// blocks, but we can make sure they come from our own allocator by intercepting
// __libc_memalign(). On top of that, there is no easy way to reach them. Their
// addresses are stored in a dynamically allocated array (the DTV) which is
// referenced from the static TLS. Unfortunately, we can&apos;t just rely on the DTV
// being reachable from the static TLS, and the dynamic TLS being reachable from
// the DTV. This is because the initial DTV is allocated before our interception
// mechanism kicks in, and thus we don&apos;t recognize it as allocated memory. We
// can&apos;t special-case it either, since we don&apos;t know its size.
// Our solution is to include in the root set all allocations made from
// ld-linux.so (which is where allocate_and_init() is implemented). This is
// guaranteed to include all dynamic TLS blocks (and possibly other allocations
// which we don&apos;t care about).
// On all other platforms, this simply checks to ensure that the caller pc is
// valid before reporting chunks as leaked.</doc>
