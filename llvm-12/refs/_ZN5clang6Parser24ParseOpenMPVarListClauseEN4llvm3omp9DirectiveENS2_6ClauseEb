<dec f='llvm/clang/include/clang/Parse/Parser.h' l='3222' type='clang::OMPClause * clang::Parser::ParseOpenMPVarListClause(clang::OpenMPDirectiveKind DKind, clang::OpenMPClauseKind Kind, bool ParseOnly)'/>
<doc f='llvm/clang/include/clang/Parse/Parser.h' l='3216'>/// Parses clause with the list of variables of a kind \a Kind.
  ///
  /// \param Kind Kind of current clause.
  /// \param ParseOnly true to skip the clause&apos;s semantic actions and return
  /// nullptr.
  ///</doc>
<use f='llvm/clang/lib/Parse/ParseOpenMP.cpp' l='2871' u='c' c='_ZN5clang6Parser17ParseOpenMPClauseEN4llvm3omp9DirectiveENS2_6ClauseEb'/>
<def f='llvm/clang/lib/Parse/ParseOpenMP.cpp' l='3836' ll='3856' type='clang::OMPClause * clang::Parser::ParseOpenMPVarListClause(clang::OpenMPDirectiveKind DKind, clang::OpenMPClauseKind Kind, bool ParseOnly)'/>
<doc f='llvm/clang/lib/Parse/ParseOpenMP.cpp' l='3781'>/// Parsing of OpenMP clause &apos;private&apos;, &apos;firstprivate&apos;, &apos;lastprivate&apos;,
/// &apos;shared&apos;, &apos;copyin&apos;, &apos;copyprivate&apos;, &apos;flush&apos;, &apos;reduction&apos;, &apos;task_reduction&apos;,
/// &apos;in_reduction&apos;, &apos;nontemporal&apos;, &apos;exclusive&apos; or &apos;inclusive&apos;.
///
///    private-clause:
///       &apos;private&apos; &apos;(&apos; list &apos;)&apos;
///    firstprivate-clause:
///       &apos;firstprivate&apos; &apos;(&apos; list &apos;)&apos;
///    lastprivate-clause:
///       &apos;lastprivate&apos; &apos;(&apos; list &apos;)&apos;
///    shared-clause:
///       &apos;shared&apos; &apos;(&apos; list &apos;)&apos;
///    linear-clause:
///       &apos;linear&apos; &apos;(&apos; linear-list [ &apos;:&apos; linear-step ] &apos;)&apos;
///    aligned-clause:
///       &apos;aligned&apos; &apos;(&apos; list [ &apos;:&apos; alignment ] &apos;)&apos;
///    reduction-clause:
///       &apos;reduction&apos; &apos;(&apos; [ modifier &apos;,&apos; ] reduction-identifier &apos;:&apos; list &apos;)&apos;
///    task_reduction-clause:
///       &apos;task_reduction&apos; &apos;(&apos; reduction-identifier &apos;:&apos; list &apos;)&apos;
///    in_reduction-clause:
///       &apos;in_reduction&apos; &apos;(&apos; reduction-identifier &apos;:&apos; list &apos;)&apos;
///    copyprivate-clause:
///       &apos;copyprivate&apos; &apos;(&apos; list &apos;)&apos;
///    flush-clause:
///       &apos;flush&apos; &apos;(&apos; list &apos;)&apos;
///    depend-clause:
///       &apos;depend&apos; &apos;(&apos; in | out | inout : list | source &apos;)&apos;
///    map-clause:
///       &apos;map&apos; &apos;(&apos; [ [ always [,] ] [ close [,] ]
///          [ mapper &apos;(&apos; mapper-identifier &apos;)&apos; [,] ]
///          to | from | tofrom | alloc | release | delete &apos;:&apos; ] list &apos;)&apos;;
///    to-clause:
///       &apos;to&apos; &apos;(&apos; [ mapper &apos;(&apos; mapper-identifier &apos;)&apos; &apos;:&apos; ] list &apos;)&apos;
///    from-clause:
///       &apos;from&apos; &apos;(&apos; [ mapper &apos;(&apos; mapper-identifier &apos;)&apos; &apos;:&apos; ] list &apos;)&apos;
///    use_device_ptr-clause:
///       &apos;use_device_ptr&apos; &apos;(&apos; list &apos;)&apos;
///    use_device_addr-clause:
///       &apos;use_device_addr&apos; &apos;(&apos; list &apos;)&apos;
///    is_device_ptr-clause:
///       &apos;is_device_ptr&apos; &apos;(&apos; list &apos;)&apos;
///    allocate-clause:
///       &apos;allocate&apos; &apos;(&apos; [ allocator &apos;:&apos; ] list &apos;)&apos;
///    nontemporal-clause:
///       &apos;nontemporal&apos; &apos;(&apos; list &apos;)&apos;
///    inclusive-clause:
///       &apos;inclusive&apos; &apos;(&apos; list &apos;)&apos;
///    exclusive-clause:
///       &apos;exclusive&apos; &apos;(&apos; list &apos;)&apos;
///
/// For &apos;linear&apos; clause linear-list may have the following forms:
///  list
///  modifier(list)
/// where modifier is &apos;val&apos; (C) or &apos;ref&apos;, &apos;val&apos; or &apos;uval&apos;(C++).</doc>
