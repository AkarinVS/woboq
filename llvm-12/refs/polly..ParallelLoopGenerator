<def f='llvm/polly/include/polly/CodeGen/LoopGenerators.h' l='111' ll='216'/>
<ovr f='llvm/polly/include/polly/CodeGen/LoopGeneratorsGOMP.h' l='26' c='polly::ParallelLoopGeneratorGOMP'/>
<use f='llvm/polly/include/polly/CodeGen/LoopGeneratorsGOMP.h' l='26'/>
<use f='llvm/polly/include/polly/CodeGen/LoopGeneratorsGOMP.h' l='31' c='_ZN5polly25ParallelLoopGeneratorGOMPC1ERN4llvm9IRBuilderINS1_14ConstantFolderENS_10IRInserterEEERNS1_8LoopInfoERNS1_13DominatorTreeERKNS1_10DataLayoutE'/>
<ovr f='llvm/polly/include/polly/CodeGen/LoopGeneratorsKMP.h' l='26' c='polly::ParallelLoopGeneratorKMP'/>
<use f='llvm/polly/include/polly/CodeGen/LoopGeneratorsKMP.h' l='26'/>
<use f='llvm/polly/include/polly/CodeGen/LoopGeneratorsKMP.h' l='31' c='_ZN5polly24ParallelLoopGeneratorKMPC1ERN4llvm9IRBuilderINS1_14ConstantFolderENS_10IRInserterEEERNS1_8LoopInfoERNS1_13DominatorTreeERKNS1_10DataLayoutE'/>
<use f='llvm/polly/lib/CodeGen/IslNodeBuilder.cpp' l='681' c='_ZN14IslNodeBuilder17createForParallelEP12isl_ast_node'/>
<size>48</size>
<doc f='llvm/polly/include/polly/CodeGen/LoopGenerators.h' l='71'>/// The ParallelLoopGenerator allows to create parallelized loops
///
/// To parallelize a loop, we perform the following steps:
///   o  Generate a subfunction which will hold the loop body.
///   o  Create a struct to hold all outer values needed in the loop body.
///   o  Create calls to a runtime library to achieve the actual parallelism.
///      These calls will spawn and join threads, define how the work (here the
///      iterations) are distributed between them and make sure each has access
///      to the struct holding all needed values.
///
/// At the moment we support only one parallel runtime, OpenMP.
///
/// If we parallelize the outer loop of the following loop nest,
///
///   S0;
///   for (int i = 0; i &lt; N; i++)
///     for (int j = 0; j &lt; M; j++)
///       S1(i, j);
///   S2;
///
/// we will generate the following code (with different runtime function names):
///
///   S0;
///   auto *values = storeValuesIntoStruct();
///   // Execute subfunction with multiple threads
///   spawn_threads(subfunction, values);
///   join_threads();
///   S2;
///
///  // This function is executed in parallel by different threads
///   void subfunction(values) {
///     while (auto *WorkItem = getWorkItem()) {
///       int LB = WorkItem.begin();
///       int UB = WorkItem.end();
///       for (int i = LB; i &lt; UB; i++)
///         for (int j = 0; j &lt; M; j++)
///           S1(i, j);
///     }
///     cleanup_thread();
///   }</doc>
<fun r='_ZN5polly21ParallelLoopGeneratorC1ERN4llvm9IRBuilderINS1_14ConstantFolderENS_10IRInserterEEERNS1_8LoopInfoERNS1_13DominatorTreeERKNS1_10DataLayoutE'/>
<fun r='_ZN5polly21ParallelLoopGeneratorD1Ev'/>
<fun r='_ZN5polly21ParallelLoopGenerator18createParallelLoopEPN4llvm5ValueES3_S3_RNS1_9SetVectorIS3_St6vectorIS3_SaIS3_EENS1_8DenseSetIS3_NS1_12DenseMapInfoIS3967497'/>
<mbr r='polly::ParallelLoopGenerator::Builder' o='64' t='polly::PollyIRBuilder &amp;'/>
<mbr r='polly::ParallelLoopGenerator::LI' o='128' t='llvm::LoopInfo &amp;'/>
<mbr r='polly::ParallelLoopGenerator::DT' o='192' t='llvm::DominatorTree &amp;'/>
<mbr r='polly::ParallelLoopGenerator::LongType' o='256' t='llvm::Type *'/>
<mbr r='polly::ParallelLoopGenerator::M' o='320' t='llvm::Module *'/>
<fun r='_ZN5polly21ParallelLoopGenerator21storeValuesIntoStructERN4llvm9SetVectorIPNS1_5ValueESt6vectorIS4_SaIS4_EENS1_8DenseSetIS4_NS1_12DenseMapInfoIS4_EEEEEE'/>
<fun r='_ZN5polly21ParallelLoopGenerator23extractValuesFromStructEN4llvm9SetVectorIPNS1_5ValueESt6vectorIS4_SaIS4_EENS1_8DenseSetIS4_NS1_12DenseMapInfoIS4_EEE5505049'/>
<fun r='_ZN5polly21ParallelLoopGenerator21createSubFnDefinitionEv'/>
<fun r='_ZN5polly21ParallelLoopGenerator23deployParallelExecutionEPN4llvm8FunctionEPNS1_5ValueES5_S5_S5_'/>
<fun r='_ZNK5polly21ParallelLoopGenerator22prepareSubFnDefinitionEPN4llvm8FunctionE'/>
<fun r='_ZN5polly21ParallelLoopGenerator11createSubFnEPN4llvm5ValueEPNS1_10AllocaInstENS1_9SetVectorIS3_St6vectorIS3_SaIS3_EENS1_8DenseSetIS3_NS1_12DenseMapIn9538730'/>
