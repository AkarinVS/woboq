<dec f='llvm/llvm/include/llvm/Analysis/ScalarEvolution.h' l='1629' type='llvm::ScalarEvolution::ExitLimit llvm::ScalarEvolution::computeExitLimitFromCond(const llvm::Loop * L, llvm::Value * ExitCond, bool ExitIfTrue, bool ControlsExit, bool AllowPredicates = false)'/>
<doc f='llvm/llvm/include/llvm/Analysis/ScalarEvolution.h' l='1619'>/// Compute the number of times the backedge of the specified loop will
  /// execute if its exit condition were a conditional branch of ExitCond.
  ///
  /// \p ControlsExit is true if ExitCond directly controls the exit
  /// branch. In this case, we can assume that the loop exits only if the
  /// condition is true and can infer that failing to meet the condition prior
  /// to integer wraparound results in undefined behavior.
  ///
  /// If \p AllowPredicates is set, this call will try to use a minimal set of
  /// SCEV predicates in order to return an exact answer.</doc>
<use f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='7463' u='c' c='_ZN4llvm15ScalarEvolution16computeExitLimitEPKNS_4LoopEPNS_10BasicBlockEb'/>
<def f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='7485' ll='7491' type='ScalarEvolution::ExitLimit llvm::ScalarEvolution::computeExitLimitFromCond(const llvm::Loop * L, llvm::Value * ExitCond, bool ExitIfTrue, bool ControlsExit, bool AllowPredicates = false)'/>
