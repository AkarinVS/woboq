<def f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='1712' ll='1716' type='unsigned int llvm::TargetInstrInfo::getUndefRegClearance(const llvm::MachineInstr &amp; MI, unsigned int OpNum, const llvm::TargetRegisterInfo * TRI) const'/>
<doc f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='1698'>/// Return the minimum clearance before an instruction that reads an
  /// unused register.
  ///
  /// For example, AVX instructions may copy part of a register operand into
  /// the unused high bits of the destination register.
  ///
  /// vcvtsi2sdq %rax, undef %xmm0, %xmm14
  ///
  /// In the code above, vcvtsi2sdq copies %xmm0[127:64] into %xmm14 creating a
  /// false dependence on any previous write to %xmm0.
  ///
  /// This hook works similarly to getPartialRegUpdateClearance, except that it
  /// does not take an operand index. Instead sets \p OpNum to the index of the
  /// unused register.</doc>
<use f='llvm/llvm/lib/CodeGen/BreakFalseDeps.cpp' l='198' u='c' c='_ZN4llvm14BreakFalseDeps11processDefsEPNS_12MachineInstrE'/>
<ovr f='llvm/llvm/lib/Target/X86/X86InstrInfo.cpp' l='5227' c='_ZNK4llvm12X86InstrInfo20getUndefRegClearanceERKNS_12MachineInstrEjPKNS_18TargetRegisterInfoE'/>
