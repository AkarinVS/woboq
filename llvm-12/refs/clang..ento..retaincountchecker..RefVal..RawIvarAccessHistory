<dec f='llvm/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h' l='108' type='unsigned int'/>
<use f='llvm/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h' l='114' u='w' c='_ZN5clang4ento18retaincountchecker6RefValC1ENS2_4KindENS0_7ObjKindEjjNS_8QualTypeENS2_17IvarAccessHistoryE'/>
<use f='llvm/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h' l='149' u='r' c='_ZNK5clang4ento18retaincountchecker6RefVal20getIvarAccessHistoryEv'/>
<use f='llvm/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h' l='232' u='r' c='_ZNK5clang4ento18retaincountchecker6RefVal7ProfileERN4llvm16FoldingSetNodeIDE'/>
<offset>136</offset>
<doc f='llvm/clang/lib/StaticAnalyzer/Checkers/RetainCountChecker/RetainCountChecker.h' l='99'>/// True if the current state and/or retain count may turn out to not be the
  /// best possible approximation of the reference counting state.
  ///
  /// If true, the checker may decide to throw away (&quot;override&quot;) this state
  /// in favor of something else when it sees the object being used in new ways.
  ///
  /// This setting should not be propagated to state derived from this state.
  /// Once we start deriving new states, it would be inconsistent to override
  /// them.</doc>
