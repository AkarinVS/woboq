<dec f='llvm/llvm/include/llvm/CodeGen/LiveInterval.h' l='864' type='void llvm::LiveInterval::refineSubRanges(llvm::BumpPtrAllocator &amp; Allocator, llvm::LaneBitmask LaneMask, std::function&lt;void (LiveInterval::SubRange &amp;)&gt; Apply, const llvm::SlotIndexes &amp; Indexes, const llvm::TargetRegisterInfo &amp; TRI, unsigned int ComposeSubRegIdx = 0)'/>
<doc f='llvm/llvm/include/llvm/CodeGen/LiveInterval.h' l='825'>/// Refines the subranges to support \p LaneMask. This may only be called
    /// for LI.hasSubrange()==true. Subregister ranges are split or created
    /// until \p LaneMask can be matched exactly. \p Mod is executed on the
    /// matching subranges.
    ///
    /// Example:
    ///    Given an interval with subranges with lanemasks L0F00, L00F0 and
    ///    L000F, refining for mask L0018. Will split the L00F0 lane into
    ///    L00E0 and L0010 and the L000F lane into L0007 and L0008. The Mod
    ///    function will be applied to the L0010 and L0008 subranges.
    ///
    /// \p Indexes and \p TRI are required to clean up the VNIs that
    /// don&apos;t define the related lane masks after they get shrunk. E.g.,
    /// when L000F gets split into L0007 and L0008 maybe only a subset
    /// of the VNIs that defined L000F defines L0007.
    ///
    /// The clean up of the VNIs need to look at the actual instructions
    /// to decide what is or is not live at a definition point. If the
    /// update of the subranges occurs while the IR does not reflect these
    /// changes, \p ComposeSubRegIdx can be used to specify how the
    /// definition are going to be rewritten.
    /// E.g., let say we want to merge:
    ///     V1.sub1:&lt;2 x s32&gt; = COPY V2.sub3:&lt;4 x s32&gt;
    /// We do that by choosing a class where sub1:&lt;2 x s32&gt; and sub3:&lt;4 x s32&gt;
    /// overlap, i.e., by choosing a class where we can find &quot;offset + 1 == 3&quot;.
    /// Put differently we align V2&apos;s sub3 with V1&apos;s sub1:
    /// V2: sub0 sub1 sub2 sub3
    /// V1: &lt;offset&gt;  sub0 sub1
    ///
    /// This offset will look like a composed subregidx in the the class:
    ///     V1.(composed sub2 with sub1):&lt;4 x s32&gt; = COPY V2.sub3:&lt;4 x s32&gt;
    /// =&gt;  V1.(composed sub2 with sub1):&lt;4 x s32&gt; = COPY V2.sub3:&lt;4 x s32&gt;
    ///
    /// Now if we didn&apos;t rewrite the uses and def of V1, all the checks for V1
    /// need to account for this offset.
    /// This happens during coalescing where we update the live-ranges while
    /// still having the old IR around because updating the IR on-the-fly
    /// would actually clobber some information on how the live-ranges that
    /// are being updated look like.</doc>
<def f='llvm/llvm/lib/CodeGen/LiveInterval.cpp' l='930' ll='967' type='void llvm::LiveInterval::refineSubRanges(llvm::BumpPtrAllocator &amp; Allocator, llvm::LaneBitmask LaneMask, std::function&lt;void (LiveInterval::SubRange &amp;)&gt; Apply, const llvm::SlotIndexes &amp; Indexes, const llvm::TargetRegisterInfo &amp; TRI, unsigned int ComposeSubRegIdx = 0)'/>
<use f='llvm/llvm/lib/CodeGen/LiveIntervalCalc.cpp' l='79' u='c' c='_ZN4llvm16LiveIntervalCalc9calculateERNS_12LiveIntervalEb'/>
<use f='llvm/llvm/lib/CodeGen/RegisterCoalescer.cpp' l='990' u='c' c='_ZN12_GLOBAL__N_117RegisterCoalescer24removeCopyByCommutingDefERKN4llvm13CoalescerPairEPNS1_12MachineInstrE'/>
<use f='llvm/llvm/lib/CodeGen/RegisterCoalescer.cpp' l='3415' u='c' c='_ZN12_GLOBAL__N_117RegisterCoalescer17mergeSubRangeIntoERN4llvm12LiveIntervalERKNS1_9LiveRangeENS1_11LaneBitmaskERNS1_13CoalescerPairEj'/>
<use f='llvm/llvm/lib/CodeGen/SplitKit.cpp' l='533' u='c' c='_ZN4llvm11SplitEditor21buildSingleSubRegCopyENS_8RegisterES1_RNS_17MachineBasicBlockENS_26MachineInstrBundleIteratorINS_12MachineInstrELb0EEEjRNS_12Li5046593'/>
