<dec f='llvm/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h' l='424' type='llvm::Value * llvm::SCEVExpander::expandAddToGEP(const llvm::SCEV *const * op_begin, const llvm::SCEV *const * op_end, llvm::PointerType * PTy, llvm::Type * Ty, llvm::Value * V)'/>
<doc f='llvm/llvm/include/llvm/Transforms/Utils/ScalarEvolutionExpander.h' l='422'>/// Expand a SCEVAddExpr with a pointer type into a GEP instead of using
  /// ptrtoint+arithmetic+inttoptr.</doc>
<def f='llvm/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp' l='428' ll='621' type='llvm::Value * llvm::SCEVExpander::expandAddToGEP(const llvm::SCEV *const * op_begin, const llvm::SCEV *const * op_end, llvm::PointerType * PTy, llvm::Type * Ty, llvm::Value * V)'/>
<use f='llvm/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp' l='626' u='c' c='_ZN4llvm12SCEVExpander14expandAddToGEPEPKNS_4SCEVEPNS_11PointerTypeEPNS_4TypeEPNS_5ValueE'/>
<use f='llvm/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp' l='754' u='c' c='_ZN4llvm12SCEVExpander12visitAddExprEPKNS_11SCEVAddExprE'/>
<use f='llvm/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp' l='764' u='c' c='_ZN4llvm12SCEVExpander12visitAddExprEPKNS_11SCEVAddExprE'/>
<doc f='llvm/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp' l='401'>/// expandAddToGEP - Expand an addition expression with a pointer type into
/// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps
/// BasicAliasAnalysis and other passes analyze the result. See the rules
/// for getelementptr vs. inttoptr in
/// http://llvm.org/docs/LangRef.html#pointeraliasing
/// for details.
///
/// Design note: The correctness of using getelementptr here depends on
/// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as
/// they may introduce pointer arithmetic which may not be safely converted
/// into getelementptr.
///
/// Design note: It might seem desirable for this function to be more
/// loop-aware. If some of the indices are loop-invariant while others
/// aren&apos;t, it might seem desirable to emit multiple GEPs, keeping the
/// loop-invariant portions of the overall computation outside the loop.
/// However, there are a few reasons this is not done here. Hoisting simple
/// arithmetic is a low-level optimization that often isn&apos;t very
/// important until late in the optimization process. In fact, passes
/// like InstructionCombining will combine GEPs, even if it means
/// pushing loop-invariant computation down into loops, so even if the
/// GEPs were split here, the work would quickly be undone. The
/// LoopStrengthReduction pass, which is usually run quite late (and
/// after the last InstructionCombining pass), takes care of hoisting
/// loop-invariant portions of expressions, after considering what
/// can be folded using target addressing modes.
///</doc>
