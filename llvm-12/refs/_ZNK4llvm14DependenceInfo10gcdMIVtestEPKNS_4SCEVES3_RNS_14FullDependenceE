<dec f='llvm/llvm/include/llvm/Analysis/DependenceAnalysis.h' l='770' type='bool llvm::DependenceInfo::gcdMIVtest(const llvm::SCEV * Src, const llvm::SCEV * Dst, llvm::FullDependence &amp; Result) const'/>
<doc f='llvm/llvm/include/llvm/Analysis/DependenceAnalysis.h' l='764'>/// gcdMIVtest - Tests an MIV subscript pair for dependence.
    /// Returns true if any possible dependence is disproved.
    /// Marks the result as inconsistent.
    /// Can sometimes disprove the equal direction for 1 or more loops.
    //  Can handle some symbolics that even the SIV tests don&apos;t get,
    /// so we use it as a backup for everything.</doc>
<use f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='2166' u='c' c='_ZNK4llvm14DependenceInfo7testSIVEPKNS_4SCEVES3_RjRNS_14FullDependenceERNS0_10ConstraintERS3_'/>
<use f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='2177' u='c' c='_ZNK4llvm14DependenceInfo7testSIVEPKNS_4SCEVES3_RjRNS_14FullDependenceERNS0_10ConstraintERS3_'/>
<use f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='2187' u='c' c='_ZNK4llvm14DependenceInfo7testSIVEPKNS_4SCEVES3_RjRNS_14FullDependenceERNS0_10ConstraintERS3_'/>
<use f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='2263' u='c' c='_ZNK4llvm14DependenceInfo8testRDIVEPKNS_4SCEVES3_RNS_14FullDependenceE'/>
<use f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='2279' u='c' c='_ZNK4llvm14DependenceInfo7testMIVEPKNS_4SCEVES3_RKNS_14SmallBitVectorERNS_14FullDependenceE'/>
<def f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='2315' ll='2482' type='bool llvm::DependenceInfo::gcdMIVtest(const llvm::SCEV * Src, const llvm::SCEV * Dst, llvm::FullDependence &amp; Result) const'/>
<doc f='llvm/llvm/lib/Analysis/DependenceAnalysis.cpp' l='2297'>//===----------------------------------------------------------------------===//
// gcdMIVtest -
// Tests an MIV subscript pair for dependence.
// Returns true if any possible dependence is disproved.
// Marks the result as inconsistent.
// Can sometimes disprove the equal direction for 1 or more loops,
// as discussed in Michael Wolfe&apos;s book,
// High Performance Compilers for Parallel Computing, page 235.
//
// We spend some effort (code!) to handle cases like
// [10*i + 5*N*j + 15*M + 6], where i and j are induction variables,
// but M and N are just loop-invariant variables.
// This should help us handle linearized subscripts;
// also makes this test a useful backup to the various SIV tests.
//
// It occurs to me that the presence of loop-invariant variables
// changes the nature of the test from &quot;greatest common divisor&quot;
// to &quot;a common divisor&quot;.</doc>
