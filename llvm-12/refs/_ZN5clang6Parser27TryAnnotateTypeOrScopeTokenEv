<dec f='llvm/clang/include/clang/Parse/Parser.h' l='838' type='bool clang::Parser::TryAnnotateTypeOrScopeToken()'/>
<doc f='llvm/clang/include/clang/Parse/Parser.h' l='836'>// If NeedType is true, then TryAnnotateTypeOrScopeToken will try harder to
  // find a type name by attempting typo correction.</doc>
<use f='llvm/clang/lib/Parse/ParseDecl.cpp' l='3948' u='c' c='_ZN5clang6Parser26ParseDeclarationSpecifiersERNS_8DeclSpecERKNS0_18ParsedTemplateInfoENS_15AccessSpecifierENS0_15DeclSpecContextEPNS0_18LateParsedAttrListE'/>
<use f='llvm/clang/lib/Parse/ParseDecl.cpp' l='4935' u='c' c='_ZN5clang6Parser24isTypeSpecifierQualifierEv'/>
<use f='llvm/clang/lib/Parse/ParseDecl.cpp' l='4946' u='c' c='_ZN5clang6Parser24isTypeSpecifierQualifierEv'/>
<use f='llvm/clang/lib/Parse/ParseDecl.cpp' l='5076' u='c' c='_ZN5clang6Parser22isDeclarationSpecifierEb'/>
<use f='llvm/clang/lib/Parse/ParseDecl.cpp' l='5101' u='c' c='_ZN5clang6Parser22isDeclarationSpecifierEb'/>
<use f='llvm/clang/lib/Parse/ParseDecl.cpp' l='6632' u='c' c='_ZN5clang6Parser34isFunctionDeclaratorIdentifierListEv'/>
<use f='llvm/clang/lib/Parse/ParseExpr.cpp' l='1034' u='c' c='_ZN5clang6Parser19ParseCastExpressionENS0_13CastParseKindEbRbNS0_13TypeCastStateEbPb'/>
<use f='llvm/clang/lib/Parse/ParseExpr.cpp' l='1136' u='c' c='_ZN5clang6Parser19ParseCastExpressionENS0_13CastParseKindEbRbNS0_13TypeCastStateEbPb'/>
<use f='llvm/clang/lib/Parse/ParseExpr.cpp' l='1540' u='c' c='_ZN5clang6Parser19ParseCastExpressionENS0_13CastParseKindEbRbNS0_13TypeCastStateEbPb'/>
<use f='llvm/clang/lib/Parse/ParseExpr.cpp' l='1570' u='c' c='_ZN5clang6Parser19ParseCastExpressionENS0_13CastParseKindEbRbNS0_13TypeCastStateEbPb'/>
<use f='llvm/clang/lib/Parse/ParseExpr.cpp' l='1624' u='c' c='_ZN5clang6Parser19ParseCastExpressionENS0_13CastParseKindEbRbNS0_13TypeCastStateEbPb'/>
<use f='llvm/clang/lib/Parse/ParseObjc.cpp' l='2901' u='c' c='_ZN5clang6Parser26ParseObjCXXMessageReceiverERbRPv'/>
<use f='llvm/clang/lib/Parse/ParseObjc.cpp' l='2996' u='c' c='_ZN5clang6Parser43isStartOfObjCClassMessageMissingOpenBracketEv'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1291' u='c' c='_ZN5clang6Parser25isCXXDeclarationSpecifierENS0_8TPResultEPb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1312' u='c' c='_ZN5clang6Parser25isCXXDeclarationSpecifierENS0_8TPResultEPb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1328' u='c' c='_ZN5clang6Parser25isCXXDeclarationSpecifierENS0_8TPResultEPb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1343' u='c' c='_ZN5clang6Parser25isCXXDeclarationSpecifierENS0_8TPResultEPb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1482' u='c' c='_ZN5clang6Parser25isCXXDeclarationSpecifierENS0_8TPResultEPb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1549' u='c' c='_ZN5clang6Parser25isCXXDeclarationSpecifierENS0_8TPResultEPb'/>
<def f='llvm/clang/lib/Parse/Parser.cpp' l='1837' ll='1947' type='bool clang::Parser::TryAnnotateTypeOrScopeToken()'/>
<use f='llvm/clang/lib/Parse/Parser.cpp' l='1854' u='c' c='_ZN5clang6Parser27TryAnnotateTypeOrScopeTokenEv'/>
<use f='llvm/clang/lib/Parse/Parser.cpp' l='1880' u='c' c='_ZN5clang6Parser27TryAnnotateTypeOrScopeTokenEv'/>
<doc f='llvm/clang/lib/Parse/Parser.cpp' l='1815'>/// TryAnnotateTypeOrScopeToken - If the current token position is on a
/// typename (possibly qualified in C++) or a C++ scope specifier not followed
/// by a typename, TryAnnotateTypeOrScopeToken will replace one or more tokens
/// with a single annotation token representing the typename or C++ scope
/// respectively.
/// This simplifies handling of C++ scope specifiers and allows efficient
/// backtracking without the need to re-parse and resolve nested-names and
/// typenames.
/// It will mainly be called when we expect to treat identifiers as typenames
/// (if they are typenames). For example, in C we do not expect identifiers
/// inside expressions to be treated as typenames so it will not be called
/// for expressions in C.
/// The benefit for C/ObjC is that a typename will be annotated and
/// Actions.getTypeName will not be needed to be called again (e.g. getTypeName
/// will not be called twice, once to check whether we have a declaration
/// specifier, and another one to get the actual type inside
/// ParseDeclarationSpecifiers).
///
/// This returns true if an error occurred.
///
/// Note that this routine emits an error if you call it with ::new or ::delete
/// as the current tokens, so only call it in contexts where these are invalid.</doc>
