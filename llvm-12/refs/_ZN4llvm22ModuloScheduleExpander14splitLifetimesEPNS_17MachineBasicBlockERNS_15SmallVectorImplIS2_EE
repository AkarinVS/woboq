<dec f='llvm/llvm/include/llvm/CodeGen/ModuloSchedule.h' l='206' type='void llvm::ModuloScheduleExpander::splitLifetimes(llvm::MachineBasicBlock * KernelBB, llvm::ModuloScheduleExpander::MBBVectorTy &amp; EpilogBBs)'/>
<use f='llvm/llvm/lib/CodeGen/ModuloSchedule.cpp' l='170' u='c' c='_ZN4llvm22ModuloScheduleExpander21generatePipelinedLoopEv'/>
<def f='llvm/llvm/lib/CodeGen/ModuloSchedule.cpp' l='785' ll='829' type='void llvm::ModuloScheduleExpander::splitLifetimes(llvm::MachineBasicBlock * KernelBB, llvm::ModuloScheduleExpander::MBBVectorTy &amp; EpilogBBs)'/>
<doc f='llvm/llvm/lib/CodeGen/ModuloSchedule.cpp' l='775'>/// For loop carried definitions, we split the lifetime of a virtual register
/// that has uses past the definition in the next iteration. A copy with a new
/// virtual register is inserted before the definition, which helps with
/// generating a better register assignment.
///
///   v1 = phi(a, v2)     v1 = phi(a, v2)
///   v2 = phi(b, v3)     v2 = phi(b, v3)
///   v3 = ..             v4 = copy v1
///   .. = V1             v3 = ..
///                       .. = v4</doc>
