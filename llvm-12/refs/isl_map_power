<dec f='llvm/polly/lib/External/isl/include/isl/map.h' l='687' type='isl_map * isl_map_power(isl_map * map, isl_bool * exact)'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2603' u='c' c='test_closure'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2676' u='c' c='test_closure'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2713' u='c' c='test_closure'/>
<def f='llvm/polly/lib/External/isl/isl_transitive_closure.c' l='2044' ll='2086' type='isl_map * isl_map_power(isl_map * map, isl_bool * exact)'/>
<use f='llvm/polly/lib/External/isl/isl_transitive_closure.c' l='2889' u='c' c='power'/>
<doc f='llvm/polly/lib/External/isl/isl_transitive_closure.c' l='2035'>/* Compute the positive powers of &quot;map&quot;, or an overapproximation.
 * The result maps the exponent to a nested copy of the corresponding power.
 * If the result is exact, then *exact is set to 1.
 * map_power constructs an extended relation with the path lengths
 * encoded as the difference between the final coordinates.
 * In the final step, this difference is equated to an extra parameter
 * and made positive.  The extra coordinates are subsequently projected out
 * and the parameter is turned into the domain of the result.
 */</doc>
