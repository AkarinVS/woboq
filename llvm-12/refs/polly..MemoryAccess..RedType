<dec f='llvm/polly/include/polly/ScopInfo.h' l='507' type='polly::MemoryAccess::ReductionType'/>
<use f='llvm/polly/include/polly/ScopInfo.h' l='753' u='r' c='_ZNK5polly12MemoryAccess15isReductionLikeEv'/>
<use f='llvm/polly/include/polly/ScopInfo.h' l='1034' u='r' c='_ZNK5polly12MemoryAccess16getReductionTypeEv'/>
<use f='llvm/polly/include/polly/ScopInfo.h' l='1057' u='w' c='_ZN5polly12MemoryAccess19markAsReductionLikeENS0_13ReductionTypeE'/>
<offset>128</offset>
<doc f='llvm/polly/include/polly/ScopInfo.h' l='483'>/// Reduction type for reduction like accesses, RT_NONE otherwise
  ///
  /// An access is reduction like if it is part of a load-store chain in which
  /// both access the same memory location (use the same LLVM-IR value
  /// as pointer reference). Furthermore, between the load and the store there
  /// is exactly one binary operator which is known to be associative and
  /// commutative.
  ///
  /// TODO:
  ///
  /// We can later lift the constraint that the same LLVM-IR value defines the
  /// memory location to handle scops such as the following:
  ///
  ///    for i
  ///      for j
  ///        sum[i+j] = sum[i] + 3;
  ///
  /// Here not all iterations access the same memory location, but iterations
  /// for which j = 0 holds do. After lifting the equality check in ScopBuilder,
  /// subsequent transformations do not only need check if a statement is
  /// reduction like, but they also need to verify that that the reduction
  /// property is only exploited for statement instances that load from and
  /// store to the same data location. Doing so at dependence analysis time
  /// could allow us to handle the above example.</doc>
