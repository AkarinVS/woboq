<use f='llvm/clang/include/clang/Parse/Parser.h' l='2390' u='c' c='_ZN5clang6Parser31isKnownToBeDeclarationSpecifierEv'/>
<dec f='llvm/clang/include/clang/Parse/Parser.h' l='2525' type='clang::Parser::TPResult clang::Parser::isCXXDeclarationSpecifier(clang::Parser::TPResult BracedCastResult = TPResult::False, bool * InvalidAsDeclSpec = nullptr)'/>
<doc f='llvm/clang/include/clang/Parse/Parser.h' l='2517'>/// isCXXDeclarationSpecifier - Returns TPResult::True if it is a
  /// declaration specifier, TPResult::False if it is not,
  /// TPResult::Ambiguous if it could be either a decl-specifier or a
  /// function-style cast, and TPResult::Error if a parsing error was
  /// encountered. If it could be a braced C++11 function-style cast, returns
  /// BracedCastResult.
  /// Doesn&apos;t consume tokens.</doc>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='114' u='c' c='_ZN5clang6Parser22isCXXSimpleDeclarationEb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='234' u='c' c='_ZN5clang6Parser25TryParseSimpleDeclarationEb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='443' u='c' c='_ZN5clang6Parser10isEnumBaseEb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='457' u='c' c='_ZN5clang6Parser10isEnumBaseEb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='486' u='c' c='_ZN5clang6Parser40isCXXConditionDeclarationOrInitStatementEbb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='572' u='c' c='_ZN5clang6Parser11isCXXTypeIdENS0_25TentativeCXXTypeIdContextERb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='933' u='c' c='_ZN5clang6Parser18TryParseOperatorIdEv'/>
<def f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1247' ll='1713' type='Parser::TPResult clang::Parser::isCXXDeclarationSpecifier(Parser::TPResult BracedCastResult = TPResult::False, bool * InvalidAsDeclSpec = nullptr)'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1322' u='c' c='_ZN5clang6Parser25isCXXDeclarationSpecifierENS0_8TPResultEPb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1330' u='c' c='_ZN5clang6Parser25isCXXDeclarationSpecifierENS0_8TPResultEPb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1345' u='c' c='_ZN5clang6Parser25isCXXDeclarationSpecifierENS0_8TPResultEPb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1513' u='c' c='_ZN5clang6Parser25isCXXDeclarationSpecifierENS0_8TPResultEPb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1570' u='c' c='_ZN5clang6Parser25isCXXDeclarationSpecifierENS0_8TPResultEPb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1918' u='c' c='_ZN5clang6Parser34TryParseParameterDeclarationClauseEPbb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1936' u='c' c='_ZN5clang6Parser34TryParseParameterDeclarationClauseEPbb'/>
<use f='llvm/clang/lib/Parse/ParseTentative.cpp' l='2098' u='c' c='_ZN5clang6Parser22isTemplateArgumentListEj'/>
<doc f='llvm/clang/lib/Parse/ParseTentative.cpp' l='1135'>/// isCXXDeclarationSpecifier - Returns TPResult::True if it is a declaration
/// specifier, TPResult::False if it is not, TPResult::Ambiguous if it could
/// be either a decl-specifier or a function-style cast, and TPResult::Error
/// if a parsing error was found and reported.
///
/// If InvalidAsDeclSpec is not null, some cases that would be ill-formed as
/// declaration specifiers but possibly valid as some other kind of construct
/// return TPResult::Ambiguous instead of TPResult::False. When this happens,
/// the intent is to keep trying to disambiguate, on the basis that we might
/// find a better reason to treat this construct as a declaration later on.
/// When this happens and the name could possibly be valid in some other
/// syntactic context, *InvalidAsDeclSpec is set to &apos;true&apos;. The current cases
/// that trigger this are:
///
///   * When parsing X::Y (with no &apos;typename&apos;) where X is dependent
///   * When parsing X&lt;Y&gt; where X is undeclared
///
///         decl-specifier:
///           storage-class-specifier
///           type-specifier
///           function-specifier
///           &apos;friend&apos;
///           &apos;typedef&apos;
/// [C++11]   &apos;constexpr&apos;
/// [C++20]   &apos;consteval&apos;
/// [GNU]     attributes declaration-specifiers[opt]
///
///         storage-class-specifier:
///           &apos;register&apos;
///           &apos;static&apos;
///           &apos;extern&apos;
///           &apos;mutable&apos;
///           &apos;auto&apos;
/// [GNU]     &apos;__thread&apos;
/// [C++11]   &apos;thread_local&apos;
/// [C11]     &apos;_Thread_local&apos;
///
///         function-specifier:
///           &apos;inline&apos;
///           &apos;virtual&apos;
///           &apos;explicit&apos;
///
///         typedef-name:
///           identifier
///
///         type-specifier:
///           simple-type-specifier
///           class-specifier
///           enum-specifier
///           elaborated-type-specifier
///           typename-specifier
///           cv-qualifier
///
///         simple-type-specifier:
///           &apos;::&apos;[opt] nested-name-specifier[opt] type-name
///           &apos;::&apos;[opt] nested-name-specifier &apos;template&apos;
///                 simple-template-id                              [TODO]
///           &apos;char&apos;
///           &apos;wchar_t&apos;
///           &apos;bool&apos;
///           &apos;short&apos;
///           &apos;int&apos;
///           &apos;long&apos;
///           &apos;signed&apos;
///           &apos;unsigned&apos;
///           &apos;float&apos;
///           &apos;double&apos;
///           &apos;void&apos;
/// [GNU]     typeof-specifier
/// [GNU]     &apos;_Complex&apos;
/// [C++11]   &apos;auto&apos;
/// [GNU]     &apos;__auto_type&apos;
/// [C++11]   &apos;decltype&apos; ( expression )
/// [C++1y]   &apos;decltype&apos; ( &apos;auto&apos; )
///
///         type-name:
///           class-name
///           enum-name
///           typedef-name
///
///         elaborated-type-specifier:
///           class-key &apos;::&apos;[opt] nested-name-specifier[opt] identifier
///           class-key &apos;::&apos;[opt] nested-name-specifier[opt] &apos;template&apos;[opt]
///               simple-template-id
///           &apos;enum&apos; &apos;::&apos;[opt] nested-name-specifier[opt] identifier
///
///         enum-name:
///           identifier
///
///         enum-specifier:
///           &apos;enum&apos; identifier[opt] &apos;{&apos; enumerator-list[opt] &apos;}&apos;
///           &apos;enum&apos; identifier[opt] &apos;{&apos; enumerator-list &apos;,&apos; &apos;}&apos;
///
///         class-specifier:
///           class-head &apos;{&apos; member-specification[opt] &apos;}&apos;
///
///         class-head:
///           class-key identifier[opt] base-clause[opt]
///           class-key nested-name-specifier identifier base-clause[opt]
///           class-key nested-name-specifier[opt] simple-template-id
///               base-clause[opt]
///
///         class-key:
///           &apos;class&apos;
///           &apos;struct&apos;
///           &apos;union&apos;
///
///         cv-qualifier:
///           &apos;const&apos;
///           &apos;volatile&apos;
/// [GNU]     restrict
///</doc>
