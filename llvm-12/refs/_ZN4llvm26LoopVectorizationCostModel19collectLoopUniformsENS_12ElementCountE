<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1468' u='c' c='_ZN4llvm26LoopVectorizationCostModel25collectUniformsAndScalarsENS_12ElementCountE'/>
<dec f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1762' type='void llvm::LoopVectorizationCostModel::collectLoopUniforms(llvm::ElementCount VF)'/>
<def f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='5260' ll='5443' type='void llvm::LoopVectorizationCostModel::collectLoopUniforms(llvm::ElementCount VF)'/>
<doc f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='1753'>/// Collect the instructions that are uniform after vectorization. An
  /// instruction is uniform if we represent it with a single scalar value in
  /// the vectorized loop corresponding to each vector iteration. Examples of
  /// uniform instructions include pointer operands of consecutive or
  /// interleaved memory accesses. Note that although uniformity implies an
  /// instruction will be scalar, the reverse is not true. In general, a
  /// scalarized instruction will be represented by VF scalar values in the
  /// vectorized loop, each corresponding to an iteration of the original
  /// scalar loop.</doc>
