<inh f='llvm/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h' l='188' c='llvm::mca::LSUnitBase'/>
<def f='llvm/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h' l='396' ll='470'/>
<use f='llvm/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h' l='442' c='_ZN4llvm3mca6LSUnitC1ERKNS_12MCSchedModelE'/>
<use f='llvm/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h' l='444' c='_ZN4llvm3mca6LSUnitC1ERKNS_12MCSchedModelEjj'/>
<use f='llvm/llvm/lib/MCA/Context.cpp' l='37' c='_ZN4llvm3mca7Context21createDefaultPipelineERKNS0_15PipelineOptionsERNS0_9SourceMgrE'/>
<size>80</size>
<doc f='llvm/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h' l='335'>/// Default Load/Store Unit (LS Unit) for simulated processors.
///
/// Each load (or store) consumes one entry in the load (or store) queue.
///
/// Rules are:
/// 1) A younger load is allowed to pass an older load only if there are no
///    stores nor barriers in between the two loads.
/// 2) An younger store is not allowed to pass an older store.
/// 3) A younger store is not allowed to pass an older load.
/// 4) A younger load is allowed to pass an older store only if the load does
///    not alias with the store.
///
/// This class optimistically assumes that loads don&apos;t alias store operations.
/// Under this assumption, younger loads are always allowed to pass older
/// stores (this would only affects rule 4).
/// Essentially, this class doesn&apos;t perform any sort alias analysis to
/// identify aliasing loads and stores.
///
/// To enforce aliasing between loads and stores, flag `AssumeNoAlias` must be
/// set to `false` by the constructor of LSUnit.
///
/// Note that this class doesn&apos;t know about the existence of different memory
/// types for memory operations (example: write-through, write-combining, etc.).
/// Derived classes are responsible for implementing that extra knowledge, and
/// provide different sets of rules for loads and stores by overriding method
/// `isReady()`.
/// To emulate a write-combining memory type, rule 2. must be relaxed in a
/// derived class to enable the reordering of non-aliasing store operations.
///
/// No assumptions are made by this class on the size of the store buffer.  This
/// class doesn&apos;t know how to identify cases where store-to-load forwarding may
/// occur.
///
/// LSUnit doesn&apos;t attempt to predict whether a load or store hits or misses
/// the L1 cache. To be more specific, LSUnit doesn&apos;t know anything about
/// cache hierarchy and memory types.
/// It only knows if an instruction &quot;mayLoad&quot; and/or &quot;mayStore&quot;. For loads, the
/// scheduling model provides an &quot;optimistic&quot; load-to-use latency (which usually
/// matches the load-to-use latency for when there is a hit in the L1D).
/// Derived classes may expand this knowledge.
///
/// Class MCInstrDesc in LLVM doesn&apos;t know about serializing operations, nor
/// memory-barrier like instructions.
/// LSUnit conservatively assumes that an instruction which `mayLoad` and has
/// `unmodeled side effects` behave like a &quot;soft&quot; load-barrier. That means, it
/// serializes loads without forcing a flush of the load queue.
/// Similarly, instructions that both `mayStore` and have `unmodeled side
/// effects` are treated like store barriers. A full memory
/// barrier is a &apos;mayLoad&apos; and &apos;mayStore&apos; instruction with unmodeled side
/// effects. This is obviously inaccurate, but this is the best that we can do
/// at the moment.
///
/// Each load/store barrier consumes one entry in the load/store queue. A
/// load/store barrier enforces ordering of loads/stores:
///  - A younger load cannot pass a load barrier.
///  - A younger store cannot pass a store barrier.
///
/// A younger load has to wait for the memory load barrier to execute.
/// A load/store barrier is &quot;executed&quot; when it becomes the oldest entry in
/// the load/store queue(s). That also means, all the older loads/stores have
/// already been executed.</doc>
<mbr r='llvm::mca::LSUnit::CurrentLoadGroupID' o='480' t='unsigned int'/>
<mbr r='llvm::mca::LSUnit::CurrentLoadBarrierGroupID' o='512' t='unsigned int'/>
<mbr r='llvm::mca::LSUnit::CurrentStoreGroupID' o='544' t='unsigned int'/>
<mbr r='llvm::mca::LSUnit::CurrentStoreBarrierGroupID' o='576' t='unsigned int'/>
<fun r='_ZN4llvm3mca6LSUnitC1ERKNS_12MCSchedModelE'/>
<fun r='_ZN4llvm3mca6LSUnitC1ERKNS_12MCSchedModelEjj'/>
<fun r='_ZN4llvm3mca6LSUnitC1ERKNS_12MCSchedModelEjjb'/>
<fun r='_ZNK4llvm3mca6LSUnit11isAvailableERKNS0_7InstRefE'/>
<fun r='_ZN4llvm3mca6LSUnit8dispatchERKNS0_7InstRefE'/>
<fun r='_ZN4llvm3mca6LSUnit21onInstructionExecutedERKNS0_7InstRefE'/>
