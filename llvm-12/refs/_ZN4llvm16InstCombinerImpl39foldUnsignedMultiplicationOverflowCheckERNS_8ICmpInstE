<dec f='llvm/llvm/lib/Transforms/InstCombine/InstCombineInternal.h' l='658' type='llvm::Value * llvm::InstCombinerImpl::foldUnsignedMultiplicationOverflowCheck(llvm::ICmpInst &amp; Cmp)'/>
<def f='llvm/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp' l='3654' ll='3714' type='llvm::Value * llvm::InstCombinerImpl::foldUnsignedMultiplicationOverflowCheck(llvm::ICmpInst &amp; I)'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp' l='4099' u='c' c='_ZN4llvm16InstCombinerImpl13foldICmpBinOpERNS_8ICmpInstERKNS_13SimplifyQueryE'/>
<doc f='llvm/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp' l='3647'>/// Fold
///   (-1 u/ x) u&lt; y
///   ((x * y) u/ x) != y
/// to
///   @llvm.umul.with.overflow(x, y) plus extraction of overflow bit
/// Note that the comparison is commutative, while inverted (u&gt;=, ==) predicate
/// will mean that we are looking for the opposite answer.</doc>
