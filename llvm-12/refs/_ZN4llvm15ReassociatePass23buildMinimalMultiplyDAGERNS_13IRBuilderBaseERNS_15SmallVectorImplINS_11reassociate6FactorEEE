<dec f='llvm/llvm/include/llvm/Transforms/Scalar/Reassociate.h' l='117' type='llvm::Value * llvm::ReassociatePass::buildMinimalMultiplyDAG(llvm::IRBuilderBase &amp; Builder, SmallVectorImpl&lt;reassociate::Factor&gt; &amp; Factors)'/>
<def f='llvm/llvm/lib/Transforms/Scalar/Reassociate.cpp' l='1843' ll='1899' type='llvm::Value * llvm::ReassociatePass::buildMinimalMultiplyDAG(llvm::IRBuilderBase &amp; Builder, SmallVectorImpl&lt;llvm::reassociate::Factor&gt; &amp; Factors)'/>
<use f='llvm/llvm/lib/Transforms/Scalar/Reassociate.cpp' l='1890' u='c' c='_ZN4llvm15ReassociatePass23buildMinimalMultiplyDAGERNS_13IRBuilderBaseERNS_15SmallVectorImplINS_11reassociate6FactorEEE'/>
<use f='llvm/llvm/lib/Transforms/Scalar/Reassociate.cpp' l='1922' u='c' c='_ZN4llvm15ReassociatePass11OptimizeMulEPNS_14BinaryOperatorERNS_15SmallVectorImplINS_11reassociate10ValueEntryEEE'/>
<doc f='llvm/llvm/lib/Transforms/Scalar/Reassociate.cpp' l='1837'>/// Build a minimal multiplication DAG for (a^x)*(b^y)*(c^z)*...
///
/// Given a vector of values raised to various powers, where no two values are
/// equal and the powers are sorted in decreasing order, compute the minimal
/// DAG of multiplies to compute the final product, and return that product
/// value.</doc>
