<def f='llvm/polly/lib/External/isl/isl_tab_lexopt_templ.c' l='49' ll='138' type='isl_map * basic_map_partial_lexopt_symm(isl_basic_map * bmap, isl_basic_map * dom, isl_map ** empty, int max, int first, int second)'/>
<use f='llvm/polly/lib/External/isl/isl_tab_lexopt_templ.c' l='167' u='c' c='basic_map_partial_lexopt'/>
<doc f='llvm/polly/lib/External/isl/isl_tab_lexopt_templ.c' l='17'>/* Given a basic map with at least two parallel constraints (as found
 * by the function parallel_constraints), first look for more constraints
 * parallel to the two constraint and replace the found list of parallel
 * constraints by a single constraint with as &quot;input&quot; part the minimum
 * of the input parts of the list of constraints.  Then, recursively call
 * basic_map_partial_lexopt (possibly finding more parallel constraints)
 * and plug in the definition of the minimum in the result.
 *
 * As in parallel_constraints, only inequality constraints that only
 * involve input variables that do not occur in any other inequality
 * constraints are considered.
 *
 * More specifically, given a set of constraints
 *
 *	a x + b_i(p) &gt;= 0
 *
 * Replace this set by a single constraint
 *
 *	a x + u &gt;= 0
 *
 * with u a new parameter with constraints
 *
 *	u &lt;= b_i(p)
 *
 * Any solution to the new system is also a solution for the original system
 * since
 *
 *	a x &gt;= -u &gt;= -b_i(p)
 *
 * Moreover, m = min_i(b_i(p)) satisfies the constraints on u and can
 * therefore be plugged into the solution.
 */</doc>
