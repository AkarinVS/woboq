<def f='llvm/polly/lib/External/isl/isl_pw_union_opt.c' l='181' macro='1' type='isl_stat isl_pw_aff_union_opt_cmp_two(struct isl_pw_aff_union_opt_cmp_data * data_i, int i, struct isl_pw_aff_union_opt_cmp_data * data_j, int j, isl_map *(*)(isl_aff *, isl_aff *) cmp)'/>
<use f='llvm/polly/lib/External/isl/isl_pw_union_opt.c' l='344' macro='1' u='c' c='isl_pw_aff_union_opt_cmp'/>
<doc f='llvm/polly/lib/External/isl/isl_pw_union_opt.c' l='158'>/* Given (potentially) updated cells &quot;i&quot; of data_i-&gt;pw and &quot;j&quot; of data_j-&gt;pw and
 * a function &quot;cmp&quot; that returns the set of elements where
 * &quot;el1&quot; is &quot;better&quot; than &quot;el2&quot;,
 * (further) update the specified cells such that only the &quot;better&quot; elements
 * remain on the (non-empty) intersection.
 *
 * The base computation is performed by isl_pw_*_union_opt_cmp_pair,
 * which splits the cells according to the set of elements
 * where the piece from data_j-&gt;pw is better than the piece from data_i-&gt;pw.
 *
 * In some cases, there may be a subset of the intersection
 * where both pieces have the same value and can therefore
 * both be considered to be &quot;better&quot; than the other.
 * This can result in unnecessary splitting on this subset.
 * Avoid some of these cases by checking whether
 * data_i-&gt;pw is always better than data_j-&gt;pw on the intersection.
 * In particular, do this for the special case where this intersection
 * is equal to the cell &quot;j&quot; and data_i-&gt;pw is better on its entire cell.
 *
 * Similarly, if data_i-&gt;pw is never better than data_j-&gt;pw,
 * then no splitting will occur and there is no need to check
 * where data_j-&gt;pw is better than data_i-&gt;pw.
 */</doc>
