<dec f='llvm/llvm/include/llvm/Analysis/LoopAccessAnalysis.h' l='698' type='bool llvm::isConsecutiveAccess(llvm::Value * A, llvm::Value * B, const llvm::DataLayout &amp; DL, llvm::ScalarEvolution &amp; SE, bool CheckType = true)'/>
<doc f='llvm/llvm/include/llvm/Analysis/LoopAccessAnalysis.h' l='696'>/// Returns true if the memory operations \p A and \p B are consecutive.
/// This is a simple API that does not depend on the analysis pass.</doc>
<def f='llvm/llvm/lib/Analysis/LoopAccessAnalysis.cpp' l='1198' ll='1260' type='bool llvm::isConsecutiveAccess(llvm::Value * A, llvm::Value * B, const llvm::DataLayout &amp; DL, llvm::ScalarEvolution &amp; SE, bool CheckType = true)'/>
<doc f='llvm/llvm/lib/Analysis/LoopAccessAnalysis.cpp' l='1197'>/// Returns true if the memory operations \p A and \p B are consecutive.</doc>
<use f='llvm/llvm/lib/Transforms/Scalar/LoopIdiomRecognize.cpp' l='720' u='c' c='_ZN12_GLOBAL__N_118LoopIdiomRecognize17processLoopStoresERN4llvm15SmallVectorImplIPNS1_9StoreInstEEEPKNS1_4SCEVENS0_9ForMemsetE'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp' l='941' u='c' c='_ZN4llvm13slpvectorizer7BoUpSLP10VLOperands15getShallowScoreEPNS_5ValueES4_RKNS_10DataLayoutERNS_15ScalarEvolutionE'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp' l='6032' u='c' c='_ZN4llvm17SLPVectorizerPass15vectorizeStoresENS_8ArrayRefIPNS_9StoreInstEEERNS_13slpvectorizer7BoUpSLPE'/>
