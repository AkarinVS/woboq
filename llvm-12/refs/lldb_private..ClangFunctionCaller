<inh f='llvm/lldb/include/lldb/Expression/FunctionCaller.h' l='56' c='lldb_private::FunctionCaller'/>
<def f='llvm/lldb/source/Plugins/ExpressionParser/Clang/ClangFunctionCaller.h' l='58' ll='148'/>
<use f='llvm/lldb/source/Plugins/ExpressionParser/Clang/ClangFunctionCaller.h' l='63' c='_ZN12lldb_private19ClangFunctionCaller25ClangFunctionCallerHelperC1ERS0_'/>
<use f='llvm/lldb/source/Plugins/ExpressionParser/Clang/ClangFunctionCaller.h' l='81'/>
<use f='llvm/lldb/source/Plugins/ExpressionParser/Clang/ASTStructExtractor.h' l='52' c='_ZN12lldb_private18ASTStructExtractorC1EPN5clang11ASTConsumerEPKcRNS_19ClangFunctionCallerE'/>
<use f='llvm/lldb/source/Plugins/ExpressionParser/Clang/ASTStructExtractor.h' l='124'/>
<use f='llvm/lldb/source/Plugins/ExpressionParser/Clang/ASTStructExtractor.cpp' l='31' c='_ZN12lldb_private18ASTStructExtractorC1EPN5clang11ASTConsumerEPKcRNS_19ClangFunctionCallerE'/>
<size>416</size>
<doc f='llvm/lldb/source/Plugins/ExpressionParser/Clang/ClangFunctionCaller.h' l='26'>/// \class ClangFunctionCaller ClangFunctionCaller.h
/// &quot;lldb/Expression/ClangFunctionCaller.h&quot; Encapsulates a function that can
/// be called.
///
/// A given ClangFunctionCaller object can handle a single function signature.
/// Once constructed, it can set up any number of concurrent calls to
/// functions with that signature.
///
/// It performs the call by synthesizing a structure that contains the pointer
/// to the function and the arguments that should be passed to that function,
/// and producing a special-purpose JIT-compiled function that accepts a void*
/// pointing to this struct as its only argument and calls the function in the
/// struct with the written arguments.  This method lets Clang handle the
/// vagaries of function calling conventions.
///
/// The simplest use of the ClangFunctionCaller is to construct it with a
/// function representative of the signature you want to use, then call
/// ExecuteFunction(ExecutionContext &amp;, Stream &amp;, Value &amp;).
///
/// If you need to reuse the arguments for several calls, you can call
/// InsertFunction() followed by WriteFunctionArguments(), which will return
/// the location of the args struct for the wrapper function in args_addr_ref.
///
/// If you need to call the function on the thread plan stack, you can also
/// call InsertFunction() followed by GetThreadPlanToCallFunction().
///
/// Any of the methods that take arg_addr_ptr or arg_addr_ref can be passed a
/// pointer set to LLDB_INVALID_ADDRESS and new structure will be allocated
/// and its address returned in that variable.
///
/// Any of the methods that take arg_addr_ptr can be passed NULL, and the
/// argument space will be managed for you.</doc>
<smbr r='lldb_private::ClangFunctionCaller::ID' t='char'/>
<fun r='_ZNK12lldb_private19ClangFunctionCaller3isAEPKv'/>
<fun r='_ZN12lldb_private19ClangFunctionCaller7classofEPKNS_10ExpressionE'/>
<fun r='_ZN12lldb_private19ClangFunctionCallerC1ERNS_21ExecutionContextScopeERKNS_12CompilerTypeERKNS_7AddressERKNS_9ValueListEPKc'/>
<fun r='_ZN12lldb_private19ClangFunctionCallerD1Ev'/>
<fun r='_ZN12lldb_private19ClangFunctionCaller15CompileFunctionESt10shared_ptrINS_6ThreadEERNS_17DiagnosticManagerE'/>
<fun r='_ZN12lldb_private19ClangFunctionCaller19GetTypeSystemHelperEv'/>
<fun r='_ZN12lldb_private19ClangFunctionCaller20GetWrapperStructNameEv'/>
<mbr r='lldb_private::ClangFunctionCaller::m_type_system_helper' o='3072' t='lldb_private::ClangFunctionCaller::ClangFunctionCallerHelper'/>
<use f='llvm/lldb/source/Plugins/TypeSystem/Clang/TypeSystemClang.cpp' l='9640' c='_ZN12lldb_private22ScratchTypeSystemClang17GetFunctionCallerERKNS_12CompilerTypeERKNS_7AddressERKNS_9ValueListEPKc'/>
<size>416</size>
