<dec f='llvm/lldb/include/lldb/Breakpoint/BreakpointOptions.h' l='186' type='void lldb_private::BreakpointOptions::SetCallback(lldb_private::BreakpointHitCallback callback, const lldb::BatonSP &amp; baton_sp, bool synchronous = false)'/>
<doc f='llvm/lldb/include/lldb/Breakpoint/BreakpointOptions.h' l='143'>// Callbacks
  //
  // Breakpoint callbacks come in two forms, synchronous and asynchronous.
  // Synchronous callbacks will get run before any of the thread plans are
  // consulted, and if they return false the target will continue &quot;under the
  // radar&quot; of the thread plans.  There are a couple of restrictions to
  // synchronous callbacks:
  // 1) They should NOT resume the target themselves.
  //     Just return false if you want the target to restart.
  // 2) Breakpoints with synchronous callbacks can&apos;t have conditions
  //    (or rather, they can have them, but they won&apos;t do anything.
  //    Ditto with ignore counts, etc...  You are supposed to control that all
  //    through the callback.
  // Asynchronous callbacks get run as part of the &quot;ShouldStop&quot; logic in the
  // thread plan.  The logic there is:
  //   a) If the breakpoint is thread specific and not for this thread, continue
  //   w/o running the callback.
  //      NB. This is actually enforced underneath the breakpoint system, the
  //      Process plugin is expected to
  //      call BreakpointSite::IsValidForThread, and set the thread&apos;s StopInfo
  //      to &quot;no reason&quot;.  That way,
  //      thread displays won&apos;t show stops for breakpoints not for that
  //      thread...
  //   b) If the ignore count says we shouldn&apos;t stop, then ditto.
  //   c) If the condition says we shouldn&apos;t stop, then ditto.
  //   d) Otherwise, the callback will get run, and if it returns true we will
  //      stop, and if false we won&apos;t.
  //  The asynchronous callback can run the target itself, but at present that
  //  should be the last action the callback does.  We will relax this condition
  //  at some point, but it will take a bit of plumbing to get that to work.
  //

  /// Adds a callback to the breakpoint option set.
  ///
  /// \param[in] callback
  ///    The function to be called when the breakpoint gets hit.
  ///
  /// \param[in] baton_sp
  ///    A baton which will get passed back to the callback when it is invoked.
  ///
  /// \param[in] synchronous
  ///    Whether this is a synchronous or asynchronous callback.  See discussion
  ///    above.</doc>
<use f='llvm/lldb/source/API/SBBreakpointName.cpp' l='563' u='c' c='_ZN4lldb16SBBreakpointName11SetCallbackEPFbPvRNS_9SBProcessERNS_8SBThreadERNS_20SBBreakpointLocationEES1_'/>
<use f='llvm/lldb/source/Breakpoint/Breakpoint.cpp' l='433' u='c' c='_ZN12lldb_private10Breakpoint11SetCallbackEPFbPvPNS_24StoppointCallbackContextEmmES1_b'/>
<use f='llvm/lldb/source/Breakpoint/Breakpoint.cpp' l='444' u='c' c='_ZN12lldb_private10Breakpoint11SetCallbackEPFbPvPNS_24StoppointCallbackContextEmmERKSt10shared_ptrINS_5BatonEEb'/>
<use f='llvm/lldb/source/Breakpoint/BreakpointLocation.cpp' l='202' u='c' c='_ZN12lldb_private18BreakpointLocation11SetCallbackEPFbPvPNS_24StoppointCallbackContextEmmES1_b'/>
<use f='llvm/lldb/source/Breakpoint/BreakpointLocation.cpp' l='210' u='c' c='_ZN12lldb_private18BreakpointLocation11SetCallbackEPFbPvPNS_24StoppointCallbackContextEmmERKSt10shared_ptrINS_5BatonEEb'/>
<def f='llvm/lldb/source/Breakpoint/BreakpointOptions.cpp' l='402' ll='420' type='void lldb_private::BreakpointOptions::SetCallback(lldb_private::BreakpointHitCallback callback, const lldb::BatonSP &amp; callback_baton_sp, bool callback_is_synchronous = false)'/>
<doc f='llvm/lldb/source/Breakpoint/BreakpointOptions.cpp' l='401'>// Callbacks</doc>
