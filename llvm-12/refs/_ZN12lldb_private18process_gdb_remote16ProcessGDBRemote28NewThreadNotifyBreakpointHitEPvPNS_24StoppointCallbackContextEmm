<dec f='llvm/lldb/source/Plugins/Process/gdb-remote/ProcessGDBRemote.h' l='419' type='static bool lldb_private::process_gdb_remote::ProcessGDBRemote::NewThreadNotifyBreakpointHit(void * baton, lldb_private::StoppointCallbackContext * context, lldb::user_id_t break_id, lldb::user_id_t break_loc_id)'/>
<def f='llvm/lldb/source/Plugins/Process/gdb-remote/ProcessGDBRemote.cpp' l='3877' ll='3886' type='static bool lldb_private::process_gdb_remote::ProcessGDBRemote::NewThreadNotifyBreakpointHit(void * baton, lldb_private::StoppointCallbackContext * context, lldb::user_id_t break_id, lldb::user_id_t break_loc_id)'/>
<use f='llvm/lldb/source/Plugins/Process/gdb-remote/ProcessGDBRemote.cpp' l='3942' u='r' c='_ZN12lldb_private18process_gdb_remote16ProcessGDBRemote23StartNoticingNewThreadsEv'/>
<doc f='llvm/lldb/source/Plugins/Process/gdb-remote/ProcessGDBRemote.cpp' l='3857'>// uint32_t
// ProcessGDBRemote::ListProcessesMatchingName (const char *name, StringList
// &amp;matches, std::vector&lt;lldb::pid_t&gt; &amp;pids)
//{
//    // If we are planning to launch the debugserver remotely, then we need to
//    fire up a debugserver
//    // process and ask it for the list of processes. But if we are local, we
//    can let the Host do it.
//    if (m_local_debugserver)
//    {
//        return Host::ListProcessesMatchingName (name, matches, pids);
//    }
//    else
//    {
//        // FIXME: Implement talking to the remote debugserver.
//        return 0;
//    }
//
//}
//</doc>
