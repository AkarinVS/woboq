<dec f='llvm/llvm/include/llvm/Analysis/ScalarEvolution.h' l='551' type='const llvm::SCEV * llvm::ScalarEvolution::getUDivExactExpr(const llvm::SCEV * LHS, const llvm::SCEV * RHS)'/>
<use f='llvm/llvm/lib/Analysis/LoopCacheAnalysis.cpp' l='377' u='c' c='_ZN4llvm16IndexedReference11delinearizeERKNS_8LoopInfoE'/>
<def f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='3262' ll='3312' type='const llvm::SCEV * llvm::ScalarEvolution::getUDivExactExpr(const llvm::SCEV * LHS, const llvm::SCEV * RHS)'/>
<use f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='3297' u='c' c='_ZN4llvm15ScalarEvolution16getUDivExactExprEPKNS_4SCEVES3_'/>
<use f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='6656' u='c' c='_ZN4llvm15ScalarEvolution10createSCEVEPNS_5ValueE'/>
<use f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='8760' u='c' c='_ZL28SolveLinEquationWithOverflowRKN4llvm5APIntEPKNS_4SCEVERNS_15ScalarEvolutionE'/>
<doc f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='3258'>/// Get a canonical unsigned division expression, or something simpler if
/// possible. There is no representation for an exact udiv in SCEV IR, but we
/// can attempt to remove factors from the LHS and RHS.  We can&apos;t do this when
/// it&apos;s not exact because the udiv may be clearing bits.</doc>
