<dec f='llvm/polly/lib/External/isl/include/isl/polynomial.h' l='523' type='isl_pw_qpolynomial * isl_pw_qpolynomial_to_polynomial(isl_pw_qpolynomial * pwqp, int sign)'/>
<use f='llvm/polly/lib/External/isl/include/isl/isl-noexceptions.h' l='13108' u='c' c='_ZNK3isl12noexceptions14pw_qpolynomial13to_polynomialEi'/>
<def f='llvm/polly/lib/External/isl/isl_polynomial.c' l='5094' ll='5131' type='isl_pw_qpolynomial * isl_pw_qpolynomial_to_polynomial(isl_pw_qpolynomial * pwqp, int sign)'/>
<use f='llvm/polly/lib/External/isl/isl_polynomial.c' l='5138' u='c' c='poly_entry'/>
<doc f='llvm/polly/lib/External/isl/isl_polynomial.c' l='5082'>/* Approximate each quasipolynomial by a polynomial.  If &quot;sign&quot; is positive,
 * the polynomial will be an overapproximation.  If &quot;sign&quot; is negative,
 * it will be an underapproximation.  If &quot;sign&quot; is zero, the approximation
 * will lie somewhere in between.
 *
 * In particular, is sign == 0, we simply drop the floors, turning
 * the integer divisions into rational divisions.
 * Otherwise, we split the domains into orthants, make all integer divisions
 * positive and then approximate each [a/m] by either a/m or (a-(m-1))/m,
 * depending on the requested sign and the sign of the term in which
 * the integer division appears.
 */</doc>
