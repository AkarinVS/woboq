<dec f='llvm/polly/lib/External/isl/include/isl/flow.h' l='144' type='int isl_union_map_compute_flow(isl_union_map * sink, isl_union_map * must_source, isl_union_map * may_source, isl_union_map * schedule, isl_union_map ** must_dep, isl_union_map ** may_dep, isl_union_map ** must_no_source, isl_union_map ** may_no_source)'/>
<def f='llvm/polly/lib/External/isl/isl_flow.c' l='3296' ll='3340' type='int isl_union_map_compute_flow(isl_union_map * sink, isl_union_map * must_source, isl_union_map * may_source, isl_union_map * schedule, isl_union_map ** must_dep, isl_union_map ** may_dep, isl_union_map ** must_no_source, isl_union_map ** may_no_source)'/>
<doc f='llvm/polly/lib/External/isl/isl_flow.c' l='3280'>/* Given a collection of &quot;sink&quot; and &quot;source&quot; accesses,
 * compute for each iteration of a sink access
 * and for each element accessed by that iteration,
 * the source access in the list that last accessed the
 * element accessed by the sink access before this sink access.
 * Each access is given as a map from the loop iterators
 * to the array indices.
 * The result is a relations between source and sink
 * iterations and a subset of the domain of the sink accesses,
 * corresponding to those iterations that access an element
 * not previously accessed.
 *
 * We collect the inputs in an isl_union_access_info object,
 * call isl_union_access_info_compute_flow and extract
 * the outputs from the result.
 */</doc>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='3549' u='c' c='test_flow'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='4338' u='c' c='test_one_schedule'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='4342' u='c' c='test_one_schedule'/>
