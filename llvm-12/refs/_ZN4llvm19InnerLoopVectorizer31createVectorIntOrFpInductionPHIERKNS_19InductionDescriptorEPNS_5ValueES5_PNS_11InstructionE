<dec f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='670' type='void llvm::InnerLoopVectorizer::createVectorIntOrFpInductionPHI(const llvm::InductionDescriptor &amp; II, llvm::Value * Step, llvm::Value * Start, llvm::Instruction * EntryVal)'/>
<def f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='2024' ll='2101' type='void llvm::InnerLoopVectorizer::createVectorIntOrFpInductionPHI(const llvm::InductionDescriptor &amp; II, llvm::Value * Step, llvm::Value * Start, llvm::Instruction * EntryVal)'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='2229' u='c' c='_ZN4llvm19InnerLoopVectorizer21widenIntOrFpInductionEPNS_7PHINodeEPNS_5ValueEPNS_9TruncInstE'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='2237' u='c' c='_ZN4llvm19InnerLoopVectorizer21widenIntOrFpInductionEPNS_7PHINodeEPNS_5ValueEPNS_9TruncInstE'/>
<doc f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='665'>/// Create a vector induction phi node based on an existing scalar one. \p
  /// EntryVal is the value from the original loop that maps to the vector phi
  /// node, and \p Step is the loop-invariant step. If \p EntryVal is a
  /// truncate instruction, instead of widening the original IV, we widen a
  /// version of the IV truncated to \p EntryVal&apos;s type.</doc>
