<dec f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='1081' type='bool llvm::TargetInstrInfo::getMachineCombinerPatterns(llvm::MachineInstr &amp; Root, SmallVectorImpl&lt;llvm::MachineCombinerPattern&gt; &amp; Patterns, bool DoRegPressureReduce) const'/>
<doc f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='1073'>/// Return true when there is potentially a faster code sequence
  /// for an instruction chain ending in \p Root. All potential patterns are
  /// returned in the \p Pattern vector. Pattern should be sorted in priority
  /// order since the pattern evaluator stops checking as soon as it finds a
  /// faster sequence.
  /// \param Root - Instruction that could be combined with one of its operands
  /// \param Patterns - Vector of possible combination patterns</doc>
<use f='llvm/llvm/lib/CodeGen/MachineCombiner.cpp' l='593' u='c' c='_ZN12_GLOBAL__N_115MachineCombiner19combineInstructionsEPN4llvm17MachineBasicBlockE'/>
<def f='llvm/llvm/lib/CodeGen/TargetInstrInfo.cpp' l='780' ll='800' type='bool llvm::TargetInstrInfo::getMachineCombinerPatterns(llvm::MachineInstr &amp; Root, SmallVectorImpl&lt;llvm::MachineCombinerPattern&gt; &amp; Patterns, bool DoRegPressureReduce) const'/>
<doc f='llvm/llvm/lib/CodeGen/TargetInstrInfo.cpp' l='759'>// The concept of the reassociation pass is that these operations can benefit
// from this kind of transformation:
//
// A = ? op ?
// B = A op X (Prev)
// C = B op Y (Root)
// --&gt;
// A = ? op ?
// B = X op Y
// C = A op B
//
// breaking the dependency between A and B, allowing them to be executed in
// parallel (or back-to-back in a pipeline) instead of depending on each other.

// FIXME: This has the potential to be expensive (compile time) while not
// improving the code at all. Some ways to limit the overhead:
// 1. Track successful transforms; bail out if hit rate gets too low.
// 2. Only enable at -O3 or some other non-default optimization level.
// 3. Pre-screen pattern candidates here: if an operand of the previous
//    instruction is known to not increase the critical path, then don&apos;t match
//    that pattern.</doc>
<ovr f='llvm/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp' l='4640' c='_ZNK4llvm16AArch64InstrInfo26getMachineCombinerPatternsERNS_12MachineInstrERNS_15SmallVectorImplINS_22MachineCombinerPatternEEEb'/>
<use f='llvm/llvm/lib/Target/AArch64/AArch64InstrInfo.cpp' l='4650' u='c' c='_ZNK4llvm16AArch64InstrInfo26getMachineCombinerPatternsERNS_12MachineInstrERNS_15SmallVectorImplINS_22MachineCombinerPatternEEEb'/>
<ovr f='llvm/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp' l='759' c='_ZNK4llvm12PPCInstrInfo26getMachineCombinerPatternsERNS_12MachineInstrERNS_15SmallVectorImplINS_22MachineCombinerPatternEEEb'/>
<use f='llvm/llvm/lib/Target/PowerPC/PPCInstrInfo.cpp' l='770' u='c' c='_ZNK4llvm12PPCInstrInfo26getMachineCombinerPatternsERNS_12MachineInstrERNS_15SmallVectorImplINS_22MachineCombinerPatternEEEb'/>
