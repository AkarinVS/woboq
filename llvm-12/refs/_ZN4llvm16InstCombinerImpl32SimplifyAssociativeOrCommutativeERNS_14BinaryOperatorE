<dec f='llvm/llvm/lib/Transforms/InstCombine/InstCombineInternal.h' l='527' type='bool llvm::InstCombinerImpl::SimplifyAssociativeOrCommutative(llvm::BinaryOperator &amp; I)'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp' l='1287' u='c' c='_ZN4llvm16InstCombinerImpl8visitAddERNS_14BinaryOperatorE'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp' l='1513' u='c' c='_ZN4llvm16InstCombinerImpl9visitFAddERNS_14BinaryOperatorE'/>
<doc f='llvm/llvm/lib/Transforms/InstCombine/InstCombineInternal.h' l='525'>/// Performs a few simplifications for operators which are associative
  /// or commutative.</doc>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp' l='1707' u='c' c='_ZN4llvm16InstCombinerImpl8visitAndERNS_14BinaryOperatorE'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp' l='2562' u='c' c='_ZN4llvm16InstCombinerImpl7visitOrERNS_14BinaryOperatorE'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp' l='3150' u='c' c='_ZN4llvm16InstCombinerImpl8visitXorERNS_14BinaryOperatorE'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp' l='147' u='c' c='_ZN4llvm16InstCombinerImpl8visitMulERNS_14BinaryOperatorE'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp' l='434' u='c' c='_ZN4llvm16InstCombinerImpl9visitFMulERNS_14BinaryOperatorE'/>
<def f='llvm/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp' l='369' ll='525' type='bool llvm::InstCombinerImpl::SimplifyAssociativeOrCommutative(llvm::BinaryOperator &amp; I)'/>
<doc f='llvm/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp' l='349'>/// This performs a few simplifications for operators that are associative or
/// commutative:
///
///  Commutative operators:
///
///  1. Order operands such that they are listed from right (least complex) to
///     left (most complex).  This puts constants before unary operators before
///     binary operators.
///
///  Associative operators:
///
///  2. Transform: &quot;(A op B) op C&quot; ==&gt; &quot;A op (B op C)&quot; if &quot;B op C&quot; simplifies.
///  3. Transform: &quot;A op (B op C)&quot; ==&gt; &quot;(A op B) op C&quot; if &quot;A op B&quot; simplifies.
///
///  Associative and commutative operators:
///
///  4. Transform: &quot;(A op B) op C&quot; ==&gt; &quot;(C op A) op B&quot; if &quot;C op A&quot; simplifies.
///  5. Transform: &quot;A op (B op C)&quot; ==&gt; &quot;B op (C op A)&quot; if &quot;C op A&quot; simplifies.
///  6. Transform: &quot;(A op C1) op (B op C2)&quot; ==&gt; &quot;(A op B) op (C1 op C2)&quot;
///     if C1 and C2 are constants.</doc>
