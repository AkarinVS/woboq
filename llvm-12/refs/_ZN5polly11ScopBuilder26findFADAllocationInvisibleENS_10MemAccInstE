<dec f='llvm/polly/include/polly/ScopBuilder.h' l='105' type='llvm::Value * polly::ScopBuilder::findFADAllocationInvisible(polly::MemAccInst Inst)'/>
<def f='llvm/polly/lib/Analysis/ScopBuilder.cpp' l='1458' ll='1491' type='llvm::Value * polly::ScopBuilder::findFADAllocationInvisible(polly::MemAccInst Inst)'/>
<use f='llvm/polly/lib/Analysis/ScopBuilder.cpp' l='2323' u='c' c='_ZN5polly11ScopBuilder14addArrayAccessEPNS_8ScopStmtENS_10MemAccInstENS_12MemoryAccess10AccessTypeEPN4llvm5ValueEPNS6_4TypeEbNS6_8ArrayRefIPKNS6_4SCEVEEESF_S8_'/>
<doc f='llvm/polly/include/polly/ScopBuilder.h' l='76'>// Methods for pattern matching against Fortran code generated by dragonegg.
  // @{

  /// Try to match for the descriptor of a Fortran array whose allocation
  /// is not visible. That is, we can see the load/store into the memory, but
  /// we don&apos;t actually know where the memory is allocated. If ALLOCATE had been
  /// called on the Fortran array, then we will see the lowered malloc() call.
  /// If not, this is dubbed as an &quot;invisible allocation&quot;.
  ///
  /// &quot;&lt;descriptor&gt;&quot; is the descriptor of the Fortran array.
  ///
  /// Pattern match for &quot;@descriptor&quot;:
  ///  1. %mem = load double*, double** bitcast (%&quot;struct.array1_real(kind=8)&quot;*
  ///    &lt;descriptor&gt; to double**), align 32
  ///
  ///  2. [%slot = getelementptr inbounds i8, i8* %mem, i64 &lt;index&gt;]
  ///  2 is optional because if you are writing to the 0th index, you don&apos;t
  ///     need a GEP.
  ///
  ///  3.1 store/load &lt;memtype&gt; &lt;val&gt;, &lt;memtype&gt;* %slot
  ///  3.2 store/load &lt;memtype&gt; &lt;val&gt;, &lt;memtype&gt;* %mem
  ///
  /// @see polly::MemoryAccess, polly::ScopArrayInfo
  ///
  /// @note assumes -polly-canonicalize has been run.
  ///
  /// @param Inst The LoadInst/StoreInst that accesses the memory.
  ///
  /// @returns Reference to &lt;descriptor&gt; on success, nullptr on failure.</doc>
