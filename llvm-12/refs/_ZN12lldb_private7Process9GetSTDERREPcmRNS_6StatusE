<dec f='llvm/lldb/include/lldb/Target/Process.h' l='1919' type='size_t lldb_private::Process::GetSTDERR(char * buf, size_t buf_size, lldb_private::Status &amp; error)'/>
<doc f='llvm/lldb/include/lldb/Target/Process.h' l='1892'>/// Get any available STDERR.
  ///
  /// Calling this method is a valid operation only if all of the following
  /// conditions are true: 1) The process was launched, and not attached to.
  /// 2) The process was not launched with eLaunchFlagDisableSTDIO. 3) The
  /// process was launched without supplying a valid file path
  ///    for STDERR.
  ///
  /// Note that the implementation will probably need to start a read thread
  /// in the background to make sure that the pipe is drained and the STDERR
  /// buffered appropriately, to prevent the process from deadlocking trying
  /// to write to a full buffer.
  ///
  /// Events will be queued indicating that there is STDERR available that can
  /// be retrieved using this function.
  ///
  /// \param[in] buf
  ///     A buffer that will receive any STDERR bytes that are
  ///     currently available.
  ///
  /// \param[out] buf_size
  ///     The size in bytes for the buffer \a buf.
  ///
  /// \return
  ///     The number of bytes written into \a buf. If this value is
  ///     equal to \a buf_size, another call to this function should
  ///     be made to retrieve more STDERR data.</doc>
<use f='llvm/lldb/source/API/SBProcess.cpp' l='295' u='c' c='_ZNK4lldb9SBProcess9GetSTDERREPcm'/>
<use f='llvm/lldb/source/Core/Debugger.cpp' l='1286' u='a' c='_ZN12lldb_private8Debugger18FlushProcessOutputERNS_7ProcessEbb'/>
<def f='llvm/lldb/source/Target/Process.cpp' l='4242' ll='4259' type='size_t lldb_private::Process::GetSTDERR(char * buf, size_t buf_size, lldb_private::Status &amp; error)'/>
