<def f='llvm/llvm/include/llvm/Support/TaskQueue.h' l='34' ll='135'/>
<use f='llvm/llvm/include/llvm/Support/TaskQueue.h' l='42' c='_ZN4llvm9TaskQueue4TaskC1ET_RS0_'/>
<use f='llvm/llvm/include/llvm/Support/TaskQueue.h' l='64'/>
<use f='llvm/llvm/unittests/Support/TaskQueueTest.cpp' l='26' c='_ZN33TaskQueueTest_OrderedFutures_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/Support/TaskQueueTest.cpp' l='70' c='_ZN35TaskQueueTest_UnOrderedFutures_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/Support/TaskQueueTest.cpp' l='100' c='_ZN40TaskQueueTest_FutureWithReturnValue_Test8TestBodyEv'/>
<size>136</size>
<doc f='llvm/llvm/include/llvm/Support/TaskQueue.h' l='31'>/// TaskQueue executes serialized work on a user-defined Thread Pool.  It
/// guarantees that if task B is enqueued after task A, task B begins after
/// task A completes and there is no overlap between the two.</doc>
<fun r='_ZN4llvm9TaskQueueC1ERNS_10ThreadPoolE'/>
<fun r='_ZN4llvm9TaskQueueD1Ev'/>
<fun r='_ZN4llvm9TaskQueue5asyncEOT_'/>
<fun r='_ZN4llvm9TaskQueue12completeTaskEv'/>
<mbr r='llvm::TaskQueue::Scheduler' o='0' t='llvm::ThreadPool &amp;'/>
<mbr r='llvm::TaskQueue::IsTaskInFlight' o='64' t='bool'/>
<mbr r='llvm::TaskQueue::QueueLock' o='128' t='std::mutex'/>
<mbr r='llvm::TaskQueue::Tasks' o='448' t='std::deque&lt;std::function&lt;void ()&gt; &gt;'/>
