<dec f='llvm/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.h' l='143' type='void llvm::HexagonDAGToDAGISel::ppAddrRewriteAndSrl(std::vector&lt;SDNode *&gt; &amp;&amp; Nodes)'/>
<def f='llvm/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp' l='1097' ll='1158' type='void llvm::HexagonDAGToDAGISel::ppAddrRewriteAndSrl(std::vector&lt;SDNode *&gt; &amp;&amp; Nodes)'/>
<use f='llvm/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp' l='1257' u='c' c='_ZN4llvm19HexagonDAGToDAGISel17PreprocessISelDAGEv'/>
<doc f='llvm/llvm/lib/Target/Hexagon/HexagonISelDAGToDAG.cpp' l='1084'>// Transform: (load ch (add x (and (srl y c) Mask)))
//        to: (load ch (add x (shl (srl y d) d-c)))
// where
// Mask = 00..0 111..1 0.0
//          |     |     +-- d-c 0s, and d-c is 0, 1 or 2.
//          |     +-------- 1s
//          +-------------- at most c 0s
// Motivating example:
// DAG combiner optimizes (add x (shl (srl y 5) 2))
//                     to (add x (and (srl y 3) 1FFFFFFC))
// which results in a constant-extended and(##...,lsr). This transformation
// undoes this simplification for cases where the shl can be folded into
// an addressing mode.</doc>
