<dec f='llvm/llvm/include/llvm/IR/Constants.h' l='194' type='static bool llvm::ConstantInt::isValueValidForType(llvm::Type * Ty, uint64_t V)'/>
<doc f='llvm/llvm/include/llvm/IR/Constants.h' l='185'>/// This static method returns true if the type Ty is big enough to
  /// represent the value V. This can be used to avoid having the get method
  /// assert when V is larger than Ty can represent. Note that there are two
  /// versions of this method, one for unsigned and one for signed integers.
  /// Although ConstantInt canonicalizes everything to an unsigned integer,
  /// the signed version avoids callers having to convert a signed quantity
  /// to the appropriate unsigned type before calling the method.
  /// @returns true if V is a valid value for type Ty
  /// Determine if the value is in range for the given type.</doc>
<def f='llvm/llvm/lib/IR/Constants.cpp' l='1546' ll='1551' type='static bool llvm::ConstantInt::isValueValidForType(llvm::Type * Ty, uint64_t Val)'/>
<doc f='llvm/llvm/lib/IR/Constants.cpp' l='1543'>//===----------------------------------------------------------------------===//
//                      isValueValidForType implementations</doc>
<use f='llvm/llvm/lib/Target/X86/X86ISelLowering.cpp' l='51099' u='c' c='_ZNK4llvm17X86TargetLowering28LowerAsmOperandForConstraintENS_7SDValueERNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERSt6vectorIS1_SaIS1_EERNS_12SelectionDAGE'/>
<use f='llvm/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp' l='1064' u='c' c='_ZN12_GLOBAL__N_121FunctionStackPoisoner18visitIntrinsicInstERN4llvm13IntrinsicInstE'/>
