<def f='llvm/llvm/include/llvm/Support/YAMLTraits.h' l='299' ll='305'/>
<use f='llvm/llvm/include/llvm/Support/YAMLTraits.h' l='537'/>
<use f='llvm/llvm/include/llvm/Support/YAMLTraits.h' l='1097' c='_ZN4llvm4yaml7yamlizeERNS0_2IOERT_bRNS0_12EmptyContextE'/>
<use f='llvm/llvm/include/llvm/Support/YAMLTraits.h' l='1100' c='_ZN4llvm4yaml7yamlizeERNS0_2IOERT_bRNS0_12EmptyContextE'/>
<use f='llvm/llvm/include/llvm/Support/YAMLTraits.h' l='1102' c='_ZN4llvm4yaml7yamlizeERNS0_2IOERT_bRNS0_12EmptyContextE'/>
<use f='llvm/llvm/include/llvm/Support/YAMLTraits.h' l='1104' c='_ZN4llvm4yaml7yamlizeERNS0_2IOERT_bRNS0_12EmptyContextE'/>
<doc f='llvm/llvm/include/llvm/Support/YAMLTraits.h' l='282'>/// This class should be specialized by any type that can be represented as
/// a scalar, map, or sequence, decided dynamically. For example:
///
///    typedef std::unique_ptr&lt;MyBase&gt; MyPoly;
///
///    template&lt;&gt;
///    struct PolymorphicTraits&lt;MyPoly&gt; {
///      static NodeKind getKind(const MyPoly &amp;poly) {
///        return poly-&gt;getKind();
///      }
///      static MyScalar&amp; getAsScalar(MyPoly &amp;poly) {
///        if (!poly || !isa&lt;MyScalar&gt;(poly))
///          poly.reset(new MyScalar());
///        return *cast&lt;MyScalar&gt;(poly.get());
///      }
///      // ...
///    };</doc>
<def f='llvm/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp' l='147' ll='170'/>
<use f='llvm/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp' l='147'/>
<size>1</size>
<doc f='llvm/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp' l='146'>/// YAMLIO for DocNode</doc>
<def f='llvm/llvm/unittests/Support/YAMLIOTest.cpp' l='2886' ll='2914'/>
<use f='llvm/llvm/unittests/Support/YAMLIOTest.cpp' l='2886'/>
<size>1</size>
