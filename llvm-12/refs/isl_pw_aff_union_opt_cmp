<def f='llvm/polly/lib/External/isl/isl_pw_union_opt.c' l='295' macro='1' type='isl_pw_aff * isl_pw_aff_union_opt_cmp(isl_pw_aff * pw1, isl_pw_aff * pw2, isl_map *(*)(isl_aff *, isl_aff *) cmp)'/>
<use f='llvm/polly/lib/External/isl/isl_aff.c' l='2819' u='c' c='isl_pw_aff_union_max'/>
<use f='llvm/polly/lib/External/isl/isl_aff.c' l='2832' u='c' c='isl_pw_aff_union_min'/>
<doc f='llvm/polly/lib/External/isl/isl_pw_union_opt.c' l='277'>/* Given a function &quot;cmp&quot; that returns the set of elements where
 * &quot;el1&quot; is &quot;better&quot; than &quot;el2&quot;, return a piecewise
 * expression defined on the union of the definition domains
 * of &quot;pw1&quot; and &quot;pw2&quot; that maps to the &quot;best&quot; of &quot;pw1&quot; and
 * &quot;pw2&quot; on each cell.  If only one of the two input functions
 * is defined on a given cell, then it is considered the best.
 *
 * Run through all pairs of pieces in &quot;pw1&quot; and &quot;pw2&quot;.
 * If the domains of these pieces intersect, then the intersection
 * needs to be distributed over the two pieces based on &quot;cmp&quot;.
 *
 * After the updated domains have been computed, the result is constructed
 * from &quot;pw1&quot;, &quot;pw2&quot;, data[0].cell and data[1].cell.  If there are any pieces
 * in &quot;pw1&quot; and &quot;pw2&quot; with the same function value expression, then
 * they are combined into a single piece in the result.
 * In order to be able to do this efficiently, the pieces of &quot;pw1&quot; and
 * &quot;pw2&quot; are first sorted according to their function value expressions.
 */</doc>
