<dec f='llvm/llvm/utils/benchmark/include/benchmark/benchmark.h' l='510' type='void benchmark::State::SkipWithError(const char * msg)'/>
<doc f='llvm/llvm/utils/benchmark/include/benchmark/benchmark.h' l='491'>// REQUIRES: &apos;SkipWithError(...)&apos; has not been called previously by the
  //            current thread.
  // Report the benchmark as resulting in an error with the specified &apos;msg&apos;.
  // After this call the user may explicitly &apos;return&apos; from the benchmark.
  //
  // If the ranged-for style of benchmark loop is used, the user must explicitly
  // break from the loop, otherwise all future iterations will be run.
  // If the &apos;KeepRunning()&apos; loop is used the current thread will automatically
  // exit the loop at the end of the current iteration.
  //
  // For threaded benchmarks only the current thread stops executing and future
  // calls to `KeepRunning()` will block until all threads have completed
  // the `KeepRunning()` loop. If multiple threads report an error only the
  // first error message is used.
  //
  // NOTE: Calling &apos;SkipWithError(...)&apos; does not cause the benchmark to exit
  // the current scope immediately. If the function is called from within
  // the &apos;KeepRunning()&apos; loop the current iteration will finish. It is the users
  // responsibility to exit the scope as needed.</doc>
<def f='llvm/llvm/utils/benchmark/src/benchmark.cc' l='344' ll='356' type='void benchmark::State::SkipWithError(const char * msg)'/>
