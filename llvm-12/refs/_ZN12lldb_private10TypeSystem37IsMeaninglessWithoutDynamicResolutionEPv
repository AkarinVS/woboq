<dec f='llvm/lldb/include/lldb/Symbol/TypeSystem.h' l='495' type='bool lldb_private::TypeSystem::IsMeaninglessWithoutDynamicResolution(void * type)'/>
<doc f='llvm/lldb/include/lldb/Symbol/TypeSystem.h' l='483'>// Type systems can have types that are placeholder types, which are meant to
  // indicate the presence of a type, but offer no actual information about
  // said types, and leave the burden of actually figuring type information out
  // to dynamic type resolution. For instance a language with a generics
  // system, can use placeholder types to indicate &quot;type argument goes here&quot;,
  // without promising uniqueness of the placeholder, nor attaching any
  // actually idenfiable information to said placeholder. This API allows type
  // systems to tell LLDB when such a type has been encountered In response,
  // the debugger can react by not using this type as a cache entry in any
  // type-specific way For instance, LLDB will currently not cache any
  // formatters that are discovered on such a type as attributable to the
  // meaningless type itself, instead preferring to use the dynamic type</doc>
<use f='llvm/lldb/source/Symbol/CompilerType.cpp' l='703' u='c' c='_ZNK12lldb_private12CompilerType37IsMeaninglessWithoutDynamicResolutionEv'/>
<def f='llvm/lldb/source/Symbol/TypeSystem.cpp' l='145' ll='147' type='bool lldb_private::TypeSystem::IsMeaninglessWithoutDynamicResolution(void * type)'/>
