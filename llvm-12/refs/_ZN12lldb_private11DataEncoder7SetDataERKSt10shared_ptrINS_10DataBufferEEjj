<dec f='llvm/lldb/include/lldb/Utility/DataEncoder.h' l='212' type='uint32_t lldb_private::DataEncoder::SetData(const lldb::DataBufferSP &amp; data_sp, uint32_t offset = 0, uint32_t length = (4294967295U))'/>
<doc f='llvm/lldb/include/lldb/Utility/DataEncoder.h' l='190'>/// Adopt a subset of shared data in \a data_sp.
  ///
  /// Copies the data shared pointer which adds a reference to the contained
  /// in \a data_sp. The shared data reference is reference counted to ensure
  /// the data lives as long as anyone still has a valid shared pointer to the
  /// data in \a data_sp. The byte order and address byte size settings remain
  /// the same. If \a offset is not a valid offset in \a data_sp, then no
  /// reference to the shared data will be added. If there are not \a length
  /// bytes available in \a data starting at \a offset, the length will be
  /// truncated to contains as many bytes as possible.
  ///
  /// \param[in] data_sp
  ///     A shared pointer to data.
  ///
  /// \param[in] offset
  ///     The offset into \a data_sp at which the subset starts.
  ///
  /// \param[in] length
  ///     The length in bytes of the subset of \a data_sp.
  ///
  /// \return
  ///     The number of bytes that this object now contains.</doc>
<use f='llvm/lldb/source/Utility/DataEncoder.cpp' l='47' u='c' c='_ZN12lldb_private11DataEncoderC1ERKSt10shared_ptrINS_10DataBufferEEN4lldb9ByteOrderEh'/>
<def f='llvm/lldb/source/Utility/DataEncoder.cpp' l='73' ll='102' type='uint32_t lldb_private::DataEncoder::SetData(const lldb::DataBufferSP &amp; data_sp, uint32_t data_offset = 0, uint32_t data_length = (4294967295U))'/>
<doc f='llvm/lldb/source/Utility/DataEncoder.cpp' l='62'>// Assign the data for this object to be a subrange of the shared data in
// &quot;data_sp&quot; starting &quot;data_offset&quot; bytes into &quot;data_sp&quot; and ending
// &quot;data_length&quot; bytes later. If &quot;data_offset&quot; is not a valid offset into
// &quot;data_sp&quot;, then this object will contain no bytes. If &quot;data_offset&quot; is
// within &quot;data_sp&quot; yet &quot;data_length&quot; is too large, the length will be capped
// at the number of bytes remaining in &quot;data_sp&quot;. A ref counted pointer to the
// data in &quot;data_sp&quot; will be made in this object IF the number of bytes this
// object refers to in greater than zero (if at least one byte was available
// starting at &quot;data_offset&quot;) to ensure the data stays around as long as it is
// needed. The address size and endian swap settings will remain unchanged from
// their current settings.</doc>
