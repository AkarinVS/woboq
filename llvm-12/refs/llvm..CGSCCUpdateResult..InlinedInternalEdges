<dec f='llvm/llvm/include/llvm/Analysis/CGSCCPassManager.h' l='317' type='SmallDenseSet&lt;std::pair&lt;LazyCallGraph::Node *, LazyCallGraph::SCC *&gt;, 4&gt; &amp;'/>
<offset>1152</offset>
<doc f='llvm/llvm/include/llvm/Analysis/CGSCCPassManager.h' l='310'>/// A hacky area where the inliner can retain history about inlining
  /// decisions that mutated the call graph&apos;s SCC structure in order to avoid
  /// infinite inlining. See the comments in the inliner&apos;s CG update logic.
  ///
  /// FIXME: Keeping this here seems like a big layering issue, we should look
  /// for a better technique.</doc>
<use f='llvm/llvm/lib/Transforms/IPO/Inliner.cpp' l='807' u='m' c='_ZN4llvm11InlinerPass3runERNS_13LazyCallGraph3SCCERNS_15AnalysisManagerIS2_JRS1_EEES5_RNS_17CGSCCUpdateResultE'/>
<use f='llvm/llvm/lib/Transforms/IPO/Inliner.cpp' l='946' u='m' c='_ZN4llvm11InlinerPass3runERNS_13LazyCallGraph3SCCERNS_15AnalysisManagerIS2_JRS1_EEES5_RNS_17CGSCCUpdateResultE'/>
