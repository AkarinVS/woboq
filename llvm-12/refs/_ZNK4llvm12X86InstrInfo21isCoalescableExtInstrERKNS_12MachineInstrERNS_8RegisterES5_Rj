<dec f='llvm/llvm/lib/Target/X86/X86InstrInfo.h' l='181' type='bool llvm::X86InstrInfo::isCoalescableExtInstr(const llvm::MachineInstr &amp; MI, llvm::Register &amp; SrcReg, llvm::Register &amp; DstReg, unsigned int &amp; SubIdx) const'/>
<doc f='llvm/llvm/lib/Target/X86/X86InstrInfo.h' l='175'>/// isCoalescableExtInstr - Return true if the instruction is a &quot;coalescable&quot;
  /// extension instruction. That is, it&apos;s like a copy where it&apos;s legal for the
  /// source to overlap the destination. e.g. X86::MOVSX64rr32. If this returns
  /// true, then it&apos;s expected the pre-extension value is available as a subreg
  /// of the result register. This also returns the sub-register index in
  /// SubIdx.</doc>
<inh f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='246' c='_ZNK4llvm15TargetInstrInfo21isCoalescableExtInstrERKNS_12MachineInstrERNS_8RegisterES5_Rj'/>
<def f='llvm/llvm/lib/Target/X86/X86InstrInfo.cpp' l='89' ll='136' type='bool llvm::X86InstrInfo::isCoalescableExtInstr(const llvm::MachineInstr &amp; MI, llvm::Register &amp; SrcReg, llvm::Register &amp; DstReg, unsigned int &amp; SubIdx) const'/>
