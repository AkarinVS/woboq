<dec f='llvm/llvm/lib/Transforms/Utils/PredicateInfo.cpp' l='287' type='void llvm::PredicateInfoBuilder::renameUses(SmallVectorImpl&lt;llvm::Value *&gt; &amp; OpsToRename)'/>
<use f='llvm/llvm/lib/Transforms/Utils/PredicateInfo.cpp' l='541' u='c' c='_ZN4llvm20PredicateInfoBuilder18buildPredicateInfoEv'/>
<def f='llvm/llvm/lib/Transforms/Utils/PredicateInfo.cpp' l='634' ll='753' type='void llvm::PredicateInfoBuilder::renameUses(SmallVectorImpl&lt;llvm::Value *&gt; &amp; OpsToRename)'/>
<doc f='llvm/llvm/lib/Transforms/Utils/PredicateInfo.cpp' l='615'>// Instead of the standard SSA renaming algorithm, which is O(Number of
// instructions), and walks the entire dominator tree, we walk only the defs +
// uses.  The standard SSA renaming algorithm does not really rely on the
// dominator tree except to order the stack push/pops of the renaming stacks, so
// that defs end up getting pushed before hitting the correct uses.  This does
// not require the dominator tree, only the *order* of the dominator tree. The
// complete and correct ordering of the defs and uses, in dominator tree is
// contained in the DFS numbering of the dominator tree. So we sort the defs and
// uses into the DFS ordering, and then just use the renaming stack as per
// normal, pushing when we hit a def (which is a predicateinfo instruction),
// popping when we are out of the dfs scope for that def, and replacing any uses
// with top of stack if it exists.  In order to handle liveness without
// propagating liveness info, we don&apos;t actually insert the predicateinfo
// instruction def until we see a use that it would dominate.  Once we see such
// a use, we materialize the predicateinfo instruction in the right place and
// use it.
//
// TODO: Use this algorithm to perform fast single-variable renaming in
// promotememtoreg and memoryssa.</doc>
