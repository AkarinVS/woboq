<def f='llvm/llvm/include/llvm/CodeGen/TargetLowering.h' l='2014' ll='2016' type='ISD::NodeType llvm::TargetLoweringBase::getExtendForAtomicCmpSwapArg() const'/>
<doc f='llvm/llvm/include/llvm/CodeGen/TargetLowering.h' l='2006'>/// Returns how the platform&apos;s atomic compare and swap expects its comparison
  /// value to be extended (ZERO_EXTEND, SIGN_EXTEND, or ANY_EXTEND). This is
  /// separate from getExtendForAtomicOps, which is concerned with the
  /// sign-extension of the instruction&apos;s output, whereas here we are concerned
  /// with the sign-extension of the input. For targets with compare-and-swap
  /// instructions (or sub-word comparisons in their LL/SC loop expansions),
  /// the input can be ANY_EXTEND, but the output will still have a specific
  /// extension.</doc>
<use f='llvm/llvm/lib/CodeGen/SelectionDAG/LegalizeIntegerTypes.cpp' l='305' u='c' c='_ZN4llvm16DAGTypeLegalizer27PromoteIntRes_AtomicCmpSwapEPNS_12AtomicSDNodeEj'/>
<ovr f='llvm/llvm/lib/Target/RISCV/RISCVISelLowering.h' l='208' c='_ZNK4llvm19RISCVTargetLowering28getExtendForAtomicCmpSwapArgEv'/>
