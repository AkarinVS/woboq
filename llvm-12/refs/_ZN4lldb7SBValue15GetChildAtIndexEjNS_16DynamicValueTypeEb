<dec f='llvm/lldb/include/lldb/API/SBValue.h' l='190' type='lldb::SBValue lldb::SBValue::GetChildAtIndex(uint32_t idx, lldb::DynamicValueType use_dynamic, bool can_create_synthetic)'/>
<use f='llvm/build/tools/lldb/bindings/python/LLDBWrapPython.cpp' l='75814' u='c' c='_ZL37_wrap_SBValue_GetChildAtIndex__SWIG_1P7_objectlPS0_'/>
<doc f='llvm/lldb/include/lldb/API/SBValue.h' l='138'>/// Get a child value by index from a value.
  ///
  /// Structs, unions, classes, arrays and pointers have child
  /// values that can be access by index.
  ///
  /// Structs and unions access child members using a zero based index
  /// for each child member. For
  ///
  /// Classes reserve the first indexes for base classes that have
  /// members (empty base classes are omitted), and all members of the
  /// current class will then follow the base classes.
  ///
  /// Pointers differ depending on what they point to. If the pointer
  /// points to a simple type, the child at index zero
  /// is the only child value available, unless \a synthetic_allowed
  /// is \b true, in which case the pointer will be used as an array
  /// and can create &apos;synthetic&apos; child values using positive or
  /// negative indexes. If the pointer points to an aggregate type
  /// (an array, class, union, struct), then the pointee is
  /// transparently skipped and any children are going to be the indexes
  /// of the child values within the aggregate type. For example if
  /// we have a &apos;Point&apos; type and we have a SBValue that contains a
  /// pointer to a &apos;Point&apos; type, then the child at index zero will be
  /// the &apos;x&apos; member, and the child at index 1 will be the &apos;y&apos; member
  /// (the child at index zero won&apos;t be a &apos;Point&apos; instance).
  ///
  /// If you actually need an SBValue that represents the type pointed
  /// to by a SBValue for which GetType().IsPointeeType() returns true,
  /// regardless of the pointee type, you can do that with SBValue::Dereference.
  ///
  /// Arrays have a preset number of children that can be accessed by
  /// index and will returns invalid child values for indexes that are
  /// out of bounds unless the \a synthetic_allowed is \b true. In this
  /// case the array can create &apos;synthetic&apos; child values for indexes
  /// that aren&apos;t in the array bounds using positive or negative
  /// indexes.
  ///
  /// \param[in] idx
  ///     The index of the child value to get
  ///
  /// \param[in] use_dynamic
  ///     An enumeration that specifies whether to get dynamic values,
  ///     and also if the target can be run to figure out the dynamic
  ///     type of the child value.
  ///
  /// \param[in] can_create_synthetic
  ///     If \b true, then allow child values to be created by index
  ///     for pointers and arrays for indexes that normally wouldn&apos;t
  ///     be allowed.
  ///
  /// \return
  ///     A new SBValue object that represents the child member value.</doc>
<use f='llvm/lldb/source/API/SBValue.cpp' l='685' u='c' c='_ZN4lldb7SBValue15GetChildAtIndexEj'/>
<def f='llvm/lldb/source/API/SBValue.cpp' l='688' ll='711' type='lldb::SBValue lldb::SBValue::GetChildAtIndex(uint32_t idx, lldb::DynamicValueType use_dynamic, bool can_create_synthetic)'/>
<use f='llvm/lldb/source/API/SBValue.cpp' l='691' u='a' c='_ZN4lldb7SBValue15GetChildAtIndexEjNS_16DynamicValueTypeEb'/>
<use f='llvm/lldb/source/API/SBValue.cpp' l='691' u='a' c='_ZN4lldb7SBValue15GetChildAtIndexEjNS_16DynamicValueTypeEb'/>
<use f='llvm/lldb/source/API/SBValue.cpp' l='1595' u='a' c='_ZN12lldb_private5repro15RegisterMethodsERNS0_8RegistryE'/>
