<inh f='llvm/llvm/utils/TableGen/GlobalISel/GIMatchTree.h' l='442' c='llvm::GIMatchTreePartitioner'/>
<def f='llvm/llvm/utils/TableGen/GlobalISel/GIMatchTree.h' l='556' ll='583'/>
<use f='llvm/llvm/utils/TableGen/GlobalISel/GIMatchTree.h' l='566' c='_ZNK4llvm28GIMatchTreeOpcodePartitioner5cloneEv'/>
<size>112</size>
<doc f='llvm/llvm/utils/TableGen/GlobalISel/GIMatchTree.h' l='530'>/// Partition according to the opcode of the instruction.
///
/// Numbers CodeGenInstr ptrs for use as partition ID&apos;s. One special partition,
/// nullptr, represents the case where the instruction isn&apos;t known.
///
/// * If the opcode can be tested and is a single opcode, create the partition
///   for that opcode and assign the leaf to it. This partition no longer needs
///   to test the opcode, and many details about the instruction will usually
///   become known (e.g. number of operands for non-variadic instrs) via the
///   CodeGenInstr ptr.
/// * (not implemented yet) If the opcode can be tested and is a choice of
///   opcodes, then the leaf can be treated like the single-opcode case but must
///   be added to all relevant partitions and not quite as much becomes known as
///   a result. That said, multiple-choice opcodes are likely similar enough
///   (because if they aren&apos;t then handling them together makes little sense)
///   that plenty still becomes known. The main implementation issue with this
///   is having a description to represent the commonality between instructions.
/// * If the opcode is not tested, the leaf must be added to all partitions
///   including the wildcard nullptr partition. What becomes known as a result
///   varies between partitions.
/// * If the instruction to be tested is not declared then add the leaf to all
///   partitions. This occurs when we encounter one rule that is a superset of
///   the other and we are still matching the remainder of the superset. The
///   result is that the cases that don&apos;t match the superset will match the
///   subset rule, while the ones that do match the superset will match either
///   (which one is algorithm dependent but will usually be the superset).</doc>
<mbr r='llvm::GIMatchTreeOpcodePartitioner::InstrID' o='256' t='unsigned int'/>
<mbr r='llvm::GIMatchTreeOpcodePartitioner::InstrToPartition' o='320' t='DenseMap&lt;const llvm::CodeGenInstruction *, unsigned int&gt;'/>
<mbr r='llvm::GIMatchTreeOpcodePartitioner::PartitionToInstr' o='512' t='std::vector&lt;const CodeGenInstruction *&gt;'/>
<mbr r='llvm::GIMatchTreeOpcodePartitioner::TestedPredicates' o='704' t='std::vector&lt;BitVector&gt;'/>
<fun r='_ZN4llvm28GIMatchTreeOpcodePartitionerC1Ej'/>
<fun r='_ZNK4llvm28GIMatchTreeOpcodePartitioner5cloneEv'/>
<fun r='_ZNK4llvm28GIMatchTreeOpcodePartitioner15emitDescriptionERNS_11raw_ostreamE'/>
<fun r='_ZNK4llvm28GIMatchTreeOpcodePartitioner17emitPartitionNameERNS_11raw_ostreamEj'/>
<fun r='_ZN4llvm28GIMatchTreeOpcodePartitioner11repartitionERSt6vectorINS_26GIMatchTreeBuilderLeafInfoESaIS2_EE'/>
<fun r='_ZN4llvm28GIMatchTreeOpcodePartitioner17applyForPartitionEjRNS_18GIMatchTreeBuilderES2_'/>
<fun r='_ZNK4llvm28GIMatchTreeOpcodePartitioner20emitPartitionResultsERNS_11raw_ostreamE'/>
<fun r='_ZNK4llvm28GIMatchTreeOpcodePartitioner29generatePartitionSelectorCodeERNS_11raw_ostreamENS_9StringRefE'/>
<use f='llvm/llvm/utils/TableGen/GlobalISel/GIMatchTree.cpp' l='187' c='_ZN4llvm18GIMatchTreeBuilder23addPartitionersForInstrEj'/>
<size>112</size>
<fun r='_ZNK4llvm28GIMatchTreeOpcodePartitioner17emitPartitionNameERNS_11raw_ostreamEj'/>
<fun r='_ZN4llvm28GIMatchTreeOpcodePartitioner11repartitionERSt6vectorINS_26GIMatchTreeBuilderLeafInfoESaIS2_EE'/>
<fun r='_ZN4llvm28GIMatchTreeOpcodePartitioner17applyForPartitionEjRNS_18GIMatchTreeBuilderES2_'/>
<fun r='_ZNK4llvm28GIMatchTreeOpcodePartitioner20emitPartitionResultsERNS_11raw_ostreamE'/>
<fun r='_ZNK4llvm28GIMatchTreeOpcodePartitioner29generatePartitionSelectorCodeERNS_11raw_ostreamENS_9StringRefE'/>
