<dec f='llvm/llvm/lib/FileCheck/FileCheckImpl.h' l='769' type='static Expected&lt;std::unique_ptr&lt;ExpressionAST&gt; &gt; llvm::Pattern::parseNumericOperand(llvm::StringRef &amp; Expr, llvm::Pattern::AllowedOperand AO, bool ConstraintParsed, Optional&lt;size_t&gt; LineNumber, llvm::FileCheckPatternContext * Context, const llvm::SourceMgr &amp; SM)'/>
<def f='llvm/llvm/lib/FileCheck/FileCheck.cpp' l='536' ll='592' type='static Expected&lt;std::unique_ptr&lt;ExpressionAST&gt; &gt; llvm::Pattern::parseNumericOperand(llvm::StringRef &amp; Expr, llvm::Pattern::AllowedOperand AO, bool MaybeInvalidConstraint, Optional&lt;size_t&gt; LineNumber, llvm::FileCheckPatternContext * Context, const llvm::SourceMgr &amp; SM)'/>
<use f='llvm/llvm/lib/FileCheck/FileCheck.cpp' l='607' u='c' c='_ZN4llvm7Pattern14parseParenExprERNS_9StringRefENS_8OptionalImEEPNS_23FileCheckPatternContextERKNS_9SourceMgrE'/>
<use f='llvm/llvm/lib/FileCheck/FileCheck.cpp' l='662' u='c' c='_ZN4llvm7Pattern10parseBinopENS_9StringRefERS1_St10unique_ptrINS_13ExpressionASTESt14default_deleteIS4_EEbNS_8OptionalImEEPNS_23FileCheckPatternContextERKNS_9SourceMgrE'/>
<use f='llvm/llvm/lib/FileCheck/FileCheck.cpp' l='703' u='c' c='_ZN4llvm7Pattern13parseCallExprERNS_9StringRefES1_NS_8OptionalImEEPNS_23FileCheckPatternContextERKNS_9SourceMgrE'/>
<use f='llvm/llvm/lib/FileCheck/FileCheck.cpp' l='837' u='c' c='_ZN4llvm7Pattern29parseNumericSubstitutionBlockENS_9StringRefERNS_8OptionalIPNS_15NumericVariableEEEbNS2_ImEEPNS_23FileCheckPatternContextERKNS_9SourceMgrE'/>
<doc f='llvm/llvm/lib/FileCheck/FileCheckImpl.h' l='759'>/// Parses \p Expr for use of a numeric operand at line \p LineNumber, or
  /// before input is parsed if \p LineNumber is None. Accepts literal values,
  /// numeric variables and function calls, depending on the value of \p AO.
  /// \p MaybeInvalidConstraint indicates whether the text being parsed could
  /// be an invalid constraint. \p Context points to the class instance holding
  /// the live string and numeric variables. \returns the class representing
  /// that operand in the AST of the expression or an error holding a
  /// diagnostic against \p SM otherwise. If \p Expr starts with a &quot;(&quot; this
  /// function will attempt to parse a parenthesized expression.</doc>
