<dec f='llvm/polly/lib/External/isl/isl_scan.h' l='21' type='isl_stat isl_basic_set_scan(isl_basic_map * bset, struct isl_scan_callback * callback)'/>
<use f='llvm/polly/lib/External/isl/isl_point.c' l='537' u='c' c='isl_set_foreach_point'/>
<def f='llvm/polly/lib/External/isl/isl_scan.c' l='102' ll='223' type='isl_stat isl_basic_set_scan(isl_basic_map * bset, struct isl_scan_callback * callback)'/>
<use f='llvm/polly/lib/External/isl/isl_scan.c' l='240' u='c' c='isl_set_scan'/>
<use f='llvm/polly/lib/External/isl/isl_scan.c' l='264' u='c' c='isl_basic_set_count_upto'/>
<doc f='llvm/polly/lib/External/isl/isl_scan.c' l='84'>/* Look for all integer points in &quot;bset&quot;, which is assumed to be bounded,
 * and call callback-&gt;add on each of them.
 *
 * We first compute a reduced basis for the set and then scan
 * the set in the directions of this basis.
 * We basically perform a depth first search, where in each level i
 * we compute the range in the i-th basis vector direction, given
 * fixed values in the directions of the previous basis vector.
 * We then add an equality to the tableau fixing the value in the
 * direction of the current basis vector to each value in the range
 * in turn and then continue to the next level.
 *
 * The search is implemented iteratively.  &quot;level&quot; identifies the current
 * basis vector.  &quot;init&quot; is true if we want the first value at the current
 * level and false if we want the next value.
 * Solutions are added in the leaves of the search tree, i.e., after
 * we have fixed a value in each direction of the basis.
 */</doc>
