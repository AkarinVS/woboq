<def f='llvm/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp' l='1918' ll='1921' type='void llvm::slpvectorizer::BoUpSLP::eraseInstruction(llvm::Instruction * I, bool ReplaceOpsWithUndef = false)'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp' l='2520' u='c' c='_ZN4llvm13slpvectorizer7BoUpSLP17eraseInstructionsENS_8ArrayRefIPNS_5ValueEEE'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp' l='4993' u='c' c='_ZN4llvm13slpvectorizer7BoUpSLP13vectorizeTreeERNS_9MapVectorIPNS_5ValueENS_11SmallVectorIPNS_11InstructionELj2EEENS_8DenseMapIS4_jNS_12DenseMapInfoIS1236484'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp' l='5074' u='c' c='_ZN4llvm13slpvectorizer7BoUpSLP22optimizeGatherSequenceEv'/>
<doc f='llvm/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp' l='1912'>/// Removes an instruction from its block and eventually deletes it.
  /// It&apos;s like Instruction::eraseFromParent() except that the actual deletion
  /// is delayed until BoUpSLP is destructed.
  /// This is required to ensure that there are no incorrect collisions in the
  /// AliasCache, which can happen if a new instruction is allocated at the
  /// same address as a previously deleted instruction.</doc>
