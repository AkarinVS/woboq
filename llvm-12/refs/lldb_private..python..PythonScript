<def f='llvm/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h' l='741' ll='756'/>
<size>16</size>
<doc f='llvm/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.h' l='724'>// Sometimes the best way to interact with a python interpreter is
// to run some python code.   You construct a PythonScript with
// script string.   The script assigns some function to `_function_`
// and you get a C++ callable object that calls the python function.
//
// Example:
//
// const char script[] = R&quot;(
// def main(x, y):
//    ....
// )&quot;;
//
// Expected&lt;PythonObject&gt; cpp_foo_wrapper(PythonObject x, PythonObject y) {
//   // no need to synchronize access to this global, we already have the GIL
//   static PythonScript foo(script)
//   return  foo(x, y);
// }</doc>
<mbr r='lldb_private::python::PythonScript::script' o='0' t='const char *'/>
<mbr r='lldb_private::python::PythonScript::function' o='64' t='lldb_private::python::PythonCallable'/>
<fun r='_ZN12lldb_private6python12PythonScript4InitEv'/>
<fun r='_ZN12lldb_private6python12PythonScriptC1EPKc'/>
<fun r='_ZN12lldb_private6python12PythonScriptclEDpOT_'/>
<use f='llvm/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp' l='886' c='_ZNK12lldb_private6python14PythonCallable10GetArgInfoEv'/>
<use f='llvm/lldb/source/Plugins/ScriptInterpreter/Python/PythonDataObjects.cpp' l='1090' c='_ZNK12lldb_private6python15PythonException13ReadBacktraceB5cxx11Ev'/>
<size>16</size>
<fun r='_ZN12lldb_private6python12PythonScript4InitEv'/>
<use f='llvm/lldb/unittests/ScriptInterpreter/Python/PythonDataObjectsTests.cpp' l='792' c='_ZN37PythonDataObjectsTest_TestScript_Test8TestBodyEv'/>
<use f='llvm/lldb/unittests/ScriptInterpreter/Python/PythonDataObjectsTests.cpp' l='809' c='_ZN41PythonDataObjectsTest_TestExceptions_Test8TestBodyEv'/>
<use f='llvm/lldb/unittests/ScriptInterpreter/Python/PythonDataObjectsTests.cpp' l='829' c='_ZN41PythonDataObjectsTest_TestExceptions_Test8TestBodyEv'/>
<size>16</size>
