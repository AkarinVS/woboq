<def f='llvm/lldb/include/lldb/Symbol/ObjectFile.h' l='447' type='bool lldb_private::ObjectFile::AllowAssemblyEmulationUnwindPlans()'/>
<doc f='llvm/lldb/include/lldb/Symbol/ObjectFile.h' l='426'>/// Returns if the function bounds for symbols in this symbol file are
  /// likely accurate.
  ///
  /// The unwinder can emulate the instructions of functions to understand
  /// prologue/epilogue code sequences, where registers are spilled on the
  /// stack, etc.  This feature relies on having the correct start addresses
  /// of all functions.  If the ObjectFile has a way to tell that symbols have
  /// been stripped and there&apos;s no way to reconstruct start addresses (e.g.
  /// LC_FUNCTION_STARTS on Mach-O, or eh_frame unwind info), the ObjectFile
  /// should indicate that assembly emulation should not be used for this
  /// module.
  ///
  /// It is uncommon for this to return false.  An ObjectFile needs to be sure
  /// that symbol start addresses are unavailable before false is returned.
  /// If it is unclear, this should return true.
  ///
  /// \return
  ///     Returns true if assembly emulation should be used for this
  ///     module.
  ///     Only returns false if the ObjectFile is sure that symbol
  ///     addresses are insufficient for accurate assembly emulation.</doc>
<ovr f='llvm/lldb/source/Plugins/ObjectFile/Mach-O/ObjectFileMachO.cpp' l='6033' c='_ZN15ObjectFileMachO33AllowAssemblyEmulationUnwindPlansEv'/>
<use f='llvm/lldb/source/Symbol/UnwindTable.cpp' l='207' u='c' c='_ZN12lldb_private11UnwindTable36GetAllowAssemblyEmulationUnwindPlansEv'/>
