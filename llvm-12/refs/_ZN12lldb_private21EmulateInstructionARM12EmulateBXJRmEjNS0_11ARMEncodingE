<dec f='llvm/lldb/source/Plugins/Instruction/ARM/EmulateInstructionARM.h' l='354' type='bool lldb_private::EmulateInstructionARM::EmulateBXJRm(const uint32_t opcode, const lldb_private::EmulateInstructionARM::ARMEncoding encoding)'/>
<def f='llvm/lldb/source/Plugins/Instruction/ARM/EmulateInstructionARM.cpp' l='2218' ll='2267' type='bool lldb_private::EmulateInstructionARM::EmulateBXJRm(const uint32_t opcode, const lldb_private::EmulateInstructionARM::ARMEncoding encoding)'/>
<use f='llvm/lldb/source/Plugins/Instruction/ARM/EmulateInstructionARM.cpp' l='12918' u='a' c='_ZN12lldb_private21EmulateInstructionARM26GetARMOpcodeForInstructionEjj'/>
<use f='llvm/lldb/source/Plugins/Instruction/ARM/EmulateInstructionARM.cpp' l='13325' u='a' c='_ZN12lldb_private21EmulateInstructionARM28GetThumbOpcodeForInstructionEjj'/>
<doc f='llvm/lldb/source/Plugins/Instruction/ARM/EmulateInstructionARM.cpp' l='2211'>// Branch and Exchange Jazelle attempts to change to Jazelle state. If the
// attempt fails, it branches to an address and instruction set specified by a
// register as though it were a BX instruction.
//
// TODO: Emulate Jazelle architecture?
//       We currently assume that switching to Jazelle state fails, thus
//       treating BXJ as a BX operation.</doc>
<doc f='llvm/lldb/source/Plugins/Instruction/ARM/EmulateInstructionARM.h' l='353'>// A8.6.26 BXJ</doc>
