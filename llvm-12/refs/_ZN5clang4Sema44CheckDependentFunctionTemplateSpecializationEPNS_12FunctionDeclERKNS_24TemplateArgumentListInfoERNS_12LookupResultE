<dec f='llvm/clang/include/clang/Sema/Sema.h' l='7618' type='bool clang::Sema::CheckDependentFunctionTemplateSpecialization(clang::FunctionDecl * FD, const clang::TemplateArgumentListInfo &amp; ExplicitTemplateArgs, clang::LookupResult &amp; Previous)'/>
<use f='llvm/clang/lib/Sema/SemaDecl.cpp' l='9539' u='c' c='_ZN5clang4Sema23ActOnFunctionDeclaratorEPNS_5ScopeERNS_10DeclaratorEPNS_11DeclContextEPNS_14TypeSourceInfoERNS_12LookupResultEN4llvm15MutableArrayRefI5939088'/>
<def f='llvm/clang/lib/Sema/SemaTemplate.cpp' l='8863' ll='8903' type='bool clang::Sema::CheckDependentFunctionTemplateSpecialization(clang::FunctionDecl * FD, const clang::TemplateArgumentListInfo &amp; ExplicitTemplateArgs, clang::LookupResult &amp; Previous)'/>
<doc f='llvm/clang/lib/Sema/SemaTemplate.cpp' l='8848'>/// Perform semantic analysis for the given dependent function
/// template specialization.
///
/// The only possible way to get a dependent function template specialization
/// is with a friend declaration, like so:
///
/// \code
///   template \&lt;class T&gt; void foo(T);
///   template \&lt;class T&gt; class A {
///     friend void foo&lt;&gt;(T);
///   };
/// \endcode
///
/// There really isn&apos;t any useful analysis we can do here, so we
/// just store the information.</doc>
