<dec f='llvm/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h' l='392' type='llvm::Error llvm::CodeGenPassBuilder::addMachinePasses(llvm::CodeGenPassBuilder::AddMachinePass &amp; ) const'/>
<def f='llvm/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h' l='838' ll='938' type='llvm::Error llvm::CodeGenPassBuilder::addMachinePasses(llvm::CodeGenPassBuilder::AddMachinePass &amp; addPass) const'/>
<doc f='llvm/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h' l='390'>/// Add the complete, standard set of LLVM CodeGen passes.
  /// Fully developed targets will not generally override this.</doc>
<doc f='llvm/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h' l='823'>/// Add the complete set of target-independent postISel code generator passes.
///
/// This can be read as the standard order of major LLVM CodeGen stages. Stages
/// with nontrivial configuration or multiple passes are broken out below in
/// add%Stage routines.
///
/// Any CodeGenPassBuilder&lt;Derived&gt;::addXX routine may be overriden by the
/// Target. The addPre/Post methods with empty header implementations allow
/// injecting target-specific fixups just before or after major stages.
/// Additionally, targets have the flexibility to change pass order within a
/// stage by overriding default implementation of add%Stage routines below. Each
/// technique has maintainability tradeoffs because alternate pass orders are
/// not well supported. addPre/Post works better if the target pass is easily
/// tied to a common pass. But if it has subtle dependencies on multiple passes,
/// the target should override the stage instead.</doc>
