<dec f='llvm/llvm/include/llvm/Transforms/Utils/Cloning.h' l='231' type='llvm::InlineResult llvm::InlineFunction(llvm::CallBase &amp; CB, llvm::InlineFunctionInfo &amp; IFI, llvm::AAResults * CalleeAAR = nullptr, bool InsertLifetime = true, llvm::Function * ForwardVarArgsTo = nullptr)'/>
<doc f='llvm/llvm/include/llvm/Transforms/Utils/Cloning.h' l='212'>/// This function inlines the called function into the basic
/// block of the caller.  This returns false if it is not possible to inline
/// this call.  The program is still in a well defined state if this occurs
/// though.
///
/// Note that this only does one level of inlining.  For example, if the
/// instruction &apos;call B&apos; is inlined, and &apos;B&apos; calls &apos;C&apos;, then the call to &apos;C&apos; now
/// exists in the instruction stream.  Similarly this will inline a recursive
/// function by one level.
///
/// Note that while this routine is allowed to cleanup and optimize the
/// *inlined* code to minimize the actual inserted code, it must not delete
/// code in the caller as users of this routine may have pointers to
/// instructions in the caller that need to remain stable.
///
/// If ForwardVarArgsTo is passed, inlining a function with varargs is allowed
/// and all varargs at the callsite will be passed to any calls to
/// ForwardVarArgsTo. The caller of InlineFunction has to make sure any varargs
/// are only used by ForwardVarArgsTo.</doc>
<use f='llvm/llvm/lib/CodeGen/SafeStack.cpp' l='750' u='c' c='_ZN12_GLOBAL__N_19SafeStack23TryInlinePointerAddressEv'/>
<use f='llvm/llvm/lib/Transforms/Coroutines/CoroSplit.cpp' l='215' u='c' c='_ZL19replaceCoroEndAsyncPN4llvm14AnyCoroEndInstE'/>
<use f='llvm/llvm/lib/Transforms/Coroutines/CoroSplit.cpp' l='767' u='c' c='_ZN12_GLOBAL__N_110CoroCloner21deriveNewFramePointerEv'/>
<use f='llvm/llvm/lib/Transforms/Coroutines/CoroSplit.cpp' l='1556' u='c' c='_ZL19splitAsyncCoroutineRN4llvm8FunctionERNS_4coro5ShapeERNS_15SmallVectorImplIPS0_EE'/>
<use f='llvm/llvm/lib/Transforms/IPO/AlwaysInliner.cpp' l='84' u='c' c='_ZN4llvm17AlwaysInlinerPass3runERNS_6ModuleERNS_15AnalysisManagerIS1_JEEE'/>
<use f='llvm/llvm/lib/Transforms/IPO/Inliner.cpp' l='255' u='c' c='_ZL20inlineCallIfPossibleRN4llvm8CallBaseERNS_18InlineFunctionInfoERNS_8DenseMapIPNS_9ArrayTypeESt6vectorIPNS_10AllocaInstESaIS9_EENS_12DenseMapInfoIS6931155'/>
<use f='llvm/llvm/lib/Transforms/IPO/Inliner.cpp' l='830' u='c' c='_ZN4llvm11InlinerPass3runERNS_13LazyCallGraph3SCCERNS_15AnalysisManagerIS2_JRS1_EEES5_RNS_17CGSCCUpdateResultE'/>
<use f='llvm/llvm/lib/Transforms/IPO/PartialInlining.cpp' l='1425' u='c' c='_ZN12_GLOBAL__N_118PartialInlinerImpl16tryPartialInlineERNS0_14FunctionClonerE'/>
<use f='llvm/llvm/lib/Transforms/IPO/SampleProfile.cpp' l='1376' u='c' c='_ZN12_GLOBAL__N_119SampleProfileLoader18tryInlineCandidateERNS_15InlineCandidateEPN4llvm11SmallVectorIPNS3_8CallBaseELj8EEE'/>
<use f='llvm/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp' l='653' u='c' c='_ZL19InsertSafepointPollPN4llvm11InstructionERSt6vectorIPNS_8CallBaseESaIS4_EERKNS_17TargetLibraryInfoE'/>
<def f='llvm/llvm/lib/Transforms/Utils/InlineFunction.cpp' l='1661' ll='2538' type='llvm::InlineResult llvm::InlineFunction(llvm::CallBase &amp; CB, llvm::InlineFunctionInfo &amp; IFI, llvm::AAResults * CalleeAAR = nullptr, bool InsertLifetime = true, llvm::Function * ForwardVarArgsTo = nullptr)'/>
<doc f='llvm/llvm/lib/Transforms/Utils/InlineFunction.cpp' l='1653'>/// This function inlines the called function into the basic block of the
/// caller. This returns false if it is not possible to inline this call.
/// The program is still in a well defined state if this occurs though.
///
/// Note that this only does one level of inlining.  For example, if the
/// instruction &apos;call B&apos; is inlined, and &apos;B&apos; calls &apos;C&apos;, then the call to &apos;C&apos; now
/// exists in the instruction stream.  Similarly this will inline a recursive
/// function by one level.</doc>
