<dec f='llvm/llvm/include/llvm/Analysis/MemorySSAUpdater.h' l='206' type='llvm::MemoryUseOrDef * llvm::MemorySSAUpdater::createMemoryAccessBefore(llvm::Instruction * I, llvm::MemoryAccess * Definition, llvm::MemoryUseOrDef * InsertPt)'/>
<doc f='llvm/llvm/include/llvm/Analysis/MemorySSAUpdater.h' l='196'>/// Create a MemoryAccess in MemorySSA before or after an existing
  /// MemoryAccess.
  ///
  /// Returns the new MemoryAccess.
  /// This should be called when a memory instruction is created that is being
  /// used to replace an existing memory instruction. It will *not* create PHI
  /// nodes, or verify the clobbering definition.
  ///
  /// Note: If a MemoryAccess already exists for I, this function will make it
  /// inaccessible and it *must* have removeMemoryAccess called on it.</doc>
<def f='llvm/llvm/lib/Analysis/MemorySSAUpdater.cpp' l='1458' ll='1466' type='llvm::MemoryUseOrDef * llvm::MemorySSAUpdater::createMemoryAccessBefore(llvm::Instruction * I, llvm::MemoryAccess * Definition, llvm::MemoryUseOrDef * InsertPt)'/>
<use f='llvm/llvm/lib/CodeGen/InterleavedLoadCombinePass.cpp' l='1229' u='c' c='_ZN12_GLOBAL__N_126InterleavedLoadCombineImpl7combineERNSt7__cxx114listINS_10VectorInfoESaIS3_EEERN4llvm25OptimizationRemarkEmitterE'/>
<use f='llvm/llvm/lib/Transforms/Scalar/GVN.cpp' l='1628' u='c' c='_ZN4llvm3GVN22processAssumeIntrinsicEPNS_13IntrinsicInstE'/>
<use f='llvm/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp' l='494' u='c' c='_ZN4llvm13MemCpyOptPass20tryMergingIntoMemsetEPNS_11InstructionEPNS_5ValueES4_'/>
<use f='llvm/llvm/lib/Transforms/Scalar/MemCpyOptimizer.cpp' l='1213' u='c' c='_ZN4llvm13MemCpyOptPass29processMemSetMemCpyDependenceEPNS_10MemCpyInstEPNS_10MemSetInstE'/>
