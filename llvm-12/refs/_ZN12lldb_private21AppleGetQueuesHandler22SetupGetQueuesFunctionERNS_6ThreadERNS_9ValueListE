<dec f='llvm/lldb/source/Plugins/SystemRuntime/MacOSX/AppleGetQueuesHandler.h' l='93' type='lldb::addr_t lldb_private::AppleGetQueuesHandler::SetupGetQueuesFunction(lldb_private::Thread &amp; thread, lldb_private::ValueList &amp; get_queues_arglist)'/>
<def f='llvm/lldb/source/Plugins/SystemRuntime/MacOSX/AppleGetQueuesHandler.cpp' l='141' ll='214' type='lldb::addr_t lldb_private::AppleGetQueuesHandler::SetupGetQueuesFunction(lldb_private::Thread &amp; thread, lldb_private::ValueList &amp; get_queues_arglist)'/>
<use f='llvm/lldb/source/Plugins/SystemRuntime/MacOSX/AppleGetQueuesHandler.cpp' l='314' u='c' c='_ZN12lldb_private21AppleGetQueuesHandler16GetCurrentQueuesERNS_6ThreadEmmRNS_6StatusE'/>
<doc f='llvm/lldb/source/Plugins/SystemRuntime/MacOSX/AppleGetQueuesHandler.cpp' l='115'>// Construct a CompilerType for the structure that
// g_get_current_queues_function_code will return by value so we can extract
// the fields after performing the function call. i.e. we are getting this
// struct returned to us:
//
//    struct get_current_queues_return_values
//    {
//        introspection_dispatch_queue_info_t *queues_buffer;
//        uint64_t queues_buffer_size;
//        uint64_t count;
//    };

// Compile our __lldb_backtrace_recording_get_current_queues() function (from
// the source above in g_get_current_queues_function_code) if we don&apos;t find
// that function in the inferior already with USE_BUILTIN_FUNCTION defined.
// (e.g. this would be the case for testing.)
//
// Insert the __lldb_backtrace_recording_get_current_queues into the inferior
// process if needed.
//
// Write the get_queues_arglist into the inferior&apos;s memory space to prepare for
// the call.
//
// Returns the address of the arguments written down in the inferior process,
// which can be used to make the function call.</doc>
