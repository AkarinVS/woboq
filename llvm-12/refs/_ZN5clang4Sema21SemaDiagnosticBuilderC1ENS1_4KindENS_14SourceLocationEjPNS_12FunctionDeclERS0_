<dec f='llvm/clang/include/clang/Sema/Sema.h' l='1646' type='void clang::Sema::SemaDiagnosticBuilder::SemaDiagnosticBuilder(clang::Sema::SemaDiagnosticBuilder::Kind K, clang::SourceLocation Loc, unsigned int DiagID, clang::FunctionDecl * Fn, clang::Sema &amp; S)'/>
<def f='llvm/clang/lib/Sema/Sema.cpp' l='1697' ll='1717' type='void clang::Sema::SemaDiagnosticBuilder::SemaDiagnosticBuilder(clang::Sema::SemaDiagnosticBuilder::Kind K, clang::SourceLocation Loc, unsigned int DiagID, clang::FunctionDecl * Fn, clang::Sema &amp; S)'/>
<use f='llvm/clang/lib/Sema/Sema.cpp' l='1757' u='c' c='_ZN5clang4Sema10targetDiagENS_14SourceLocationEjPNS_12FunctionDeclE'/>
<use f='llvm/clang/lib/Sema/Sema.cpp' l='1773' u='c' c='_ZN5clang4Sema4DiagENS_14SourceLocationEjb'/>
<doc f='llvm/clang/lib/Sema/Sema.cpp' l='1673'>// In CUDA, there are some constructs which may appear in semantically-valid
// code, but trigger errors if we ever generate code for the function in which
// they appear.  Essentially every construct you&apos;re not allowed to use on the
// device falls into this category, because you are allowed to use these
// constructs in a __host__ __device__ function, but only if that function is
// never codegen&apos;ed on the device.
//
// To handle semantic checking for these constructs, we keep track of the set of
// functions we know will be emitted, either because we could tell a priori that
// they would be emitted, or because they were transitively called by a
// known-emitted function.
//
// We also keep a partial call graph of which not-known-emitted functions call
// which other not-known-emitted functions.
//
// When we see something which is illegal if the current function is emitted
// (usually by way of CUDADiagIfDeviceCode, CUDADiagIfHostCode, or
// CheckCUDACall), we first check if the current function is known-emitted.  If
// so, we immediately output the diagnostic.
//
// Otherwise, we &quot;defer&quot; the diagnostic.  It sits in Sema::DeviceDeferredDiags
// until we discover that the function is known-emitted, at which point we take
// it out of this map and emit the diagnostic.</doc>
<use f='llvm/clang/lib/Sema/SemaCUDA.cpp' l='668' u='c' c='_ZN5clang4Sema20CUDADiagIfDeviceCodeENS_14SourceLocationEj'/>
<use f='llvm/clang/lib/Sema/SemaCUDA.cpp' l='697' u='c' c='_ZN5clang4Sema18CUDADiagIfHostCodeENS_14SourceLocationEj'/>
<use f='llvm/clang/lib/Sema/SemaCUDA.cpp' l='746' u='c' c='_ZN5clang4Sema13CheckCUDACallENS_14SourceLocationEPNS_12FunctionDeclE'/>
<use f='llvm/clang/lib/Sema/SemaCUDA.cpp' l='750' u='c' c='_ZN5clang4Sema13CheckCUDACallENS_14SourceLocationEPNS_12FunctionDeclE'/>
<use f='llvm/clang/lib/Sema/SemaCUDA.cpp' l='793' u='c' c='_ZN5clang4Sema22CUDACheckLambdaCaptureEPNS_13CXXMethodDeclERKNS_4sema7CaptureE'/>
<use f='llvm/clang/lib/Sema/SemaCUDA.cpp' l='797' u='c' c='_ZN5clang4Sema22CUDACheckLambdaCaptureEPNS_13CXXMethodDeclERKNS_4sema7CaptureE'/>
<use f='llvm/clang/lib/Sema/SemaOpenMP.cpp' l='1934' u='c' c='_ZN5clang4Sema22diagIfOpenMPDeviceCodeENS_14SourceLocationEjPNS_12FunctionDeclE'/>
<use f='llvm/clang/lib/Sema/SemaOpenMP.cpp' l='1958' u='c' c='_ZN5clang4Sema20diagIfOpenMPHostCodeENS_14SourceLocationEjPNS_12FunctionDeclE'/>
<use f='llvm/clang/lib/Sema/SemaSYCL.cpp' l='32' u='c' c='_ZN5clang4Sema20SYCLDiagIfDeviceCodeENS_14SourceLocationEj'/>
