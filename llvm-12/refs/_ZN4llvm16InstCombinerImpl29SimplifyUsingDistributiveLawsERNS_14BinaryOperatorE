<dec f='llvm/llvm/lib/Transforms/InstCombine/InstCombineInternal.h' l='536' type='llvm::Value * llvm::InstCombinerImpl::SimplifyUsingDistributiveLaws(llvm::BinaryOperator &amp; I)'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp' l='1294' u='c' c='_ZN4llvm16InstCombinerImpl8visitAddERNS_14BinaryOperatorE'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineAddSub.cpp' l='1774' u='c' c='_ZN4llvm16InstCombinerImpl8visitSubERNS_14BinaryOperatorE'/>
<doc f='llvm/llvm/lib/Transforms/InstCombine/InstCombineInternal.h' l='529'>/// Tries to simplify binary operations which some other binary
  /// operation distributes over.
  ///
  /// It does this by either by factorizing out common terms (eg &quot;(A*B)+(A*C)&quot;
  /// -&gt; &quot;A*(B+C)&quot;) or expanding out if this results in simplifications (eg: &quot;A
  /// &amp; (B | C) -&gt; (A&amp;B) | (A&amp;C)&quot; if this is a win).  Returns the simplified
  /// value, or null if it didn&apos;t simplify.</doc>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp' l='1723' u='c' c='_ZN4llvm16InstCombinerImpl8visitAndERNS_14BinaryOperatorE'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp' l='2578' u='c' c='_ZN4llvm16InstCombinerImpl7visitOrERNS_14BinaryOperatorE'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp' l='3160' u='c' c='_ZN4llvm16InstCombinerImpl8visitXorERNS_14BinaryOperatorE'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp' l='153' u='c' c='_ZN4llvm16InstCombinerImpl8visitMulERNS_14BinaryOperatorE'/>
<def f='llvm/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp' l='703' ll='819' type='llvm::Value * llvm::InstCombinerImpl::SimplifyUsingDistributiveLaws(llvm::BinaryOperator &amp; I)'/>
<doc f='llvm/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp' l='698'>/// This tries to simplify binary operations which some other binary operation
/// distributes over either by factorizing out common terms
/// (eg &quot;(A*B)+(A*C)&quot; -&gt; &quot;A*(B+C)&quot;) or expanding out if this results in
/// simplifications (eg: &quot;A &amp; (B | C) -&gt; (A&amp;B) | (A&amp;C)&quot; if this is a win).
/// Returns the simplified value, or null if it didn&apos;t simplify.</doc>
