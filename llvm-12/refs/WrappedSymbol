<def f='llvm/lld/ELF/Driver.cpp' l='1892' ll='1896'/>
<use f='llvm/lld/ELF/Driver.cpp' l='1903' c='_ZL17addWrappedSymbolsRN4llvm3opt12InputArgListE'/>
<use f='llvm/lld/ELF/Driver.cpp' l='1904' c='_ZL17addWrappedSymbolsRN4llvm3opt12InputArgListE'/>
<use f='llvm/lld/ELF/Driver.cpp' l='1944' c='_ZL15redirectSymbolsN4llvm8ArrayRefI13WrappedSymbolEE'/>
<use f='llvm/lld/ELF/Driver.cpp' l='1947' c='_ZL15redirectSymbolsN4llvm8ArrayRefI13WrappedSymbolEE'/>
<use f='llvm/lld/ELF/Driver.cpp' l='1989' c='_ZL15redirectSymbolsN4llvm8ArrayRefI13WrappedSymbolEE'/>
<use f='llvm/lld/ELF/Driver.cpp' l='2171' c='_ZN3lld3elf12LinkerDriver4linkERN4llvm3opt12InputArgListE'/>
<size>24</size>
<doc f='llvm/lld/ELF/Driver.cpp' l='1884'>// The --wrap option is a feature to rename symbols so that you can write
// wrappers for existing functions. If you pass `-wrap=foo`, all
// occurrences of symbol `foo` are resolved to `__wrap_foo` (so, you are
// expected to write `__wrap_foo` function as a wrapper). The original
// symbol becomes accessible as `__real_foo`, so you can call that from your
// wrapper.
//
// This data structure is instantiated for each -wrap option.</doc>
