<dec f='llvm/llvm/include/llvm/Analysis/MemorySSAUpdater.h' l='105' type='void llvm::MemorySSAUpdater::updateForClonedLoop(const llvm::LoopBlocksRPO &amp; LoopBlocks, ArrayRef&lt;llvm::BasicBlock *&gt; ExitBlocks, const llvm::ValueToValueMapTy &amp; VM, bool IgnoreIncomingWithNoClones = false)'/>
<doc f='llvm/llvm/include/llvm/Analysis/MemorySSAUpdater.h' l='101'>/// Update MemorySSA after a loop was cloned, given the blocks in RPO order,
  /// the exit blocks and a 1:1 mapping of all blocks and instructions
  /// cloned. This involves duplicating all defs and uses in the cloned blocks
  /// Updating phi nodes in exit block successors is done separately.</doc>
<def f='llvm/llvm/lib/Analysis/MemorySSAUpdater.cpp' l='680' ll='758' type='void llvm::MemorySSAUpdater::updateForClonedLoop(const llvm::LoopBlocksRPO &amp; LoopBlocks, ArrayRef&lt;llvm::BasicBlock *&gt; ExitBlocks, const llvm::ValueToValueMapTy &amp; VMap, bool IgnoreIncomingWithNoClones = false)'/>
<use f='llvm/llvm/lib/Transforms/Scalar/LoopUnswitch.cpp' l='1556' u='c' c='_ZN12_GLOBAL__N_112LoopUnswitch27unswitchNontrivialConditionEPN4llvm5ValueEPNS1_8ConstantEPNS1_4LoopEPNS1_11InstructionENS1_8ArrayRefIS9_EE'/>
<use f='llvm/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp' l='2162' u='c' c='_ZL28unswitchNontrivialInvariantsRN4llvm4LoopERNS_11InstructionENS_8ArrayRefIPNS_5ValueEEERNS_15SmallVectorImplIPNS_10BasicBlockEEERNS_13DominatorTree1049984'/>
<use f='llvm/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp' l='2227' u='c' c='_ZL28unswitchNontrivialInvariantsRN4llvm4LoopERNS_11InstructionENS_8ArrayRefIPNS_5ValueEEERNS_15SmallVectorImplIPNS_10BasicBlockEEERNS_13DominatorTree1049984'/>
