<dec f='llvm/lldb/include/lldb/Target/RegisterContextUnwind.h' l='169' type='bool lldb_private::RegisterContextUnwind::TryFallbackUnwindPlan()'/>
<use f='llvm/lldb/source/Target/RegisterContextUnwind.cpp' l='243' u='c' c='_ZN12lldb_private21RegisterContextUnwind21InitializeZerothFrameEv'/>
<use f='llvm/lldb/source/Target/RegisterContextUnwind.cpp' l='415' u='c' c='_ZN12lldb_private21RegisterContextUnwind24InitializeNonZerothFrameEv'/>
<use f='llvm/lldb/source/Target/RegisterContextUnwind.cpp' l='581' u='c' c='_ZN12lldb_private21RegisterContextUnwind24InitializeNonZerothFrameEv'/>
<def f='llvm/lldb/source/Target/RegisterContextUnwind.cpp' l='1582' ll='1710' type='bool lldb_private::RegisterContextUnwind::TryFallbackUnwindPlan()'/>
<doc f='llvm/lldb/source/Target/RegisterContextUnwind.cpp' l='1565'>// TryFallbackUnwindPlan() -- this method is a little tricky.
//
// When this is called, the frame above -- the caller frame, the &quot;previous&quot;
// frame -- is invalid or bad.
//
// Instead of stopping the stack walk here, we&apos;ll try a different UnwindPlan
// and see if we can get a valid frame above us.
//
// This most often happens when an unwind plan based on assembly instruction
// inspection is not correct -- mostly with hand-written assembly functions or
// functions where the stack frame is set up &quot;out of band&quot;, e.g. the kernel
// saved the register context and then called an asynchronous trap handler like
// _sigtramp.
//
// Often in these cases, if we just do a dumb stack walk we&apos;ll get past this
// tricky frame and our usual techniques can continue to be used.</doc>
<doc f='llvm/lldb/include/lldb/Target/RegisterContextUnwind.h' l='159'>/// If the unwind has to the caller frame has failed, try something else
  ///
  /// If lldb is using an assembly language based UnwindPlan for a frame and
  /// the unwind to the caller frame fails, try falling back to a generic
  /// UnwindPlan (architecture default unwindplan) to see if that might work
  /// better.  This is mostly helping to work around problems where the
  /// assembly language inspection fails on hand-written assembly code.
  ///
  /// \return
  ///     Returns true if a fallback unwindplan was found &amp; was installed.</doc>
<use f='llvm/lldb/source/Target/UnwindLLDB.cpp' l='153' u='c' c='_ZN12lldb_private10UnwindLLDB15GetOneMoreFrameEPNS_3ABIE'/>
<use f='llvm/lldb/source/Target/UnwindLLDB.cpp' l='172' u='c' c='_ZN12lldb_private10UnwindLLDB15GetOneMoreFrameEPNS_3ABIE'/>
<use f='llvm/lldb/source/Target/UnwindLLDB.cpp' l='192' u='c' c='_ZN12lldb_private10UnwindLLDB15GetOneMoreFrameEPNS_3ABIE'/>
<use f='llvm/lldb/source/Target/UnwindLLDB.cpp' l='217' u='c' c='_ZN12lldb_private10UnwindLLDB15GetOneMoreFrameEPNS_3ABIE'/>
<use f='llvm/lldb/source/Target/UnwindLLDB.cpp' l='220' u='c' c='_ZN12lldb_private10UnwindLLDB15GetOneMoreFrameEPNS_3ABIE'/>
<use f='llvm/lldb/source/Target/UnwindLLDB.cpp' l='248' u='c' c='_ZN12lldb_private10UnwindLLDB15GetOneMoreFrameEPNS_3ABIE'/>
<use f='llvm/lldb/source/Target/UnwindLLDB.cpp' l='267' u='c' c='_ZN12lldb_private10UnwindLLDB15GetOneMoreFrameEPNS_3ABIE'/>
<use f='llvm/lldb/source/Target/UnwindLLDB.cpp' l='352' u='c' c='_ZN12lldb_private10UnwindLLDB15AddOneMoreFrameEPNS_3ABIE'/>
