<def f='llvm/lldb/include/lldb/Core/Architecture.h' l='86' ll='89' type='lldb::addr_t lldb_private::Architecture::GetOpcodeLoadAddress(lldb::addr_t addr, lldb_private::AddressClass addr_class = AddressClass::eInvalid) const'/>
<doc f='llvm/lldb/include/lldb/Core/Architecture.h' l='75'>/// Get \a load_addr as an opcode for this target.
  ///
  /// Take \a load_addr and potentially strip any address bits that are
  /// needed to make the address point to an opcode. For ARM this can
  /// clear bit zero (if it already isn&apos;t) if \a load_addr is a
  /// thumb function and load_addr is in code.
  /// If \a addr_class is set to AddressClass::eInvalid, then the address
  /// adjustment will always happen. If it is set to an address class
  /// that doesn&apos;t have code in it, LLDB_INVALID_ADDRESS will be
  /// returned.</doc>
<ovr f='llvm/lldb/source/Plugins/Architecture/Arm/ArchitectureArm.cpp' l='150' c='_ZNK12lldb_private15ArchitectureArm20GetOpcodeLoadAddressEmNS_12AddressClassE'/>
<ovr f='llvm/lldb/source/Plugins/Architecture/Mips/ArchitectureMips.cpp' l='67' c='_ZNK12lldb_private16ArchitectureMips20GetOpcodeLoadAddressEmNS_12AddressClassE'/>
<use f='llvm/lldb/source/Target/Target.cpp' l='2509' u='c' c='_ZNK12lldb_private6Target20GetOpcodeLoadAddressEmNS_12AddressClassE'/>
