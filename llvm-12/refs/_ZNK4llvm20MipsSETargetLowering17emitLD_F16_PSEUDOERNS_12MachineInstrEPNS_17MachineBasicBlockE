<dec f='llvm/llvm/lib/Target/Mips/MipsSEISelLowering.h' l='126' type='llvm::MachineBasicBlock * llvm::MipsSETargetLowering::emitLD_F16_PSEUDO(llvm::MachineInstr &amp; MI, llvm::MachineBasicBlock * BB) const'/>
<use f='llvm/llvm/lib/Target/Mips/MipsSEISelLowering.cpp' l='1131' u='c' c='_ZNK4llvm20MipsSETargetLowering27EmitInstrWithCustomInserterERNS_12MachineInstrEPNS_17MachineBasicBlockE'/>
<def f='llvm/llvm/lib/Target/Mips/MipsSEISelLowering.cpp' l='3562' ll='3597' type='llvm::MachineBasicBlock * llvm::MipsSETargetLowering::emitLD_F16_PSEUDO(llvm::MachineInstr &amp; MI, llvm::MachineBasicBlock * BB) const'/>
<doc f='llvm/llvm/lib/Target/Mips/MipsSEISelLowering.cpp' l='3549'>// Emit the LD_F16_PSEDUO instruction to load a f16 value into an MSA register.
//
// LD_F16 MSA128F16:$wd, mem_simm10:$addr
// =&gt;
//  lh $rtemp, $addr
//  fill.h $wd, $rtemp
//
// Safety: We can&apos;t use ld.h &amp; co as they over-read from the source.
// Additionally, if the address is not modulo 16, 2 cases can occur:
//  a) Segmentation fault as the load instruction reads from a memory page
//     memory it&apos;s not supposed to.
//  b) The load crosses an implementation specific boundary, requiring OS
//     intervention.</doc>
<doc f='llvm/llvm/lib/Target/Mips/MipsSEISelLowering.h' l='125'>/// Emit the FILL_FW pseudo instruction</doc>
