<dec f='llvm/llvm/include/llvm/Analysis/ScalarEvolution.h' l='1746' type='llvm::ScalarEvolution::ExitLimit llvm::ScalarEvolution::howManyLessThans(const llvm::SCEV * LHS, const llvm::SCEV * RHS, const llvm::Loop * L, bool isSigned, bool ControlsExit, bool AllowPredicates = false)'/>
<doc f='llvm/llvm/include/llvm/Analysis/ScalarEvolution.h' l='1734'>/// Return the number of times an exit condition containing the specified
  /// less-than comparison will execute.  If not computable, return
  /// CouldNotCompute.
  ///
  /// \p isSigned specifies whether the less-than is signed.
  ///
  /// \p ControlsExit is true when the LHS &lt; RHS condition directly controls
  /// the branch (loops exits only if condition is true). In this case, we can
  /// use NoWrapFlags to skip overflow checks.
  ///
  /// If \p AllowPredicates is set, this call will try to use a minimal set of
  /// SCEV predicates in order to return an exact answer.</doc>
<use f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='7737' u='c' c='_ZN4llvm15ScalarEvolution24computeExitLimitFromICmpEPKNS_4LoopEPNS_8ICmpInstEbbb'/>
<def f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='11122' ll='11267' type='ScalarEvolution::ExitLimit llvm::ScalarEvolution::howManyLessThans(const llvm::SCEV * LHS, const llvm::SCEV * RHS, const llvm::Loop * L, bool IsSigned, bool ControlsExit, bool AllowPredicates = false)'/>
