<dec f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='752' type='void llvm::InnerLoopVectorizer::createInductionResumeValues(llvm::Loop * L, llvm::Value * VectorTripCount, std::pair&lt;BasicBlock *, Value *&gt; AdditionalBypass = {nullptr, nullptr})'/>
<def f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='3383' ll='3450' type='void llvm::InnerLoopVectorizer::createInductionResumeValues(llvm::Loop * L, llvm::Value * VectorTripCount, std::pair&lt;BasicBlock *, Value *&gt; AdditionalBypass = {nullptr, nullptr})'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='3591' u='c' c='_ZN4llvm19InnerLoopVectorizer28createVectorizedLoopSkeletonEv'/>
<use f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='8072' u='c' c='_ZN4llvm30EpilogueVectorizerEpilogueLoop36createEpilogueVectorizedLoopSkeletonEv'/>
<doc f='llvm/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp' l='745'>/// Create new phi nodes for the induction variables to resume iteration count
  /// in the scalar epilogue, from where the vectorized loop left off (given by
  /// \p VectorTripCount).
  /// In cases where the loop skeleton is more complicated (eg. epilogue
  /// vectorization) and the resume values can come from an additional bypass
  /// block, the \p AdditionalBypass pair provides information about the bypass
  /// block and the end value on the edge from bypass to this loop.</doc>
