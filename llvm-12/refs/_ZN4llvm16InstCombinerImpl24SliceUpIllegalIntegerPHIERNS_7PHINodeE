<dec f='llvm/llvm/lib/Transforms/InstCombine/InstCombineInternal.h' l='147' type='llvm::Instruction * llvm::InstCombinerImpl::SliceUpIllegalIntegerPHI(llvm::PHINode &amp; PN)'/>
<def f='llvm/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp' l='1054' ll='1226' type='llvm::Instruction * llvm::InstCombinerImpl::SliceUpIllegalIntegerPHI(llvm::PHINode &amp; FirstPhi)'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp' l='1457' u='c' c='_ZN4llvm16InstCombinerImpl12visitPHINodeERNS_7PHINodeE'/>
<doc f='llvm/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp' l='1046'>/// This is an integer PHI and we know that it has an illegal type: see if it is
/// only used by trunc or trunc(lshr) operations. If so, we split the PHI into
/// the various pieces being extracted. This sort of thing is introduced when
/// SROA promotes an aggregate to large integer values.
///
/// TODO: The user of the trunc may be an bitcast to float/double/vector or an
/// inttoptr.  We should produce new PHIs in the right type.
///</doc>
