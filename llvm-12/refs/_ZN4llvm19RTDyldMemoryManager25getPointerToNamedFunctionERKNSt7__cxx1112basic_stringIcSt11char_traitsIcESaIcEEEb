<dec f='llvm/llvm/include/llvm/ExecutionEngine/RTDyldMemoryManager.h' l='137' type='void * llvm::RTDyldMemoryManager::getPointerToNamedFunction(const std::string &amp; Name, bool AbortOnFailure = true)'/>
<doc f='llvm/llvm/include/llvm/ExecutionEngine/RTDyldMemoryManager.h' l='128'>/// This method returns the address of the specified function. As such it is
  /// only useful for resolving library symbols, not code generated symbols.
  ///
  /// If \p AbortOnFailure is false and no function with the given name is
  /// found, this function returns a null pointer. Otherwise, it prints a
  /// message to stderr and aborts.
  ///
  /// This function is deprecated for memory managers to be used with
  /// MCJIT or RuntimeDyld.  Use getSymbolAddress instead.</doc>
<ovr f='llvm/lldb/source/Expression/IRExecutionUnit.cpp' l='1060' c='_ZN12lldb_private15IRExecutionUnit13MemoryManager25getPointerToNamedFunctionERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb'/>
<def f='llvm/llvm/lib/ExecutionEngine/RuntimeDyld/RTDyldMemoryManager.cpp' l='282' ll='291' type='void * llvm::RTDyldMemoryManager::getPointerToNamedFunction(const std::string &amp; Name, bool AbortOnFailure = true)'/>
<ovr f='llvm/llvm/tools/llvm-rtdyld/llvm-rtdyld.cpp' l='213' c='_ZN20TrivialMemoryManager25getPointerToNamedFunctionERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb'/>
