<dec f='llvm/lldb/include/lldb/Target/Target.h' l='816' type='lldb::addr_t lldb_private::Target::GetOpcodeLoadAddress(lldb::addr_t load_addr, lldb_private::AddressClass addr_class = AddressClass::eInvalid) const'/>
<doc f='llvm/lldb/include/lldb/Target/Target.h' l='805'>/// Get \a load_addr as an opcode for this target.
  ///
  /// Take \a load_addr and potentially strip any address bits that are
  /// needed to make the address point to an opcode. For ARM this can
  /// clear bit zero (if it already isn&apos;t) if \a load_addr is a
  /// thumb function and load_addr is in code.
  /// If \a addr_class is set to AddressClass::eInvalid, then the address
  /// adjustment will always happen. If it is set to an address class
  /// that doesn&apos;t have code in it, LLDB_INVALID_ADDRESS will be
  /// returned.</doc>
<use f='llvm/lldb/source/Core/Address.cpp' l='373' u='c' c='_ZNK12lldb_private7Address20GetOpcodeLoadAddressEPNS_6TargetENS_12AddressClassE'/>
<use f='llvm/lldb/source/Core/Address.cpp' l='385' u='c' c='_ZN12lldb_private7Address20SetOpcodeLoadAddressEmPNS_6TargetENS_12AddressClassEb'/>
<use f='llvm/lldb/source/Target/RegisterContext.cpp' l='131' u='c' c='_ZN12lldb_private15RegisterContext5GetPCEm'/>
<def f='llvm/lldb/source/Target/Target.cpp' l='2506' ll='2511' type='lldb::addr_t lldb_private::Target::GetOpcodeLoadAddress(lldb::addr_t load_addr, lldb_private::AddressClass addr_class = AddressClass::eInvalid) const'/>
<use f='llvm/lldb/source/Target/ThreadPlanRunToAddress.cpp' l='39' u='c' c='_ZN12lldb_private22ThreadPlanRunToAddressC1ERNS_6ThreadEmb'/>
<use f='llvm/lldb/source/Target/ThreadPlanRunToAddress.cpp' l='54' u='c' c='_ZN12lldb_private22ThreadPlanRunToAddressC1ERNS_6ThreadERKSt6vectorImSaImEEb'/>
