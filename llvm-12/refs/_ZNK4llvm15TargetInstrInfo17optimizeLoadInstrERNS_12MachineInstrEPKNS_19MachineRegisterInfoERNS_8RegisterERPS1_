<def f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='1525' ll='1530' type='llvm::MachineInstr * llvm::TargetInstrInfo::optimizeLoadInstr(llvm::MachineInstr &amp; MI, const llvm::MachineRegisterInfo * MRI, llvm::Register &amp; FoldAsLoadDefReg, llvm::MachineInstr *&amp; DefMI) const'/>
<doc f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='1518'>/// Try to remove the load by folding it to a register operand at the use.
  /// We fold the load instructions if and only if the
  /// def and use are in the same BB. We only look at one load and see
  /// whether it can be folded into MI. FoldAsLoadDefReg is the virtual register
  /// defined by the load we are trying to fold. DefMI returns the machine
  /// instruction that defines FoldAsLoadDefReg, and the function returns
  /// the machine instruction generated due to folding.</doc>
<use f='llvm/llvm/lib/CodeGen/PeepholeOptimizer.cpp' l='1770' u='c' c='_ZN12_GLOBAL__N_117PeepholeOptimizer20runOnMachineFunctionERN4llvm15MachineFunctionE'/>
<ovr f='llvm/llvm/lib/Target/X86/X86InstrInfo.cpp' l='4417' c='_ZNK4llvm12X86InstrInfo17optimizeLoadInstrERNS_12MachineInstrEPKNS_19MachineRegisterInfoERNS_8RegisterERPS1_'/>
