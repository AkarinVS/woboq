<dec f='llvm/clang/include/clang/Parse/Parser.h' l='3045' type='bool clang::Parser::ParseUnqualifiedIdTemplateId(clang::CXXScopeSpec &amp; SS, clang::ParsedType ObjectType, bool ObjectHadErrors, clang::SourceLocation TemplateKWLoc, clang::IdentifierInfo * Name, clang::SourceLocation NameLoc, bool EnteringContext, clang::UnqualifiedId &amp; Id, bool AssumeTemplateId)'/>
<use f='llvm/clang/lib/Parse/ParseExprCXX.cpp' l='1807' u='c' c='_ZN5clang6Parser24ParseCXXPseudoDestructorEPNS_4ExprENS_14SourceLocationENS_3tok9TokenKindERNS_12CXXScopeSpecENS_9OpaquePtrINS_8QualTypeEEE'/>
<def f='llvm/clang/lib/Parse/ParseExprCXX.cpp' l='2334' ll='2487' type='bool clang::Parser::ParseUnqualifiedIdTemplateId(clang::CXXScopeSpec &amp; SS, clang::ParsedType ObjectType, bool ObjectHadErrors, clang::SourceLocation TemplateKWLoc, clang::IdentifierInfo * Name, clang::SourceLocation NameLoc, bool EnteringContext, clang::UnqualifiedId &amp; Id, bool AssumeTemplateId)'/>
<use f='llvm/clang/lib/Parse/ParseExprCXX.cpp' l='2826' u='c' c='_ZN5clang6Parser18ParseUnqualifiedIdERNS_12CXXScopeSpecENS_9OpaquePtrINS_8QualTypeEEEbbbbbPNS_14SourceLocationERNS_13UnqualifiedIdE'/>
<use f='llvm/clang/lib/Parse/ParseExprCXX.cpp' l='2912' u='c' c='_ZN5clang6Parser18ParseUnqualifiedIdERNS_12CXXScopeSpecENS_9OpaquePtrINS_8QualTypeEEEbbbbbPNS_14SourceLocationERNS_13UnqualifiedIdE'/>
<use f='llvm/clang/lib/Parse/ParseExprCXX.cpp' l='3008' u='c' c='_ZN5clang6Parser18ParseUnqualifiedIdERNS_12CXXScopeSpecENS_9OpaquePtrINS_8QualTypeEEEbbbbbPNS_14SourceLocationERNS_13UnqualifiedIdE'/>
<doc f='llvm/clang/lib/Parse/ParseExprCXX.cpp' l='2299'>/// Finish parsing a C++ unqualified-id that is a template-id of
/// some form.
///
/// This routine is invoked when a &apos;&lt;&apos; is encountered after an identifier or
/// operator-function-id is parsed by \c ParseUnqualifiedId() to determine
/// whether the unqualified-id is actually a template-id. This routine will
/// then parse the template arguments and form the appropriate template-id to
/// return to the caller.
///
/// \param SS the nested-name-specifier that precedes this template-id, if
/// we&apos;re actually parsing a qualified-id.
///
/// \param ObjectType if this unqualified-id occurs within a member access
/// expression, the type of the base object whose member is being accessed.
///
/// \param ObjectHadErrors this unqualified-id occurs within a member access
/// expression, indicates whether the original subexpressions had any errors.
///
/// \param Name for constructor and destructor names, this is the actual
/// identifier that may be a template-name.
///
/// \param NameLoc the location of the class-name in a constructor or
/// destructor.
///
/// \param EnteringContext whether we&apos;re entering the scope of the
/// nested-name-specifier.
///
/// \param Id as input, describes the template-name or operator-function-id
/// that precedes the &apos;&lt;&apos;. If template arguments were parsed successfully,
/// will be updated with the template-id.
///
/// \param AssumeTemplateId When true, this routine will assume that the name
/// refers to a template without performing name lookup to verify.
///
/// \returns true if a parse error occurred, false otherwise.</doc>
