<dec f='llvm/polly/lib/External/isl/include/isl/map.h' l='690' type='isl_map * isl_map_transitive_closure(isl_map * map, isl_bool * exact)'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2613' u='c' c='test_closure'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2628' u='c' c='test_closure'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2642' u='c' c='test_closure'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2663' u='c' c='test_closure'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2689' u='c' c='test_closure'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2705' u='c' c='test_closure'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2730' u='c' c='test_closure'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2739' u='c' c='test_closure'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2749' u='c' c='test_closure'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2766' u='c' c='test_closure'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2772' u='c' c='test_closure'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2785' u='c' c='test_closure'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2794' u='c' c='test_closure'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2822' u='c' c='test_closure'/>
<use f='llvm/polly/lib/External/isl/isl_transitive_closure.c' l='1178' u='c' c='compute_incremental'/>
<use f='llvm/polly/lib/External/isl/isl_transitive_closure.c' l='1554' u='c' c='floyd_warshall_iterate'/>
<def f='llvm/polly/lib/External/isl/isl_transitive_closure.c' l='2557' ll='2588' type='isl_map * isl_map_transitive_closure(isl_map * map, isl_bool * exact)'/>
<doc f='llvm/polly/lib/External/isl/isl_transitive_closure.c' l='2551'>/* Compute the transitive closure  of &quot;map&quot;, or an overapproximation.
 * If the result is exact, then *exact is set to 1.
 * Simply use map_power to compute the powers of map, but tell
 * it to project out the lengths of the paths instead of equating
 * the length to a parameter.
 */</doc>
