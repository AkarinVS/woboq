<dec f='include/linux/perf_event.h' l='566' type='__u16'/>
<offset>400</offset>
<doc f='include/linux/perf_event.h' l='542'>/*
	 * If cap_usr_time the below fields can be used to compute the time
	 * delta since time_enabled (in ns) using rdtsc or similar.
	 *
	 *   u64 quot, rem;
	 *   u64 delta;
	 *
	 *   quot = (cyc &gt;&gt; time_shift);
	 *   rem = cyc &amp; (((u64)1 &lt;&lt; time_shift) - 1);
	 *   delta = time_offset + quot * time_mult +
	 *              ((rem * time_mult) &gt;&gt; time_shift);
	 *
	 * Where time_offset,time_mult,time_shift and cyc are read in the
	 * seqcount loop described above. This delta can then be added to
	 * enabled and possible running (if index), improving the scaling:
	 *
	 *   enabled += delta;
	 *   if (index)
	 *     running += delta;
	 *
	 *   quot = count / running;
	 *   rem  = count % running;
	 *   count = quot * enabled + (rem * enabled) / running;
	 */</doc>
<dec f='include/perfmon/perf_event.h' l='387' type='uint16_t'/>
<offset>400</offset>
