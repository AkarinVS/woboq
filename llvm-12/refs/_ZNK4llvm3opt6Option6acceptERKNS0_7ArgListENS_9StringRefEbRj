<dec f='llvm/llvm/include/llvm/Option/Option.h' l='220' type='llvm::opt::Arg * llvm::opt::Option::accept(const llvm::opt::ArgList &amp; Args, llvm::StringRef CurArg, bool GroupedShortOption, unsigned int &amp; Index) const'/>
<doc f='llvm/llvm/include/llvm/Option/Option.h' l='208'>/// accept - Potentially accept the current argument, returning a
  /// new Arg instance, or 0 if the option does not accept this
  /// argument (or the argument is missing values).
  ///
  /// If the option accepts the current argument, accept() sets
  /// Index to the position where argument parsing should resume
  /// (even if the argument is missing values).
  ///
  /// \p CurArg The argument to be matched. It may be shorter than the
  /// underlying storage to represent a Joined argument.
  /// \p GroupedShortOption If true, we are handling the fallback case of
  /// parsing a prefix of the current argument as a short option.</doc>
<use f='llvm/llvm/lib/Option/OptTable.cpp' l='363' u='c' c='_ZNK4llvm3opt8OptTable18parseOneArgGroupedERNS0_12InputArgListERj'/>
<use f='llvm/llvm/lib/Option/OptTable.cpp' l='379' u='c' c='_ZNK4llvm3opt8OptTable18parseOneArgGroupedERNS0_12InputArgListERj'/>
<use f='llvm/llvm/lib/Option/OptTable.cpp' l='434' u='c' c='_ZNK4llvm3opt8OptTable11ParseOneArgERKNS0_7ArgListERjjj'/>
<def f='llvm/llvm/lib/Option/Option.cpp' l='233' ll='291' type='llvm::opt::Arg * llvm::opt::Option::accept(const llvm::opt::ArgList &amp; Args, llvm::StringRef CurArg, bool GroupedShortOption, unsigned int &amp; Index) const'/>
