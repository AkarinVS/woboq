<dec f='llvm/polly/include/polly/ScheduleOptimizer.h' l='300' type='static bool ScheduleTreeOptimizer::isMatrMultPattern(isl::schedule_node Node, const polly::Dependences * D, polly::MatMulInfoTy &amp; MMI)'/>
<def f='llvm/polly/lib/Transform/ScheduleOptimizer.cpp' l='1310' ll='1327' type='static bool ScheduleTreeOptimizer::isMatrMultPattern(isl::schedule_node Node, const polly::Dependences * D, polly::MatMulInfoTy &amp; MMI)'/>
<use f='llvm/polly/lib/Transform/ScheduleOptimizer.cpp' l='1340' u='c' c='_ZN21ScheduleTreeOptimizer12optimizeBandEP17isl_schedule_nodePv'/>
<doc f='llvm/polly/include/polly/ScheduleOptimizer.h' l='280'>/// Check if this node contains a partial schedule that could
  ///        probably be optimized with analytical modeling.
  ///
  /// isMatrMultPattern tries to determine whether the following conditions
  /// are true:
  /// 1. the partial schedule contains only one statement.
  /// 2. there are exactly three input dimensions.
  /// 3. all memory accesses of the statement will have stride 0 or 1, if we
  ///    interchange loops (switch the variable used in the inner loop to
  ///    the outer loop).
  /// 4. all memory accesses of the statement except from the last one, are
  ///    read memory access and the last one is write memory access.
  /// 5. all subscripts of the last memory access of the statement don&apos;t
  ///    contain the variable used in the inner loop.
  /// If this is the case, we could try to use an approach that is similar to
  /// the one used to get close-to-peak performance of matrix multiplications.
  ///
  /// @param Node The node to check.
  /// @param D    The SCoP dependencies.
  /// @param MMI  Parameters of the matrix multiplication operands.</doc>
