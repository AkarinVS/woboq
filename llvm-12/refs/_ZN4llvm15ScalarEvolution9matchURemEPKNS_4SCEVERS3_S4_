<dec f='llvm/llvm/include/llvm/Analysis/ScalarEvolution.h' l='2022' type='bool llvm::ScalarEvolution::matchURem(const llvm::SCEV * Expr, const llvm::SCEV *&amp; LHS, const llvm::SCEV *&amp; RHS)'/>
<doc f='llvm/llvm/include/llvm/Analysis/ScalarEvolution.h' l='2020'>/// Try to match the pattern generated by getURemExpr(A, B). If successful,
  /// Assign A and B to LHS and RHS, respectively.</doc>
<use f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='1746' u='c' c='_ZN4llvm15ScalarEvolution17getZeroExtendExprEPKNS_4SCEVEPNS_4TypeEj'/>
<def f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='13146' ll='13192' type='bool llvm::ScalarEvolution::matchURem(const llvm::SCEV * Expr, const llvm::SCEV *&amp; LHS, const llvm::SCEV *&amp; RHS)'/>
<doc f='llvm/llvm/lib/Analysis/ScalarEvolution.cpp' l='13141'>// Match the mathematical pattern A - (A / B) * B, where A and B can be
// arbitrary expressions. Also match zext (trunc A to iB) to iY, which is used
// for URem with constant power-of-2 second operands.
// It&apos;s not always easy, as A and B can be folded (imagine A is X / 2, and B is
// 4, A / B becomes X / 8).</doc>
<use f='llvm/llvm/unittests/Analysis/ScalarEvolutionTest.cpp' l='69' u='c' c='_ZN4llvm20ScalarEvolutionsTest9matchURemERNS_15ScalarEvolutionEPKNS_4SCEVERS5_S6_'/>
