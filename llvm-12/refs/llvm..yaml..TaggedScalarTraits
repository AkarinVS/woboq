<def f='llvm/llvm/include/llvm/Support/YAMLTraits.h' l='215' ll='229'/>
<use f='llvm/llvm/include/llvm/Support/YAMLTraits.h' l='395'/>
<use f='llvm/llvm/include/llvm/Support/YAMLTraits.h' l='1020' c='_ZN4llvm4yaml7yamlizeERNS0_2IOERT_bRNS0_12EmptyContextE'/>
<use f='llvm/llvm/include/llvm/Support/YAMLTraits.h' l='1025' c='_ZN4llvm4yaml7yamlizeERNS0_2IOERT_bRNS0_12EmptyContextE'/>
<use f='llvm/llvm/include/llvm/Support/YAMLTraits.h' l='1032' c='_ZN4llvm4yaml7yamlizeERNS0_2IOERT_bRNS0_12EmptyContextE'/>
<doc f='llvm/llvm/include/llvm/Support/YAMLTraits.h' l='194'>/// This class should be specialized by type that requires custom conversion
/// to/from a YAML scalar with optional tags. For example:
///
///    template &lt;&gt;
///    struct TaggedScalarTraits&lt;MyType&gt; {
///      static void output(const MyType &amp;Value, void*, llvm::raw_ostream
///      &amp;ScalarOut, llvm::raw_ostream &amp;TagOut)
///      {
///        // stream out custom formatting including optional Tag
///        Out &lt;&lt; Value;
///      }
///      static StringRef input(StringRef Scalar, StringRef Tag, void*, MyType
///      &amp;Value) {
///        // parse scalar and set `value`
///        // return empty string on success, or error string
///        return StringRef();
///      }
///      static QuotingType mustQuote(const MyType &amp;Value, StringRef) {
///        return QuotingType::Single;
///      }
///    };</doc>
<use f='llvm/llvm/lib/BinaryFormat/MsgPackDocumentYAML.cpp' l='173'/>
<def f='llvm/llvm/unittests/Support/YAMLIOTest.cpp' l='2916' ll='2962'/>
<use f='llvm/llvm/unittests/Support/YAMLIOTest.cpp' l='2916'/>
<size>1</size>
