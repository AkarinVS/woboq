<dec f='llvm/clang/include/clang/Parse/Parser.h' l='1932' type='clang::ExprResult clang::Parser::ParseCXXPseudoDestructor(clang::Expr * Base, clang::SourceLocation OpLoc, tok::TokenKind OpKind, clang::CXXScopeSpec &amp; SS, clang::ParsedType ObjectType)'/>
<doc f='llvm/clang/include/clang/Parse/Parser.h' l='1930'>//===--------------------------------------------------------------------===//
  // C++ 5.2.4: C++ Pseudo-Destructor Expressions</doc>
<use f='llvm/clang/lib/Parse/ParseExpr.cpp' l='2151' u='c' c='_ZN5clang6Parser28ParsePostfixExpressionSuffixENS_12ActionResultIPNS_4ExprELb1EEE'/>
<def f='llvm/clang/lib/Parse/ParseExprCXX.cpp' l='1746' ll='1816' type='clang::ExprResult clang::Parser::ParseCXXPseudoDestructor(clang::Expr * Base, clang::SourceLocation OpLoc, tok::TokenKind OpKind, clang::CXXScopeSpec &amp; SS, clang::ParsedType ObjectType)'/>
<doc f='llvm/clang/lib/Parse/ParseExprCXX.cpp' l='1715'>/// Parse a C++ pseudo-destructor expression after the base,
/// . or -&gt; operator, and nested-name-specifier have already been
/// parsed. We&apos;re handling this fragment of the grammar:
///
///       postfix-expression: [C++2a expr.post]
///         postfix-expression . template[opt] id-expression
///         postfix-expression -&gt; template[opt] id-expression
///
///       id-expression:
///         qualified-id
///         unqualified-id
///
///       qualified-id:
///         nested-name-specifier template[opt] unqualified-id
///
///       nested-name-specifier:
///         type-name ::
///         decltype-specifier ::    FIXME: not implemented, but probably only
///                                         allowed in C++ grammar by accident
///         nested-name-specifier identifier ::
///         nested-name-specifier template[opt] simple-template-id ::
///         [...]
///
///       unqualified-id:
///         ~ type-name
///         ~ decltype-specifier
///         [...]
///
/// ... where the all but the last component of the nested-name-specifier
/// has already been parsed, and the base expression is not of a non-dependent
/// class type.</doc>
