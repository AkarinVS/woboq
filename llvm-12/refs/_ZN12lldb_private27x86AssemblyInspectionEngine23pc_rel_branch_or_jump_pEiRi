<dec f='llvm/lldb/source/Plugins/UnwindAssembly/x86/x86AssemblyInspectionEngine.h' l='118' type='bool lldb_private::x86AssemblyInspectionEngine::pc_rel_branch_or_jump_p(const int instruction_length, int &amp; offset)'/>
<def f='llvm/lldb/source/Plugins/UnwindAssembly/x86/x86AssemblyInspectionEngine.cpp' l='733' ll='808' type='bool lldb_private::x86AssemblyInspectionEngine::pc_rel_branch_or_jump_p(const int instruction_length, int &amp; offset)'/>
<use f='llvm/lldb/source/Plugins/UnwindAssembly/x86/x86AssemblyInspectionEngine.cpp' l='820' u='c' c='_ZN12lldb_private27x86AssemblyInspectionEngine14local_branch_pEmRKNS_12AddressRangeEiRm'/>
<use f='llvm/lldb/source/Plugins/UnwindAssembly/x86/x86AssemblyInspectionEngine.cpp' l='847' u='c' c='_ZN12lldb_private27x86AssemblyInspectionEngine18non_local_branch_pEmRKNS_12AddressRangeEi'/>
<doc f='llvm/lldb/source/Plugins/UnwindAssembly/x86/x86AssemblyInspectionEngine.cpp' l='718'>// Detect branches to fixed pc-relative offsets.
// Returns the offset from the address of the next instruction
// that may be branch/jumped to.
//
// Cannot determine the offset of a JMP that jumps to the address in
// a register (&quot;jmpq *%rax&quot;) or offset from a register value 
// (&quot;jmpq *0x28(%rax)&quot;), this method will return false on those
// instructions.
//
// These instructions all end in either a relative 8/16/32 bit value
// depending on the instruction and the current execution mode of the
// inferior process.  Once we know the size of the opcode instruction, 
// we can use the total instruction length to determine the size of
// the relative offset without having to compute it correctly.</doc>
