<dec f='llvm/polly/include/polly/ScopBuilder.h' l='402' type='void polly::ScopBuilder::foldSizeConstantsToRight()'/>
<def f='llvm/polly/lib/Analysis/ScopBuilder.cpp' l='2358' ll='2454' type='void polly::ScopBuilder::foldSizeConstantsToRight()'/>
<use f='llvm/polly/lib/Analysis/ScopBuilder.cpp' l='2475' u='c' c='_ZN5polly11ScopBuilder16finalizeAccessesEv'/>
<doc f='llvm/polly/include/polly/ScopBuilder.h' l='377'>/// Fold size constants to the right.
  ///
  /// In case all memory accesses in a given dimension are multiplied with a
  /// common constant, we can remove this constant from the individual access
  /// functions and move it to the size of the memory access. We do this as this
  /// increases the size of the innermost dimension, consequently widens the
  /// valid range the array subscript in this dimension can evaluate to, and
  /// as a result increases the likelihood that our delinearization is
  /// correct.
  ///
  /// Example:
  ///
  ///    A[][n]
  ///    S[i,j] -&gt; A[2i][2j+1]
  ///    S[i,j] -&gt; A[2i][2j]
  ///
  ///    =&gt;
  ///
  ///    A[][2n]
  ///    S[i,j] -&gt; A[i][2j+1]
  ///    S[i,j] -&gt; A[i][2j]
  ///
  /// Constants in outer dimensions can arise when the elements of a parametric
  /// multi-dimensional array are not elementary data types, but e.g.,
  /// structures.</doc>
