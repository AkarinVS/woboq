<def f='llvm/lldb/include/lldb/Core/Architecture.h' l='45' ll='47' type='size_t lldb_private::Architecture::GetBytesToSkip(lldb_private::Symbol &amp; func, const lldb_private::Address &amp; curr_addr) const'/>
<doc f='llvm/lldb/include/lldb/Core/Architecture.h' l='30'>/// This method is used to get the number of bytes that should be
  /// skipped, from function start address, to reach the first
  /// instruction after the prologue. If overrode, it must return
  /// non-zero only if the current address matches one of the known
  /// function entry points.
  ///
  /// This method is called only if the standard platform-independent
  /// code fails to get the number of bytes to skip, giving the plugin
  /// a chance to try to find the missing info.
  ///
  /// This is specifically used for PPC64, where functions may have
  /// more than one entry point, global and local, so both should
  /// be compared with current address, in order to find out the
  /// number of bytes that should be skipped, in case we are stopped
  /// at either function entry point.</doc>
<ovr f='llvm/lldb/source/Plugins/Architecture/PPC64/ArchitecturePPC64.cpp' l='54' c='_ZNK12lldb_private17ArchitecturePPC6414GetBytesToSkipERNS_6SymbolERKNS_7AddressE'/>
<use f='llvm/lldb/source/Target/ThreadPlanStepInRange.cpp' l='266' u='c' c='_ZN12lldb_private21ThreadPlanStepInRange10ShouldStopEPNS_5EventE'/>
