<dec f='llvm/llvm/include/llvm/DebugInfo/GSYM/Range.h' l='62' type='void llvm::gsym::AddressRange::decode(llvm::DataExtractor &amp; Data, uint64_t BaseAddr, uint64_t &amp; Offset)'/>
<doc f='llvm/llvm/include/llvm/DebugInfo/GSYM/Range.h' l='53'>/// AddressRange objects are encoded and decoded to be relative to a base
  /// address. This will be the FunctionInfo&apos;s start address if the AddressRange
  /// is directly contained in a FunctionInfo, or a base address of the
  /// containing parent AddressRange or AddressRanges. This allows address
  /// ranges to be efficiently encoded using ULEB128 encodings as we encode the
  /// offset and size of each range instead of full addresses. This also makes
  /// encoded addresses easy to relocate as we just need to relocate one base
  /// address.
  /// @{</doc>
<def f='llvm/llvm/lib/DebugInfo/GSYM/Range.cpp' l='86' ll='93' type='void llvm::gsym::AddressRange::decode(llvm::DataExtractor &amp; Data, uint64_t BaseAddr, uint64_t &amp; Offset)'/>
<use f='llvm/llvm/lib/DebugInfo/GSYM/Range.cpp' l='111' u='c' c='_ZN4llvm4gsym13AddressRanges6decodeERNS_13DataExtractorEmRm'/>
<use f='llvm/llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp' l='757' u='c' c='_ZN42GSYMTest_TestAddressRangeEncodeDecode_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp' l='758' u='c' c='_ZN42GSYMTest_TestAddressRangeEncodeDecode_Test8TestBodyEv'/>
