<dec f='llvm/llvm/include/llvm/Support/OptimizedStructLayout.h' l='137' type='std::pair&lt;uint64_t, Align&gt; llvm::performOptimizedStructLayout(MutableArrayRef&lt;llvm::OptimizedStructLayoutField&gt; Fields)'/>
<def f='llvm/llvm/lib/Support/OptimizedStructLayout.cpp' l='41' ll='449' type='std::pair&lt;uint64_t, Align&gt; llvm::performOptimizedStructLayout(MutableArrayRef&lt;Field&gt; Fields)'/>
<doc f='llvm/llvm/include/llvm/Support/OptimizedStructLayout.h' l='88'>/// Compute a layout for a struct containing the given fields, making a
/// best-effort attempt to minimize the amount of space required.
///
/// Two features are supported which require a more careful solution
/// than the well-known &quot;sort by decreasing alignment&quot; solution:
///
/// - Fields may be assigned a fixed offset in the layout.  If there are
///   gaps among the fixed-offset fields, the algorithm may attempt
///   to allocate flexible-offset fields into those gaps.  If that&apos;s
///   undesirable, the caller should &quot;block out&quot; those gaps by e.g.
///   just creating a single fixed-offset field that represents the
///   entire &quot;header&quot;.
///
/// - The size of a field is not required to be a multiple of, or even
///   greater than, the field&apos;s required alignment.  The only constraint
///   on fields is that they must not be zero-sized.
///
/// To simplify the implementation, any fixed-offset fields in the
/// layout must appear at the start of the field array, and they must
/// be ordered by increasing offset.
///
/// The algorithm will produce a guaranteed-minimal layout with no
/// interior padding in the following &quot;C-style&quot; case:
///
/// - every field&apos;s size is a multiple of its required alignment and
/// - either no fields have initially fixed offsets, or the fixed-offset
///   fields have no interior padding and end at an offset that is at
///   least as aligned as all the flexible-offset fields.
///
/// Otherwise, while the algorithm will make a best-effort attempt to
/// avoid padding, it cannot guarantee a minimal layout, as there is
/// no known efficient algorithm for doing so.
///
/// The layout produced by this algorithm may not be stable across LLVM
/// releases.  Do not use this anywhere where ABI stability is required.
///
/// Flexible-offset fields with the same size and alignment will be ordered
/// the same way they were in the initial array.  Otherwise the current
/// algorithm makes no effort to preserve the initial order of
/// flexible-offset fields.
///
/// On return, all fields will have been assigned a fixed offset, and the
/// array will be sorted in order of ascending offsets.  Note that this
/// means that the fixed-offset fields may no longer form a strict prefix
/// if there&apos;s any padding before they end.
///
/// The return value is the total size of the struct and its required
/// alignment.  Note that the total size is not rounded up to a multiple
/// of the required alignment; clients which require this can do so easily.</doc>
<use f='llvm/llvm/lib/Transforms/Coroutines/CoroFrame.cpp' l='660' u='c' c='_ZN12_GLOBAL__N_116FrameTypeBuilder6finishEPN4llvm10StructTypeE'/>
<use f='llvm/llvm/unittests/Support/OptimizedStructLayoutTest.cpp' l='51' u='c' c='_ZN12_GLOBAL__N_110LayoutTest6verifyEmm'/>
