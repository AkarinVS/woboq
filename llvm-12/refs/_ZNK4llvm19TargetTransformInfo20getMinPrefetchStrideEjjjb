<dec f='llvm/llvm/include/llvm/Analysis/TargetTransformInfo.h' l='1002' type='unsigned int llvm::TargetTransformInfo::getMinPrefetchStride(unsigned int NumMemAccesses, unsigned int NumStridedMemAccesses, unsigned int NumPrefetches, bool HasCall) const'/>
<doc f='llvm/llvm/include/llvm/Analysis/TargetTransformInfo.h' l='985'>/// Some HW prefetchers can handle accesses up to a certain constant stride.
  /// Sometimes prefetching is beneficial even below the HW prefetcher limit,
  /// and the arguments provided are meant to serve as a basis for deciding this
  /// for a particular loop.
  ///
  /// \param NumMemAccesses        Number of memory accesses in the loop.
  /// \param NumStridedMemAccesses Number of the memory accesses that
  ///                              ScalarEvolution could find a known stride
  ///                              for.
  /// \param NumPrefetches         Number of software prefetches that will be
  ///                              emitted as determined by the addresses
  ///                              involved and the cache line size.
  /// \param HasCall               True if the loop contains a call.
  ///
  /// \return This is the minimum stride in bytes where it makes sense to start
  ///         adding SW prefetches. The default is 1, i.e. prefetch with any
  ///         stride.</doc>
<def f='llvm/llvm/lib/Analysis/TargetTransformInfo.cpp' l='676' ll='681' type='unsigned int llvm::TargetTransformInfo::getMinPrefetchStride(unsigned int NumMemAccesses, unsigned int NumStridedMemAccesses, unsigned int NumPrefetches, bool HasCall) const'/>
<use f='llvm/llvm/lib/Transforms/Scalar/LoopDataPrefetch.cpp' l='84' u='c' c='_ZN12_GLOBAL__N_116LoopDataPrefetch20getMinPrefetchStrideEjjjb'/>
