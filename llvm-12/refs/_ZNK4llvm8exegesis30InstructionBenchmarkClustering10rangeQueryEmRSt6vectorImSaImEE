<dec f='llvm/llvm/tools/llvm-exegesis/lib/Clustering.h' l='134' type='void llvm::exegesis::InstructionBenchmarkClustering::rangeQuery(size_t Q, std::vector&lt;size_t&gt; &amp; Scratchpad) const'/>
<def f='llvm/llvm/tools/llvm-exegesis/lib/Clustering.cpp' l='40' ll='56' type='void llvm::exegesis::InstructionBenchmarkClustering::rangeQuery(const size_t Q, std::vector&lt;size_t&gt; &amp; Neighbors) const'/>
<use f='llvm/llvm/tools/llvm-exegesis/lib/Clustering.cpp' l='134' u='c' c='_ZN4llvm8exegesis30InstructionBenchmarkClustering16clusterizeDbScanEm'/>
<use f='llvm/llvm/tools/llvm-exegesis/lib/Clustering.cpp' l='169' u='c' c='_ZN4llvm8exegesis30InstructionBenchmarkClustering16clusterizeDbScanEm'/>
<doc f='llvm/llvm/tools/llvm-exegesis/lib/Clustering.cpp' l='22'>// The clustering problem has the following characteristics:
//  (A) - Low dimension (dimensions are typically proc resource units,
//    typically &lt; 10).
//  (B) - Number of points : ~thousands (points are measurements of an MCInst)
//  (C) - Number of clusters: ~tens.
//  (D) - The number of clusters is not known /a priory/.
//  (E) - The amount of noise is relatively small.
// The problem is rather small. In terms of algorithms, (D) disqualifies
// k-means and makes algorithms such as DBSCAN[1] or OPTICS[2] more applicable.
//
// We&apos;ve used DBSCAN here because it&apos;s simple to implement. This is a pretty
// straightforward and inefficient implementation of the pseudocode in [2].
//
// [1] https://en.wikipedia.org/wiki/DBSCAN
// [2] https://en.wikipedia.org/wiki/OPTICS_algorithm

// Finds the points at distance less than sqrt(EpsilonSquared) of Q (not
// including Q).</doc>
