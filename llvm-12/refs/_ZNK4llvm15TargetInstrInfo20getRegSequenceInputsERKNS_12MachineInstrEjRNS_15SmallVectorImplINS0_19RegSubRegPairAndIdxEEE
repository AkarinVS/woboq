<dec f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='509' type='bool llvm::TargetInstrInfo::getRegSequenceInputs(const llvm::MachineInstr &amp; MI, unsigned int DefIdx, SmallVectorImpl&lt;llvm::TargetInstrInfo::RegSubRegPairAndIdx&gt; &amp; InputRegs) const'/>
<doc f='llvm/llvm/include/llvm/CodeGen/TargetInstrInfo.h' l='490'>/// Build the equivalent inputs of a REG_SEQUENCE for the given \p MI
  /// and \p DefIdx.
  /// \p [out] InputRegs of the equivalent REG_SEQUENCE. Each element of
  /// the list is modeled as &lt;Reg:SubReg, SubIdx&gt;. Operands with the undef
  /// flag are not added to this list.
  /// E.g., REG_SEQUENCE %1:sub1, sub0, %2, sub1 would produce
  /// two elements:
  /// - %1:sub1, sub0
  /// - %2&lt;:0&gt;, sub1
  ///
  /// \returns true if it is possible to build such an input sequence
  /// with the pair \p MI, \p DefIdx. False otherwise.
  ///
  /// \pre MI.isRegSequence() or MI.isRegSequenceLike().
  ///
  /// \note The generic implementation does not provide any support for
  /// MI.isRegSequenceLike(). In other words, one has to override
  /// getRegSequenceLikeInputs for target specific instructions.</doc>
<use f='llvm/llvm/lib/CodeGen/PeepholeOptimizer.cpp' l='1906' u='c' c='_ZN12_GLOBAL__N_112ValueTracker28getNextSourceFromRegSequenceEv'/>
<def f='llvm/llvm/lib/CodeGen/TargetInstrInfo.cpp' l='1286' ll='1311' type='bool llvm::TargetInstrInfo::getRegSequenceInputs(const llvm::MachineInstr &amp; MI, unsigned int DefIdx, SmallVectorImpl&lt;llvm::TargetInstrInfo::RegSubRegPairAndIdx&gt; &amp; InputRegs) const'/>
