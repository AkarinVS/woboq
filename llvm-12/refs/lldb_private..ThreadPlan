<use f='llvm/lldb/include/lldb/lldb-forward.h' l='435'/>
<use f='llvm/lldb/include/lldb/lldb-forward.h' l='436'/>
<use f='llvm/lldb/include/lldb/API/SBThread.h' l='224' c='_ZN4lldb8SBThread13ResumeNewPlanERN12lldb_private16ExecutionContextEPNS1_10ThreadPlanE'/>
<use f='llvm/lldb/include/lldb/API/SBThreadPlan.h' l='20'/>
<use f='llvm/lldb/include/lldb/API/SBThreadPlan.h' l='125' c='_ZNK4lldb12SBThreadPlan3getEv'/>
<use f='llvm/lldb/include/lldb/lldb-private-interfaces.h' l='95'/>
<use f='llvm/lldb/include/lldb/lldb-private-interfaces.h' l='98'/>
<use f='llvm/lldb/include/lldb/Target/Thread.h' l='943' c='_ZNK12lldb_private6Thread14GetCurrentPlanEv'/>
<use f='llvm/lldb/include/lldb/Target/Thread.h' l='984' c='_ZNK12lldb_private6Thread16IsThreadPlanDoneEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/include/lldb/Target/Thread.h' l='995' c='_ZNK12lldb_private6Thread22WasThreadPlanDiscardedEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/include/lldb/Target/Thread.h' l='1032' c='_ZN12lldb_private6Thread26DiscardThreadPlansUpToPlanEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/include/lldb/Target/Thread.h' l='1194'/>
<use f='llvm/lldb/include/lldb/Target/Thread.h' l='1214' c='_ZNK12lldb_private6Thread15GetPreviousPlanEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/include/lldb/Target/Thread.h' l='1214' c='_ZNK12lldb_private6Thread15GetPreviousPlanEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanStack.h' l='63' c='_ZN12lldb_private15ThreadPlanStack20DiscardPlansUpToPlanEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanStack.h' l='86' c='_ZNK12lldb_private15ThreadPlanStack10IsPlanDoneEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanStack.h' l='88' c='_ZNK12lldb_private15ThreadPlanStack16WasPlanDiscardedEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanStack.h' l='90' c='_ZNK12lldb_private15ThreadPlanStack15GetPreviousPlanEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanStack.h' l='90' c='_ZNK12lldb_private15ThreadPlanStack15GetPreviousPlanEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanStack.h' l='92' c='_ZNK12lldb_private15ThreadPlanStack22GetInnermostExpressionEv'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanTracer.h' l='21'/>
<inh f='llvm/lldb/include/lldb/Utility/UserID.h' l='31' c='lldb_private::UserID'/>
<def f='llvm/lldb/include/lldb/Target/ThreadPlan.h' l='281' ll='576'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlan.h' l='281'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlan.h' l='521' c='_ZN12lldb_private10ThreadPlan15GetPreviousPlanEv'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlan.h' l='574' c='_ZN12lldb_private10ThreadPlanC1ERKS0_'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlan.h' l='575' c='_ZN12lldb_private10ThreadPlanaSERKS0_'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlan.h' l='575' c='_ZN12lldb_private10ThreadPlanaSERKS0_'/>
<ovr f='llvm/lldb/include/lldb/Target/ThreadPlan.h' l='584' c='lldb_private::ThreadPlanNull'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlan.h' l='584'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanShouldStopHere.h' l='66' c='_ZN12lldb_private24ThreadPlanShouldStopHereC1EPNS_10ThreadPlanE'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanShouldStopHere.h' l='68' c='_ZN12lldb_private24ThreadPlanShouldStopHereC1EPNS_10ThreadPlanEPKNS0_33ThreadPlanShouldStopHereCallbacksEPv'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanShouldStopHere.h' l='109' c='_ZN12lldb_private24ThreadPlanShouldStopHere29DefaultShouldStopHereCallbackEPNS_10ThreadPlanERNS_5FlagsEN4lldb15FrameComparisonERNS_6StatusEPv'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanShouldStopHere.h' l='115' c='_ZN12lldb_private24ThreadPlanShouldStopHere27DefaultStepFromHereCallbackEPNS_10ThreadPlanERNS_5FlagsEN4lldb15FrameComparisonERNS_6StatusEPv'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanShouldStopHere.h' l='129'/>
<ovr f='llvm/lldb/include/lldb/Target/ThreadPlanStepRange.h' l='20' c='lldb_private::ThreadPlanStepRange'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanStepRange.h' l='20'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanStepInRange.h' l='52' c='_ZN12lldb_private21ThreadPlanStepInRange29DefaultShouldStopHereCallbackEPNS_10ThreadPlanERNS_5FlagsEN4lldb15FrameComparisonERNS_6StatusEPv'/>
<ovr f='llvm/lldb/include/lldb/Target/ThreadPlanStepInstruction.h' l='18' c='lldb_private::ThreadPlanStepInstruction'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanStepInstruction.h' l='18'/>
<ovr f='llvm/lldb/include/lldb/Target/ThreadPlanStepOut.h' l='18' c='lldb_private::ThreadPlanStepOut'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanStepOut.h' l='18'/>
<use f='llvm/lldb/source/API/SBThread.cpp' l='485' c='_ZN4lldb8SBThread13ResumeNewPlanERN12lldb_private16ExecutionContextEPNS1_10ThreadPlanE'/>
<size>224</size>
<doc f='llvm/lldb/include/lldb/Target/ThreadPlan.h' l='25'>//  ThreadPlan:
//
//  This is the pure virtual base class for thread plans.
//
//  The thread plans provide the &quot;atoms&quot; of behavior that all the logical
//  process control, either directly from commands or through more complex
//  composite plans will rely on.
//
//  Plan Stack:
//
//  The thread maintaining a thread plan stack, and you program the actions of
//  a particular thread by pushing plans onto the plan stack.  There is always
//  a &quot;Current&quot; plan, which is the top of the plan stack, though in some cases
//  a plan may defer to plans higher in the stack for some piece of information
//  (let us define that the plan stack grows downwards).
//
//  The plan stack is never empty, there is always a Base Plan which persists
//  through the life of the running process.
//
//
//  Creating Plans:
//
//  The thread plan is generally created and added to the plan stack through
//  the QueueThreadPlanFor... API in lldb::Thread.  Those API&apos;s will return the
//  plan that performs the named operation in a manner appropriate for the
//  current process.  The plans in lldb/source/Target are generic
//  implementations, but a Process plugin can override them.
//
//  ValidatePlan is then called.  If it returns false, the plan is unshipped.
//  This is a little convenience which keeps us from having to error out of the
//  constructor.
//
//  Then the plan is added to the plan stack.  When the plan is added to the
//  plan stack its DidPush will get called.  This is useful if a plan wants to
//  push any additional plans as it is constructed, since you need to make sure
//  you&apos;re already on the stack before you push additional plans.
//
//  Completed Plans:
//
//  When the target process stops the plans are queried, among other things,
//  for whether their job is done.  If it is they are moved from the plan stack
//  to the Completed Plan stack in reverse order from their position on the
//  plan stack (since multiple plans may be done at a given stop.)  This is
//  used primarily so that the lldb::Thread::StopInfo for the thread can be set
//  properly.  If one plan pushes another to achieve part of its job, but it
//  doesn&apos;t want that sub-plan to be the one that sets the StopInfo, then call
//  SetPrivate on the sub-plan when you create it, and the Thread will pass
//  over that plan in reporting the reason for the stop.
//
//  Discarded plans:
//
//  Your plan may also get discarded, i.e. moved from the plan stack to the
//  &quot;discarded plan stack&quot;.  This can happen, for instance, if the plan is
//  calling a function and the function call crashes and you want to unwind the
//  attempt to call.  So don&apos;t assume that your plan will always successfully
//  stop.  Which leads to:
//
//  Cleaning up after your plans:
//
//  When the plan is moved from the plan stack its WillPop method is always
//  called, no matter why.  Once it is moved off the plan stack it is done, and
//  won&apos;t get a chance to run again.  So you should undo anything that affects
//  target state in this method.  But be sure to leave the plan able to
//  correctly fill the StopInfo, however.  N.B. Don&apos;t wait to do clean up
//  target state till the destructor, since that will usually get called when
//  the target resumes, and you want to leave the target state correct for new
//  plans in the time between when your plan gets unshipped and the next
//  resume.
//
//  Thread State Checkpoint:
//
//  Note that calling functions on target process (ThreadPlanCallFunction)
//  changes current thread state. The function can be called either by direct
//  user demand or internally, for example lldb allocates memory on device to
//  calculate breakpoint condition expression - on Linux it is performed by
//  calling mmap on device.  ThreadStateCheckpoint saves Thread state (stop
//  info and completed plan stack) to restore it after completing function
//  call.
//
//  Over the lifetime of the plan, various methods of the ThreadPlan are then
//  called in response to changes of state in the process we are debugging as
//  follows:
//
//  Resuming:
//
//  When the target process is about to be restarted, the plan&apos;s WillResume
//  method is called, giving the plan a chance to prepare for the run.  If
//  WillResume returns false, then the process is not restarted.  Be sure to
//  set an appropriate error value in the Process if you have to do this.
//  Note, ThreadPlans actually implement DoWillResume, WillResume wraps that
//  call.
//
//  Next the &quot;StopOthers&quot; method of all the threads are polled, and if one
//  thread&apos;s Current plan returns &quot;true&quot; then only that thread gets to run.  If
//  more than one returns &quot;true&quot; the threads that want to run solo get run one
//  by one round robin fashion.  Otherwise all are let to run.
//
//  Note, the way StopOthers is implemented, the base class implementation just
//  asks the previous plan.  So if your plan has no opinion about whether it
//  should run stopping others or not, just don&apos;t implement StopOthers, and the
//  parent will be asked.
//
//  Finally, for each thread that is running, it run state is set to the return
//  of RunState from the thread&apos;s Current plan.
//
//  Responding to a stop:
//
//  When the target process stops, the plan is called in the following stages:
//
//  First the thread asks the Current Plan if it can handle this stop by
//  calling PlanExplainsStop.  If the Current plan answers &quot;true&quot; then it is
//  asked if the stop should percolate all the way to the user by calling the
//  ShouldStop method.  If the current plan doesn&apos;t explain the stop, then we
//  query up the plan stack for a plan that does explain the stop.  The plan
//  that does explain the stop then needs to figure out what to do about the
//  plans below it in the stack.  If the stop is recoverable, then the plan
//  that understands it can just do what it needs to set up to restart, and
//  then continue.  Otherwise, the plan that understood the stop should call
//  DiscardPlanStack to clean up the stack below it.  Note, plans actually
//  implement DoPlanExplainsStop, the result is cached in PlanExplainsStop so
//  the DoPlanExplainsStop itself will only get called once per stop.
//
//  Master plans:
//
//  In the normal case, when we decide to stop, we will  collapse the plan
//  stack up to the point of the plan that understood the stop reason.
//  However, if a plan wishes to stay on the stack after an event it didn&apos;t
//  directly handle it can designate itself a &quot;Master&quot; plan by responding true
//  to IsMasterPlan, and then if it wants not to be discarded, it can return
//  false to OkayToDiscard, and it and all its dependent plans will be
//  preserved when we resume execution.
//
//  The other effect of being a master plan is that when the Master plan is
//  done , if it has set &quot;OkayToDiscard&quot; to false, then it will be popped &amp;
//  execution will stop and return to the user.  Remember that if OkayToDiscard
//  is false, the plan will be popped and control will be given to the next
//  plan above it on the stack  So setting OkayToDiscard to false means the
//  user will regain control when the MasterPlan is completed.
//
//  Between these two controls this allows things like: a
//  MasterPlan/DontDiscard Step Over to hit a breakpoint, stop and return
//  control to the user, but then when the user continues, the step out
//  succeeds.  Even more tricky, when the breakpoint is hit, the user can
//  continue to step in/step over/etc, and finally when they continue, they
//  will finish up the Step Over.
//
//  FIXME: MasterPlan &amp; OkayToDiscard aren&apos;t really orthogonal.  MasterPlan
//  designation means that this plan controls it&apos;s fate and the fate of plans
//  below it.  OkayToDiscard tells whether the MasterPlan wants to stay on the
//  stack.  I originally thought &quot;MasterPlan-ness&quot; would need to be a fixed
//  characteristic of a ThreadPlan, in which case you needed the extra control.
//  But that doesn&apos;t seem to be true.  So we should be able to convert to only
//  MasterPlan status to mean the current &quot;MasterPlan/DontDiscard&quot;.  Then no
//  plans would be MasterPlans by default, and you would set the ones you
//  wanted to be &quot;user level&quot; in this way.
//
//
//  Actually Stopping:
//
//  If a plan says responds &quot;true&quot; to ShouldStop, then it is asked if it&apos;s job
//  is complete by calling MischiefManaged.  If that returns true, the plan is
//  popped from the plan stack and added to the Completed Plan Stack.  Then the
//  next plan in the stack is asked if it ShouldStop, and  it returns &quot;true&quot;,
//  it is asked if it is done, and if yes popped, and so on till we reach a
//  plan that is not done.
//
//  Since you often know in the ShouldStop method whether your plan is
//  complete, as a convenience you can call SetPlanComplete and the ThreadPlan
//  implementation of MischiefManaged will return &quot;true&quot;, without your having
//  to redo the calculation when your sub-classes MischiefManaged is called.
//  If you call SetPlanComplete, you can later use IsPlanComplete to determine
//  whether the plan is complete.  This is only a convenience for sub-classes,
//  the logic in lldb::Thread will only call MischiefManaged.
//
//  One slightly tricky point is you have to be careful using SetPlanComplete
//  in PlanExplainsStop because you are not guaranteed that PlanExplainsStop
//  for a plan will get called before ShouldStop gets called.  If your sub-plan
//  explained the stop and then popped itself, only your ShouldStop will get
//  called.
//
//  If ShouldStop for any thread returns &quot;true&quot;, then the WillStop method of
//  the Current plan of all threads will be called, the stop event is placed on
//  the Process&apos;s public broadcaster, and control returns to the upper layers
//  of the debugger.
//
//  Reporting the stop:
//
//  When the process stops, the thread is given a StopReason, in the form of a
//  StopInfo object.  If there is a completed plan corresponding to the stop,
//  then the &quot;actual&quot; stop reason can be suppressed, and instead a
//  StopInfoThreadPlan object will be cons&apos;ed up from the top completed plan in
//  the stack.  However, if the plan doesn&apos;t want to be the stop reason, then
//  it can call SetPlanComplete and pass in &quot;false&quot; for the &quot;success&quot;
//  parameter.  In that case, the real stop reason will be used instead.  One
//  example of this is the &quot;StepRangeStepIn&quot; thread plan.  If it stops because
//  of a crash or breakpoint hit, it wants to unship itself, because it isn&apos;t
//  so useful to have step in keep going after a breakpoint hit.  But it can&apos;t
//  be the reason for the stop or no-one would see that they had hit a
//  breakpoint.
//
//  Cleaning up the plan stack:
//
//  One of the complications of MasterPlans is that you may get past the limits
//  of a plan without triggering it to clean itself up.  For instance, if you
//  are doing a MasterPlan StepOver, and hit a breakpoint in a called function,
//  then step over enough times to step out of the initial StepOver range, each
//  of the step overs will explain the stop &amp; take themselves off the stack,
//  but control would never be returned to the original StepOver.  Eventually,
//  the user will continue, and when that continue stops, the old stale
//  StepOver plan that was left on the stack will get woken up and notice it is
//  done. But that can leave junk on the stack for a while.  To avoid that, the
//  plans implement a &quot;IsPlanStale&quot; method, that can check whether it is
//  relevant anymore.  On stop, after the regular plan negotiation, the
//  remaining plan stack is consulted and if any plan says it is stale, it and
//  the plans below it are discarded from the stack.
//
//  Automatically Resuming:
//
//  If ShouldStop for all threads returns &quot;false&quot;, then the target process will
//  resume.  This then cycles back to Resuming above.
//
//  Reporting eStateStopped events when the target is restarted:
//
//  If a plan decides to auto-continue the target by returning &quot;false&quot; from
//  ShouldStop, then it will be asked whether the Stopped event should still be
//  reported.  For instance, if you hit a breakpoint that is a User set
//  breakpoint, but the breakpoint callback said to continue the target
//  process, you might still want to inform the upper layers of lldb that the
//  stop had happened.  The way this works is every thread gets to vote on
//  whether to report the stop.  If all votes are eVoteNoOpinion, then the
//  thread list will decide what to do (at present it will pretty much always
//  suppress these stopped events.) If there is an eVoteYes, then the event
//  will be reported regardless of the other votes.  If there is an eVoteNo and
//  no eVoteYes&apos;s, then the event won&apos;t be reported.
//
//  One other little detail here, sometimes a plan will push another plan onto
//  the plan stack to do some part of the first plan&apos;s job, and it would be
//  convenient to tell that plan how it should respond to ShouldReportStop.
//  You can do that by setting the stop_vote in the child plan when you create
//  it.
//
//  Suppressing the initial eStateRunning event:
//
//  The private process running thread will take care of ensuring that only one
//  &quot;eStateRunning&quot; event will be delivered to the public Process broadcaster
//  per public eStateStopped event.  However there are some cases where the
//  public state of this process is eStateStopped, but a thread plan needs to
//  restart the target, but doesn&apos;t want the running event to be publicly
//  broadcast.  The obvious example of this is running functions by hand as
//  part of expression evaluation.  To suppress the running event return
//  eVoteNo from ShouldReportStop, to force a running event to be reported
//  return eVoteYes, in general though you should return eVoteNoOpinion which
//  will allow the ThreadList to figure out the right thing to do.  The
//  run_vote argument to the constructor works like stop_vote, and is a way for
//  a plan to instruct a sub-plan on how to respond to ShouldReportStop.</doc>
<fun r='_ZN12lldb_private10ThreadPlanC1ENS0_14ThreadPlanKindEPKcRNS_6ThreadENS_4VoteES6_'/>
<fun r='_ZN12lldb_private10ThreadPlanD1Ev'/>
<fun r='_ZNK12lldb_private10ThreadPlan7GetNameEv'/>
<fun r='_ZN12lldb_private10ThreadPlan9GetThreadEv'/>
<fun r='_ZN12lldb_private10ThreadPlan9GetTargetEv'/>
<fun r='_ZNK12lldb_private10ThreadPlan9GetTargetEv'/>
<fun r='_ZN12lldb_private10ThreadPlan16ClearThreadCacheEv'/>
<fun r='_ZN12lldb_private10ThreadPlan14GetDescriptionEPNS_6StreamEN4lldb16DescriptionLevelE'/>
<fun r='_ZN12lldb_private10ThreadPlan12ValidatePlanEPNS_6StreamE'/>
<fun r='_ZN12lldb_private10ThreadPlan18TracerExplainsStopEv'/>
<fun r='_ZN12lldb_private10ThreadPlan8RunStateEv'/>
<fun r='_ZN12lldb_private10ThreadPlan16PlanExplainsStopEPNS_5EventE'/>
<fun r='_ZN12lldb_private10ThreadPlan10ShouldStopEPNS_5EventE'/>
<fun r='_ZN12lldb_private10ThreadPlan18ShouldAutoContinueEPNS_5EventE'/>
<fun r='_ZN12lldb_private10ThreadPlan16ShouldReportStopEPNS_5EventE'/>
<fun r='_ZN12lldb_private10ThreadPlan15ShouldReportRunEPNS_5EventE'/>
<fun r='_ZN12lldb_private10ThreadPlan13SetStopOthersEb'/>
<fun r='_ZN12lldb_private10ThreadPlan10StopOthersEv'/>
<fun r='_ZN12lldb_private10ThreadPlan10WillResumeEN4lldb9StateTypeEb'/>
<fun r='_ZN12lldb_private10ThreadPlan8WillStopEv'/>
<fun r='_ZN12lldb_private10ThreadPlan12IsMasterPlanEv'/>
<fun r='_ZN12lldb_private10ThreadPlan15SetIsMasterPlanEb'/>
<fun r='_ZN12lldb_private10ThreadPlan13OkayToDiscardEv'/>
<fun r='_ZN12lldb_private10ThreadPlan16SetOkayToDiscardEb'/>
<fun r='_ZN12lldb_private10ThreadPlan15MischiefManagedEv'/>
<fun r='_ZN12lldb_private10ThreadPlan15ThreadDestroyedEv'/>
<fun r='_ZN12lldb_private10ThreadPlan10GetPrivateEv'/>
<fun r='_ZN12lldb_private10ThreadPlan10SetPrivateEb'/>
<fun r='_ZN12lldb_private10ThreadPlan7DidPushEv'/>
<fun r='_ZN12lldb_private10ThreadPlan7WillPopEv'/>
<fun r='_ZN12lldb_private10ThreadPlan8PushPlanERSt10shared_ptrIS0_E'/>
<fun r='_ZNK12lldb_private10ThreadPlan7GetKindEv'/>
<fun r='_ZN12lldb_private10ThreadPlan14IsPlanCompleteEv'/>
<fun r='_ZN12lldb_private10ThreadPlan15SetPlanCompleteEb'/>
<fun r='_ZN12lldb_private10ThreadPlan11IsPlanStaleEv'/>
<fun r='_ZN12lldb_private10ThreadPlan13PlanSucceededEv'/>
<fun r='_ZN12lldb_private10ThreadPlan10IsBasePlanEv'/>
<fun r='_ZN12lldb_private10ThreadPlan19GetThreadPlanTracerEv'/>
<fun r='_ZN12lldb_private10ThreadPlan19SetThreadPlanTracerESt10shared_ptrINS_16ThreadPlanTracerEE'/>
<fun r='_ZN12lldb_private10ThreadPlan10DoTraceLogEv'/>
<fun r='_ZN12lldb_private10ThreadPlan15GetRealStopInfoEv'/>
<fun r='_ZN12lldb_private10ThreadPlan20GetReturnValueObjectEv'/>
<fun r='_ZN12lldb_private10ThreadPlan21GetExpressionVariableEv'/>
<fun r='_ZN12lldb_private10ThreadPlan18RestoreThreadStateEv'/>
<fun r='_ZN12lldb_private10ThreadPlan13IsVirtualStepEv'/>
<fun r='_ZN12lldb_private10ThreadPlan17SetIterationCountEm'/>
<fun r='_ZN12lldb_private10ThreadPlan17GetIterationCountEv'/>
<fun r='_ZN12lldb_private10ThreadPlan12DoWillResumeEN4lldb9StateTypeEb'/>
<fun r='_ZN12lldb_private10ThreadPlan18DoPlanExplainsStopEPNS_5EventE'/>
<fun r='_ZN12lldb_private10ThreadPlan15GetPreviousPlanEv'/>
<fun r='_ZN12lldb_private10ThreadPlan18GetPrivateStopInfoEv'/>
<fun r='_ZN12lldb_private10ThreadPlan11SetStopInfoESt10shared_ptrINS_8StopInfoEE'/>
<fun r='_ZN12lldb_private10ThreadPlan21CachePlanExplainsStopEb'/>
<fun r='_ZNK12lldb_private10ThreadPlan25GetCachedPlanExplainsStopEv'/>
<fun r='_ZN12lldb_private10ThreadPlan15GetPlanRunStateEv'/>
<fun r='_ZN12lldb_private10ThreadPlan30IsUsuallyUnexplainedStopReasonEN4lldb10StopReasonE'/>
<mbr r='lldb_private::ThreadPlan::m_status' o='256' t='lldb_private::Status'/>
<mbr r='lldb_private::ThreadPlan::m_process' o='576' t='lldb_private::Process &amp;'/>
<mbr r='lldb_private::ThreadPlan::m_tid' o='640' t='lldb::tid_t'/>
<mbr r='lldb_private::ThreadPlan::m_stop_vote' o='704' t='lldb_private::Vote'/>
<mbr r='lldb_private::ThreadPlan::m_run_vote' o='736' t='lldb_private::Vote'/>
<mbr r='lldb_private::ThreadPlan::m_takes_iteration_count' o='768' t='bool'/>
<mbr r='lldb_private::ThreadPlan::m_could_not_resolve_hw_bp' o='776' t='bool'/>
<mbr r='lldb_private::ThreadPlan::m_iteration_count' o='800' t='int32_t'/>
<fun r='_ZN12lldb_private10ThreadPlan9GetNextIDEv'/>
<mbr r='lldb_private::ThreadPlan::m_thread' o='832' t='lldb_private::Thread *'/>
<mbr r='lldb_private::ThreadPlan::m_kind' o='896' t='lldb_private::ThreadPlan::ThreadPlanKind'/>
<mbr r='lldb_private::ThreadPlan::m_name' o='960' t='std::string'/>
<mbr r='lldb_private::ThreadPlan::m_plan_complete_mutex' o='1216' t='std::recursive_mutex'/>
<mbr r='lldb_private::ThreadPlan::m_cached_plan_explains_stop' o='1536' t='lldb_private::LazyBool'/>
<mbr r='lldb_private::ThreadPlan::m_plan_complete' o='1568' t='bool'/>
<mbr r='lldb_private::ThreadPlan::m_plan_private' o='1576' t='bool'/>
<mbr r='lldb_private::ThreadPlan::m_okay_to_discard' o='1584' t='bool'/>
<mbr r='lldb_private::ThreadPlan::m_is_master_plan' o='1592' t='bool'/>
<mbr r='lldb_private::ThreadPlan::m_plan_succeeded' o='1600' t='bool'/>
<mbr r='lldb_private::ThreadPlan::m_tracer_sp' o='1664' t='lldb::ThreadPlanTracerSP'/>
<fun r='_ZN12lldb_private10ThreadPlanC1ERKS0_'/>
<fun r='_ZN12lldb_private10ThreadPlanaSERKS0_'/>
<ovr f='llvm/lldb/include/lldb/Target/ThreadPlanPython.h' l='32' c='lldb_private::ThreadPlanPython'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanPython.h' l='32'/>
<size>224</size>
<ovr f='llvm/lldb/include/lldb/Target/ThreadPlanCallFunction.h' l='20' c='lldb_private::ThreadPlanCallFunction'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanCallFunction.h' l='20'/>
<size>224</size>
<ovr f='llvm/lldb/include/lldb/Target/ThreadPlanRunToAddress.h' l='19' c='lldb_private::ThreadPlanRunToAddress'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanRunToAddress.h' l='19'/>
<size>224</size>
<ovr f='llvm/lldb/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleThreadPlanStepThroughObjCTrampoline.h' l='23' c='lldb_private::AppleThreadPlanStepThroughObjCTrampoline'/>
<use f='llvm/lldb/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleThreadPlanStepThroughObjCTrampoline.h' l='23'/>
<size>224</size>
<use f='llvm/lldb/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleThreadPlanStepThroughObjCTrampoline.cpp' l='35' c='_ZN12lldb_private40AppleThreadPlanStepThroughObjCTrampolineC1ERNS_6ThreadERNS_26AppleObjCTrampolineHandlerERNS_9ValueListEmmb'/>
<size>224</size>
<ovr f='llvm/lldb/include/lldb/Target/ThreadPlanCallOnFunctionExit.h' l='22' c='lldb_private::ThreadPlanCallOnFunctionExit'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanCallOnFunctionExit.h' l='22'/>
<size>224</size>
<ovr f='llvm/lldb/include/lldb/Target/ThreadPlanBase.h' l='23' c='lldb_private::ThreadPlanBase'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanBase.h' l='23'/>
<size>224</size>
<ovr f='llvm/lldb/include/lldb/Target/ThreadPlanStepOverBreakpoint.h' l='17' c='lldb_private::ThreadPlanStepOverBreakpoint'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanStepOverBreakpoint.h' l='17'/>
<ovr f='llvm/lldb/include/lldb/Target/ThreadPlanStepThrough.h' l='17' c='lldb_private::ThreadPlanStepThrough'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanStepThrough.h' l='17'/>
<ovr f='llvm/lldb/include/lldb/Target/ThreadPlanStepUntil.h' l='17' c='lldb_private::ThreadPlanStepUntil'/>
<use f='llvm/lldb/include/lldb/Target/ThreadPlanStepUntil.h' l='17'/>
<use f='llvm/lldb/source/Target/Thread.cpp' l='614' c='_ZN12lldb_private6Thread8WillStopEv'/>
<use f='llvm/lldb/source/Target/Thread.cpp' l='642' c='_ZN12lldb_private6Thread14SetupForResumeEv'/>
<use f='llvm/lldb/source/Target/Thread.cpp' l='709' c='_ZN12lldb_private6Thread12ShouldResumeEN4lldb9StateTypeE'/>
<use f='llvm/lldb/source/Target/Thread.cpp' l='739' c='_ZN12lldb_private6Thread10ShouldStopEPNS_5EventE'/>
<use f='llvm/lldb/source/Target/Thread.cpp' l='830' c='_ZN12lldb_private6Thread10ShouldStopEPNS_5EventE'/>
<use f='llvm/lldb/source/Target/Thread.cpp' l='842' c='_ZN12lldb_private6Thread10ShouldStopEPNS_5EventE'/>
<use f='llvm/lldb/source/Target/Thread.cpp' l='920' c='_ZN12lldb_private6Thread10ShouldStopEPNS_5EventE'/>
<use f='llvm/lldb/source/Target/Thread.cpp' l='926' c='_ZN12lldb_private6Thread10ShouldStopEPNS_5EventE'/>
<use f='llvm/lldb/source/Target/Thread.cpp' l='1002' c='_ZN12lldb_private6Thread16ShouldReportStopEPNS_5EventE'/>
<use f='llvm/lldb/source/Target/Thread.cpp' l='1122' c='_ZNK12lldb_private6Thread14GetCurrentPlanEv'/>
<use f='llvm/lldb/source/Target/Thread.cpp' l='1138' c='_ZNK12lldb_private6Thread16IsThreadPlanDoneEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/source/Target/Thread.cpp' l='1142' c='_ZNK12lldb_private6Thread22WasThreadPlanDiscardedEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/source/Target/Thread.cpp' l='1150' c='_ZNK12lldb_private6Thread15GetPreviousPlanEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/source/Target/Thread.cpp' l='1150' c='_ZNK12lldb_private6Thread15GetPreviousPlanEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/source/Target/Thread.cpp' l='1196' c='_ZN12lldb_private6Thread31DiscardUserThreadPlansUpToIndexEj'/>
<use f='llvm/lldb/source/Target/Thread.cpp' l='1208' c='_ZN12lldb_private6Thread26DiscardThreadPlansUpToPlanEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/source/Target/Thread.cpp' l='1235' c='_ZN12lldb_private6Thread25UnwindInnermostExpressionEv'/>
<size>224</size>
<use f='llvm/lldb/source/Target/ThreadPlan.cpp' l='82' c='_ZN12lldb_private10ThreadPlan16ShouldReportStopEPNS_5EventE'/>
<use f='llvm/lldb/source/Target/ThreadPlan.cpp' l='95' c='_ZN12lldb_private10ThreadPlan15ShouldReportRunEPNS_5EventE'/>
<use f='llvm/lldb/source/Target/ThreadPlan.cpp' l='105' c='_ZN12lldb_private10ThreadPlan10StopOthersEv'/>
<use f='llvm/lldb/source/Target/ThreadPlan.cpp' l='183' c='_ZN12lldb_private14ThreadPlanNullC1ERNS_6ThreadE'/>
<size>224</size>
<fun r='_ZN12lldb_private10ThreadPlanC1ENS0_14ThreadPlanKindEPKcRNS_6ThreadENS_4VoteES6_'/>
<fun r='_ZN12lldb_private10ThreadPlanD1Ev'/>
<fun r='_ZN12lldb_private10ThreadPlan9GetTargetEv'/>
<fun r='_ZNK12lldb_private10ThreadPlan9GetTargetEv'/>
<fun r='_ZN12lldb_private10ThreadPlan9GetThreadEv'/>
<fun r='_ZN12lldb_private10ThreadPlan16PlanExplainsStopEPNS_5EventE'/>
<fun r='_ZN12lldb_private10ThreadPlan14IsPlanCompleteEv'/>
<fun r='_ZN12lldb_private10ThreadPlan15SetPlanCompleteEb'/>
<fun r='_ZN12lldb_private10ThreadPlan15MischiefManagedEv'/>
<fun r='_ZN12lldb_private10ThreadPlan16ShouldReportStopEPNS_5EventE'/>
<fun r='_ZN12lldb_private10ThreadPlan15ShouldReportRunEPNS_5EventE'/>
<fun r='_ZN12lldb_private10ThreadPlan16ClearThreadCacheEv'/>
<fun r='_ZN12lldb_private10ThreadPlan10StopOthersEv'/>
<fun r='_ZN12lldb_private10ThreadPlan13SetStopOthersEb'/>
<fun r='_ZN12lldb_private10ThreadPlan10WillResumeEN4lldb9StateTypeEb'/>
<fun r='_ZN12lldb_private10ThreadPlan9GetNextIDEv'/>
<fun r='_ZN12lldb_private10ThreadPlan7DidPushEv'/>
<fun r='_ZN12lldb_private10ThreadPlan7WillPopEv'/>
<fun r='_ZN12lldb_private10ThreadPlan13OkayToDiscardEv'/>
<fun r='_ZN12lldb_private10ThreadPlan8RunStateEv'/>
<fun r='_ZN12lldb_private10ThreadPlan30IsUsuallyUnexplainedStopReasonEN4lldb10StopReasonE'/>
<use f='llvm/lldb/source/Target/ThreadPlanBase.cpp' l='30' c='_ZN12lldb_private14ThreadPlanBaseC1ERNS_6ThreadE'/>
<size>224</size>
<use f='llvm/lldb/source/Target/ThreadPlanCallFunction.cpp' l='99' c='_ZN12lldb_private22ThreadPlanCallFunctionC1ERNS_6ThreadERKNS_7AddressERKNS_12CompilerTypeEN4llvm8ArrayRefImEERKNS_25EvaluateExpressionOptionsE'/>
<use f='llvm/lldb/source/Target/ThreadPlanCallFunction.cpp' l='129' c='_ZN12lldb_private22ThreadPlanCallFunctionC1ERNS_6ThreadERKNS_7AddressERKNS_25EvaluateExpressionOptionsE'/>
<size>224</size>
<use f='llvm/lldb/source/Target/ThreadPlanCallOnFunctionExit.cpp' l='16' c='_ZN12lldb_private28ThreadPlanCallOnFunctionExitC1ERNS_6ThreadERKSt8functionIFvvEE'/>
<size>224</size>
<use f='llvm/lldb/source/Target/ThreadPlanPython.cpp' l='30' c='_ZN12lldb_private16ThreadPlanPythonC1ERNS_6ThreadEPKcPNS_18StructuredDataImplE'/>
<size>224</size>
<use f='llvm/lldb/source/Target/ThreadPlanRunToAddress.cpp' l='24' c='_ZN12lldb_private22ThreadPlanRunToAddressC1ERNS_6ThreadERNS_7AddressEb'/>
<use f='llvm/lldb/source/Target/ThreadPlanRunToAddress.cpp' l='35' c='_ZN12lldb_private22ThreadPlanRunToAddressC1ERNS_6ThreadEmb'/>
<use f='llvm/lldb/source/Target/ThreadPlanRunToAddress.cpp' l='46' c='_ZN12lldb_private22ThreadPlanRunToAddressC1ERNS_6ThreadERKSt6vectorImSaImEEb'/>
<size>224</size>
<use f='llvm/lldb/source/Target/ThreadPlanShouldStopHere.cpp' l='19' c='_ZN12lldb_private24ThreadPlanShouldStopHereC1EPNS_10ThreadPlanE'/>
<use f='llvm/lldb/source/Target/ThreadPlanShouldStopHere.cpp' l='29' c='_ZN12lldb_private24ThreadPlanShouldStopHereC1EPNS_10ThreadPlanEPKNS0_33ThreadPlanShouldStopHereCallbacksEPv'/>
<use f='llvm/lldb/source/Target/ThreadPlanShouldStopHere.cpp' l='58' c='_ZN12lldb_private24ThreadPlanShouldStopHere29DefaultShouldStopHereCallbackEPNS_10ThreadPlanERNS_5FlagsEN4lldb15FrameComparisonERNS_6StatusEPv'/>
<use f='llvm/lldb/source/Target/ThreadPlanShouldStopHere.cpp' l='94' c='_ZN12lldb_private24ThreadPlanShouldStopHere27DefaultStepFromHereCallbackEPNS_10ThreadPlanERNS_5FlagsEN4lldb15FrameComparisonERNS_6StatusEPv'/>
<size>224</size>
<use f='llvm/lldb/source/Target/ThreadPlanStack.cpp' l='178' c='_ZN12lldb_private15ThreadPlanStack20DiscardPlansUpToPlanEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/source/Target/ThreadPlanStack.cpp' l='319' c='_ZNK12lldb_private15ThreadPlanStack10IsPlanDoneEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/source/Target/ThreadPlanStack.cpp' l='327' c='_ZNK12lldb_private15ThreadPlanStack16WasPlanDiscardedEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/source/Target/ThreadPlanStack.cpp' l='335' c='_ZNK12lldb_private15ThreadPlanStack15GetPreviousPlanEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/source/Target/ThreadPlanStack.cpp' l='335' c='_ZNK12lldb_private15ThreadPlanStack15GetPreviousPlanEPNS_10ThreadPlanE'/>
<use f='llvm/lldb/source/Target/ThreadPlanStack.cpp' l='362' c='_ZNK12lldb_private15ThreadPlanStack22GetInnermostExpressionEv'/>
<size>224</size>
<use f='llvm/lldb/source/Target/ThreadPlanStepInRange.cpp' l='363' c='_ZN12lldb_private21ThreadPlanStepInRange29DefaultShouldStopHereCallbackEPNS_10ThreadPlanERNS_5FlagsEN4lldb15FrameComparisonERNS_6StatusEPv'/>
<size>224</size>
<use f='llvm/lldb/source/Target/ThreadPlanStepInstruction.cpp' l='28' c='_ZN12lldb_private25ThreadPlanStepInstructionC1ERNS_6ThreadEbbNS_4VoteES3_'/>
<size>224</size>
<use f='llvm/lldb/source/Target/ThreadPlanStepOut.cpp' l='39' c='_ZN12lldb_private17ThreadPlanStepOutC1ERNS_6ThreadEPNS_13SymbolContextEbbNS_4VoteES5_jNS_8LazyBoolEbb'/>
<size>224</size>
<use f='llvm/lldb/source/Target/ThreadPlanStepOverBreakpoint.cpp' l='23' c='_ZN12lldb_private28ThreadPlanStepOverBreakpointC1ERNS_6ThreadE'/>
<size>224</size>
<use f='llvm/lldb/source/Target/ThreadPlanStepRange.cpp' l='37' c='_ZN12lldb_private19ThreadPlanStepRangeC1ENS_10ThreadPlan14ThreadPlanKindEPKcRNS_6ThreadERKNS_12AddressRangeERKNS_13SymbolContextEN4lldb7RunModeEb'/>
<size>224</size>
<use f='llvm/lldb/source/Target/ThreadPlanStepThrough.cpp' l='30' c='_ZN12lldb_private21ThreadPlanStepThroughC1ERNS_6ThreadERNS_7StackIDEb'/>
<size>224</size>
<use f='llvm/lldb/source/Target/ThreadPlanStepUntil.cpp' l='29' c='_ZN12lldb_private19ThreadPlanStepUntilC1ERNS_6ThreadEPmmbj'/>
<size>224</size>
