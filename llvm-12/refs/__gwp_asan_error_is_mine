<def f='llvm/compiler-rt/lib/gwp_asan/crash_handler.cpp' l='23' ll='31' type='bool __gwp_asan_error_is_mine(const gwp_asan::AllocatorState * State, uintptr_t ErrorPtr)'/>
<use f='llvm/compiler-rt/lib/gwp_asan/crash_handler.cpp' l='49' u='c' c='__gwp_asan_diagnose_error'/>
<use f='llvm/compiler-rt/lib/gwp_asan/crash_handler.cpp' l='85' u='c' c='__gwp_asan_get_metadata'/>
<dec f='llvm/compiler-rt/lib/gwp_asan/crash_handler.h' l='38' type='bool __gwp_asan_error_is_mine(const gwp_asan::AllocatorState * State, uintptr_t ErrorPtr = 0U)'/>
<use f='llvm/compiler-rt/lib/gwp_asan/optional/segv_handler_posix.cpp' l='96' u='c' c='_ZN12_GLOBAL__N_110dumpReportEjPKN8gwp_asan14AllocatorStateEPKNS0_18AllocationMetadataEPFjPjjPvEPFvPKczEPFvS7_jSE_ES8_'/>
<use f='llvm/compiler-rt/lib/gwp_asan/optional/segv_handler_posix.cpp' l='183' u='c' c='_ZN12_GLOBAL__N_114sigSegvHandlerEiP9siginfo_tPv'/>
<doc f='llvm/compiler-rt/lib/gwp_asan/crash_handler.h' l='23'>// When a process crashes, there are three possible outcomes:
//  1. The crash is unrelated to GWP-ASan - in which case this function returns
//     false.
//  2. The crash is internally detected within GWP-ASan itself (e.g. a
//     double-free bug is caught in GuardedPoolAllocator::deallocate(), and
//     GWP-ASan will terminate the process). In this case - this function
//     returns true.
//  3. The crash is caused by a memory error at `AccessPtr` that&apos;s caught by the
//     system, but GWP-ASan is responsible for the allocation. In this case -
//     the function also returns true.
// This function takes an optional `AccessPtr` parameter. If the pointer that
// was attempted to be accessed is available, you should provide it here. In the
// case of some internally-detected errors, the crash may manifest as an abort
// or trap may or may not have an associated pointer. In these cases, the
// pointer can be obtained by a call to __gwp_asan_get_internal_crash_address.</doc>
