<dec f='llvm/llvm/lib/CodeGen/AsmPrinter/WinException.h' l='47' type='void llvm::WinException::emitCSpecificHandlerTable(const llvm::MachineFunction * MF)'/>
<use f='llvm/llvm/lib/CodeGen/AsmPrinter/WinException.cpp' l='155' u='c' c='_ZN4llvm12WinException11endFunctionEPKNS_15MachineFunctionE'/>
<use f='llvm/llvm/lib/CodeGen/AsmPrinter/WinException.cpp' l='279' u='c' c='_ZN4llvm12WinException14endFuncletImplEv'/>
<def f='llvm/llvm/lib/CodeGen/AsmPrinter/WinException.cpp' l='556' ll='620' type='void llvm::WinException::emitCSpecificHandlerTable(const llvm::MachineFunction * MF)'/>
<doc f='llvm/llvm/lib/CodeGen/AsmPrinter/WinException.cpp' l='528'>/// Emit the language-specific data that __C_specific_handler expects.  This
/// handler lives in the x64 Microsoft C runtime and allows catching or cleaning
/// up after faults with __try, __except, and __finally.  The typeinfo values
/// are not really RTTI data, but pointers to filter functions that return an
/// integer (1, 0, or -1) indicating how to handle the exception. For __finally
/// blocks and other cleanups, the landing pad label is zero, and the filter
/// function is actually a cleanup handler with the same prototype.  A catch-all
/// entry is modeled with a null filter function field and a non-zero landing
/// pad label.
///
/// Possible filter function return values:
///   EXCEPTION_EXECUTE_HANDLER (1):
///     Jump to the landing pad label after cleanups.
///   EXCEPTION_CONTINUE_SEARCH (0):
///     Continue searching this table or continue unwinding.
///   EXCEPTION_CONTINUE_EXECUTION (-1):
///     Resume execution at the trapping PC.
///
/// Inferred table structure:
///   struct Table {
///     int NumEntries;
///     struct Entry {
///       imagerel32 LabelStart;
///       imagerel32 LabelEnd;
///       imagerel32 FilterOrFinally;  // One means catch-all.
///       imagerel32 LabelLPad;        // Zero means __finally.
///     } Entries[NumEntries];
///   };</doc>
