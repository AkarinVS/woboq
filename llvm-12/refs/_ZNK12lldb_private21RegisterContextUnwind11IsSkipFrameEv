<dec f='llvm/lldb/include/lldb/Target/RegisterContextUnwind.h' l='111' type='bool lldb_private::RegisterContextUnwind::IsSkipFrame() const'/>
<def f='llvm/lldb/source/Target/RegisterContextUnwind.cpp' l='1113' ll='1115' type='bool lldb_private::RegisterContextUnwind::IsSkipFrame() const'/>
<doc f='llvm/lldb/source/Target/RegisterContextUnwind.cpp' l='1105'>// A skip frame is a bogus frame on the stack -- but one where we&apos;re likely to
// find a real frame farther
// up the stack if we keep looking.  It&apos;s always the second frame in an unwind
// (i.e. the first frame after frame zero) where unwinding can be the
// trickiest.  Ideally we&apos;ll mark up this frame in some way so the user knows
// we&apos;re displaying bad data and we may have skipped one frame of their real
// program in the process of getting back on track.</doc>
<doc f='llvm/lldb/include/lldb/Target/RegisterContextUnwind.h' l='101'>// A SkipFrame occurs when the unwind out of frame 0 didn&apos;t go right -- we&apos;ve
  // got one bogus frame at frame #1.
  // There is a good chance we&apos;ll get back on track if we follow the frame
  // pointer chain (or whatever is appropriate
  // on this ABI) so we allow one invalid frame to be in the stack.  Ideally
  // we&apos;ll mark this frame specially at some
  // point and indicate to the user that the unwinder had a hiccup.  Often when
  // this happens we will miss a frame of
  // the program&apos;s actual stack in the unwind and we want to flag that for the
  // user somehow.</doc>
