<dec f='llvm/llvm/include/llvm/Support/SuffixTree.h' l='83' type='llvm::SuffixTreeNode *'/>
<use f='llvm/llvm/include/llvm/Support/SuffixTree.h' l='110' u='w' c='_ZN4llvm14SuffixTreeNodeC1EjPjPS0_'/>
<offset>384</offset>
<doc f='llvm/llvm/include/llvm/Support/SuffixTree.h' l='65'>/// For internal nodes, a pointer to the internal node representing
  /// the same sequence with the first character chopped off.
  ///
  /// This acts as a shortcut in Ukkonen&apos;s algorithm. One of the things that
  /// Ukkonen&apos;s algorithm does to achieve linear-time construction is
  /// keep track of which node the next insert should be at. This makes each
  /// insert O(1), and there are a total of O(N) inserts. The suffix link
  /// helps with inserting children of internal nodes.
  ///
  /// Say we add a child to an internal node with associated mapping S. The
  /// next insertion must be at the node representing S - its first character.
  /// This is given by the way that we iteratively build the tree in Ukkonen&apos;s
  /// algorithm. The main idea is to look at the suffixes of each prefix in the
  /// string, starting with the longest suffix of the prefix, and ending with
  /// the shortest. Therefore, if we keep pointers between such nodes, we can
  /// move to the next insertion point in O(1) time. If we don&apos;t, then we&apos;d
  /// have to query from the root, which takes O(N) time. This would make the
  /// construction algorithm O(N^2) rather than O(N).</doc>
<use f='llvm/llvm/lib/Support/SuffixTree.cpp' l='121' u='w' c='_ZN4llvm10SuffixTree6extendEjj'/>
<use f='llvm/llvm/lib/Support/SuffixTree.cpp' l='152' u='w' c='_ZN4llvm10SuffixTree6extendEjj'/>
<use f='llvm/llvm/lib/Support/SuffixTree.cpp' l='189' u='w' c='_ZN4llvm10SuffixTree6extendEjj'/>
<use f='llvm/llvm/lib/Support/SuffixTree.cpp' l='205' u='r' c='_ZN4llvm10SuffixTree6extendEjj'/>
