<def f='llvm/llvm/include/llvm/DebugInfo/GSYM/LineTable.h' l='118' ll='226'/>
<use f='llvm/llvm/include/llvm/DebugInfo/GSYM/LineTable.h' l='154' c='_ZN4llvm4gsym9LineTable6decodeERNS_13DataExtractorEm'/>
<use f='llvm/llvm/include/llvm/DebugInfo/GSYM/LineTable.h' l='210' c='_ZNK4llvm4gsym9LineTableeqERKS1_'/>
<use f='llvm/llvm/include/llvm/DebugInfo/GSYM/LineTable.h' l='213' c='_ZNK4llvm4gsym9LineTableneERKS1_'/>
<use f='llvm/llvm/include/llvm/DebugInfo/GSYM/LineTable.h' l='216' c='_ZNK4llvm4gsym9LineTableltERKS1_'/>
<use f='llvm/llvm/include/llvm/DebugInfo/GSYM/LineTable.h' l='228' c='_ZN4llvm4gsymlsERNS_11raw_ostreamERKNS0_9LineTableE'/>
<use f='llvm/llvm/include/llvm/DebugInfo/GSYM/FunctionInfo.h' l='91'/>
<use f='llvm/llvm/include/llvm/DebugInfo/GSYM/GsymReader.h' l='174' c='_ZN4llvm4gsym10GsymReader4dumpERNS_11raw_ostreamERKNS0_9LineTableE'/>
<use f='llvm/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp' l='269' c='_ZL24convertFunctionLineTableRN4llvm11raw_ostreamERNS_4gsym6CUInfoENS_8DWARFDieERNS2_11GsymCreatorERNS2_12FunctionInfoE'/>
<use f='llvm/llvm/lib/DebugInfo/GSYM/DwarfTransformer.cpp' l='278' c='_ZL24convertFunctionLineTableRN4llvm11raw_ostreamERNS_4gsym6CUInfoENS_8DWARFDieERNS2_11GsymCreatorERNS2_12FunctionInfoE'/>
<size>24</size>
<doc f='llvm/llvm/include/llvm/DebugInfo/GSYM/LineTable.h' l='23'>/// LineTable class contains deserialized versions of line tables for each
/// function&apos;s address ranges.
///
/// When saved to disk, the line table is encoded using a modified version of
/// the DWARF line tables that only tracks address to source file and line.
///
/// ENCODING
///
/// The line table starts with a small prolog that contains the following
/// values:
///
/// ENCODING NAME        DESCRIPTION
/// ======== =========== ====================================================
/// SLEB     MinDelta    The min line delta for special opcodes that  advance
///                      the address and line number.
/// SLEB     MaxDelta    The max line delta for single byte opcodes that
///                      advance the address and line number.
/// ULEB     FirstLine   The value of the first source line number to
///                      initialize the LineEntry with.
///
/// Once these prolog items are read, we initialize a LineEntry struct with
/// the start address of the function from the FunctionInfo&apos;s address range,
/// a default file index of 1, and the line number set to &quot;FirstLine&quot; from
/// the prolog above:
///
///   LineEntry Row(BaseAddr, 1, FirstLine);
///
/// The line table state machine is now initialized and ready to be parsed.
/// The stream that follows this encodes the line entries in a compact
/// form. Some opcodes cause &quot;Row&quot; to be modified and some opcodes may also
/// push &quot;Row&quot; onto the end of the &quot;LineTable.Lines&quot; vector. The end result
/// is a vector of LineEntry structs that is sorted in ascending address
/// order.
///
/// NORMAL OPCODES
///
/// The opcodes 0 through 3 are normal in opcodes. Their encoding and
/// descriptions are listed below:
///
/// ENCODING ENUMERATION       VALUE DESCRIPTION
/// ======== ================  ===== ========================================
///          LTOC_EndSequence  0x00  Parsing is done.
/// ULEB     LTOC_SetFile      0x01  Row.File = ULEB
/// ULEB     LTOC_AdvancePC    0x02  Row.Addr += ULEB, push &quot;Row&quot;.
/// SLEB     LTOC_AdvanceLine  0x03  Row.Line += SLEB
///          LTOC_FirstSpecial 0x04  First special opcode (see SPECIAL
///                                  OPCODES below).
///
/// SPECIAL OPCODES
///
/// Opcodes LTOC_FirstSpecial through 255 are special opcodes that always
/// increment both the Row.Addr and Row.Line and push &quot;Row&quot; onto the
/// LineEntry.Lines array. They do this by using some of the bits to
/// increment/decrement the source line number, and some of the bits to
/// increment the address. Line numbers can go up or down when making line
/// tables, where addresses always only increase since line tables are sorted
/// by address.
///
/// In order to calculate the amount to increment the line and address for
/// these special opcodes, we calculate the number of values reserved for the
/// line increment/decrement using the &quot;MinDelta&quot; and &quot;MaxDelta&quot; from the
/// prolog:
///
///     const int64_t LineRange = MaxDelta - MinDelta + 1;
///
/// Then we can adjust the opcode to not include any of the normal opcodes:
///
///     const uint8_t AdjustedOp = Opcode - LTOC_FirstSpecial;
///
/// And we can calculate the line offset, and address offset:
///
///     const int64_t LineDelta = MinDelta + (AdjustedOp % LineRange);
///     const uint64_t AddrDelta = (AdjustedOp / LineRange);
///
/// And use these to modify our &quot;Row&quot;:
///
///     Row.Line += LineDelta;
///     Row.Addr += AddrDelta;
///
/// And push a row onto the line table:
///
///     Lines.push_back(Row);
///
/// This is verify similar to the way that DWARF encodes its line tables. The
/// only difference is the DWARF line tables have more normal opcodes and the
/// &quot;Row&quot; contains more members, like source column number, bools for end of
/// prologue, beginnging of epilogue, is statement and many others. There are
/// also more complex rules that happen for the extra normal opcodes. By
/// leaving these extra opcodes out, we leave more bits for the special
/// opcodes that allows us to encode line tables in fewer bytes than standard
/// DWARF encodings.
///
/// Opcodes that will push &quot;Row&quot; onto the LineEntry.Lines include the
/// LTOC_AdvancePC opcode and all special opcodes. All other opcodes
/// only modify the current &quot;Row&quot;, or cause the line table to end.</doc>
<mbr r='llvm::gsym::LineTable::Lines' o='0' t='llvm::gsym::LineTable::Collection'/>
<fun r='_ZN4llvm4gsym9LineTable6lookupERNS_13DataExtractorEmm'/>
<fun r='_ZN4llvm4gsym9LineTable6decodeERNS_13DataExtractorEm'/>
<fun r='_ZNK4llvm4gsym9LineTable6encodeERNS0_10FileWriterEm'/>
<fun r='_ZNK4llvm4gsym9LineTable5emptyEv'/>
<fun r='_ZN4llvm4gsym9LineTable5clearEv'/>
<fun r='_ZNK4llvm4gsym9LineTable5firstEv'/>
<fun r='_ZNK4llvm4gsym9LineTable4lastEv'/>
<fun r='_ZN4llvm4gsym9LineTable4pushERKNS0_9LineEntryE'/>
<fun r='_ZNK4llvm4gsym9LineTable7isValidEv'/>
<fun r='_ZNK4llvm4gsym9LineTable4sizeEv'/>
<fun r='_ZN4llvm4gsym9LineTable3getEm'/>
<fun r='_ZNK4llvm4gsym9LineTable3getEm'/>
<fun r='_ZN4llvm4gsym9LineTableixEm'/>
<fun r='_ZNK4llvm4gsym9LineTableixEm'/>
<fun r='_ZNK4llvm4gsym9LineTableeqERKS1_'/>
<fun r='_ZNK4llvm4gsym9LineTableneERKS1_'/>
<fun r='_ZNK4llvm4gsym9LineTableltERKS1_'/>
<fun r='_ZNK4llvm4gsym9LineTable5beginEv'/>
<fun r='_ZNK4llvm4gsym9LineTable3endEv'/>
<use f='llvm/llvm/lib/DebugInfo/GSYM/FunctionInfo.cpp' l='76' c='_ZN4llvm4gsym12FunctionInfo6decodeERNS_13DataExtractorEm'/>
<size>24</size>
<use f='llvm/llvm/lib/DebugInfo/GSYM/GsymReader.cpp' l='357' c='_ZN4llvm4gsym10GsymReader4dumpERNS_11raw_ostreamERKNS0_9LineTableE'/>
<size>24</size>
<use f='llvm/llvm/lib/DebugInfo/GSYM/LineTable.cpp' l='251' c='_ZN4llvm4gsym9LineTable6decodeERNS_13DataExtractorEm'/>
<use f='llvm/llvm/lib/DebugInfo/GSYM/LineTable.cpp' l='253' c='_ZN4llvm4gsym9LineTable6decodeERNS_13DataExtractorEm'/>
<use f='llvm/llvm/lib/DebugInfo/GSYM/LineTable.cpp' l='289' c='_ZN4llvm4gsymlsERNS_11raw_ostreamERKNS0_9LineTableE'/>
<size>24</size>
<fun r='_ZNK4llvm4gsym9LineTable6encodeERNS0_10FileWriterEm'/>
<fun r='_ZN4llvm4gsym9LineTable6decodeERNS_13DataExtractorEm'/>
<fun r='_ZN4llvm4gsym9LineTable6lookupERNS_13DataExtractorEmm'/>
<use f='llvm/llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp' l='102' c='_ZN30GSYMTest_TestFunctionInfo_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp' l='138' c='_ZN30GSYMTest_TestFunctionInfo_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp' l='232' c='_ZN42GSYMTest_TestFunctionInfoEncodeErrors_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp' l='266' c='_ZL8AddLinesmjRN4llvm4gsym12FunctionInfoE'/>
<use f='llvm/llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp' l='803' c='_ZL19TestLineTableHelperN4llvm7support10endiannessERKNS_4gsym9LineTableE'/>
<use f='llvm/llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp' l='813' c='_ZL19TestLineTableHelperN4llvm7support10endiannessERKNS_4gsym9LineTableE'/>
<use f='llvm/llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp' l='823' c='_ZN27GSYMTest_TestLineTable_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp' l='854' c='_ZN27GSYMTest_TestLineTable_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp' l='855' c='_ZN27GSYMTest_TestLineTable_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp' l='883' c='_ZL24TestLineTableDecodeErrorN4llvm7support10endiannessENS_9StringRefEmNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE'/>
<use f='llvm/llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp' l='933' c='_ZN39GSYMTest_TestLineTableEncodeErrors_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp' l='1103' c='_ZN41GSYMTest_TestGsymCreatorEncodeErrors_Test8TestBodyEv'/>
<use f='llvm/llvm/unittests/DebugInfo/GSYM/GSYMTest.cpp' l='1318' c='_ZN29GSYMTest_TestGsymLookups_Test8TestBodyEv'/>
<size>24</size>
