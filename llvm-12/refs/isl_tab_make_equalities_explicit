<dec f='llvm/polly/lib/External/isl/isl_tab.h' l='201' type='isl_basic_map * isl_tab_make_equalities_explicit(struct isl_tab * tab, isl_basic_map * bmap)'/>
<use f='llvm/polly/lib/External/isl/isl_coalesce.c' l='4217' u='c' c='isl_map_coalesce'/>
<def f='llvm/polly/lib/External/isl/isl_tab.c' l='3201' ll='3229' type='isl_basic_map * isl_tab_make_equalities_explicit(struct isl_tab * tab, isl_basic_map * bmap)'/>
<doc f='llvm/polly/lib/External/isl/isl_tab.c' l='3168'>/* Make the equalities that are implicit in &quot;bmap&quot; but that have been
 * detected in the corresponding &quot;tab&quot; explicit in &quot;bmap&quot; and update
 * &quot;tab&quot; to reflect the new order of the constraints.
 *
 * In particular, if inequality i is an implicit equality then
 * isl_basic_map_inequality_to_equality will move the inequality
 * in front of the other equality and it will move the last inequality
 * in the position of inequality i.
 * In the tableau, the inequalities of &quot;bmap&quot; are stored after the equalities
 * and so the original order
 *
 *		E E E E E A A A I B B B B L
 *
 * is changed into
 *
 *		I E E E E E A A A L B B B B
 *
 * where I is the implicit equality, the E are equalities,
 * the A inequalities before I, the B inequalities after I and
 * L the last inequality.
 * We therefore need to rotate to the right two sets of constraints,
 * those up to and including I and those after I.
 *
 * If &quot;tab&quot; contains any constraints that are not in &quot;bmap&quot; then they
 * appear after those in &quot;bmap&quot; and they should be left untouched.
 *
 * Note that this function only calls isl_basic_map_gauss
 * (in case some equality constraints got detected)
 * if &quot;bmap&quot; has more than one reference.
 * If it only has a single reference, then it is left in a temporary state,
 * because the caller may require this state.
 * Calling isl_basic_map_gauss is then the responsibility of the caller.
 */</doc>
