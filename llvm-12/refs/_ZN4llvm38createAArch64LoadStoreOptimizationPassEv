<dec f='llvm/llvm/lib/Target/AArch64/AArch64.h' l='44' type='llvm::FunctionPass * llvm::createAArch64LoadStoreOptimizationPass()'/>
<def f='llvm/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp' l='2175' ll='2177' type='llvm::FunctionPass * llvm::createAArch64LoadStoreOptimizationPass()'/>
<doc f='llvm/llvm/lib/Target/AArch64/AArch64LoadStoreOptimizer.cpp' l='2163'>// FIXME: Do we need/want a pre-alloc pass like ARM has to try to keep loads and
// stores near one another?  Note: The pre-RA instruction scheduler already has
// hooks to try and schedule pairable loads/stores together to improve pairing
// opportunities.  Thus, pre-RA pairing pass may not be worth the effort.

// FIXME: When pairing store instructions it&apos;s very possible for this pass to
// hoist a store with a KILL marker above another use (without a KILL marker).
// The resulting IR is invalid, but nothing uses the KILL markers after this
// pass, so it&apos;s never caused a problem in practice.

/// createAArch64LoadStoreOptimizationPass - returns an instance of the
/// load / store optimization pass.</doc>
<use f='llvm/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp' l='642' u='c' c='_ZN12_GLOBAL__N_117AArch64PassConfig12addPreSched2Ev'/>
<use f='llvm/llvm/lib/Target/AArch64/AArch64TargetMachine.cpp' l='666' u='c' c='_ZN12_GLOBAL__N_117AArch64PassConfig14addPreEmitPassEv'/>
