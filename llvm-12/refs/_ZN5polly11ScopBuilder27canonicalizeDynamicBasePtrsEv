<dec f='llvm/polly/include/polly/ScopBuilder.h' l='767' type='void polly::ScopBuilder::canonicalizeDynamicBasePtrs()'/>
<def f='llvm/polly/lib/Analysis/ScopBuilder.cpp' l='3188' ll='3216' type='void polly::ScopBuilder::canonicalizeDynamicBasePtrs()'/>
<use f='llvm/polly/lib/Analysis/ScopBuilder.cpp' l='3769' u='c' c='_ZN5polly11ScopBuilder9buildScopERN4llvm6RegionERNS1_15AssumptionCacheE'/>
<doc f='llvm/polly/include/polly/ScopBuilder.h' l='741'>/// Canonicalize arrays with base pointers from the same equivalence class.
  ///
  /// Some context: in our normal model we assume that each base pointer is
  /// related to a single specific memory region, where memory regions
  /// associated with different base pointers are disjoint. Consequently we do
  /// not need to compute additional data dependences that model possible
  /// overlaps of these memory regions. To verify our assumption we compute
  /// alias checks that verify that modeled arrays indeed do not overlap. In
  /// case an overlap is detected the runtime check fails and we fall back to
  /// the original code.
  ///
  /// In case of arrays where the base pointers are know to be identical,
  /// because they are dynamically loaded by accesses that are in the same
  /// invariant load equivalence class, such run-time alias check would always
  /// be false.
  ///
  /// This function makes sure that we do not generate consistently failing
  /// run-time checks for code that contains distinct arrays with known
  /// equivalent base pointers. It identifies for each invariant load
  /// equivalence class a single canonical array and canonicalizes all memory
  /// accesses that reference arrays that have base pointers that are known to
  /// be equal to the base pointer of such a canonical array to this canonical
  /// array.
  ///
  /// We currently do not canonicalize arrays for which certain memory accesses
  /// have been hoisted as loop invariant.</doc>
