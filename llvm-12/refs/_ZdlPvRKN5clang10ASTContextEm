<dec f='llvm/clang/include/clang/AST/ASTContextAllocate.h' l='34' type='void operator delete(void * Ptr, const clang::ASTContext &amp; C, size_t )'/>
<def f='llvm/clang/include/clang/AST/ASTContext.h' l='3184' ll='3186' type='void operator delete(void * Ptr, const clang::ASTContext &amp; C, size_t )'/>
<use f='llvm/clang/include/clang/AST/Attr.h' l='75' u='c' c='_ZN5clang4AttrdlEPvRNS_10ASTContextEm'/>
<doc f='llvm/clang/include/clang/AST/ASTContext.h' l='3178'>/// Placement delete companion to the new above.
///
/// This operator is just a companion to the new above. There is no way of
/// invoking it directly; see the new operator for more details. This operator
/// is called implicitly by the compiler if a placement new expression using
/// the ASTContext throws in the object constructor.</doc>
<doc f='llvm/clang/include/clang/AST/ASTContextAllocate.h' l='31'>// It is good practice to pair new/delete operators.  Also, MSVC gives many
// warnings if a matching delete overload is not declared, even though the
// throw() spec guarantees it will not be implicitly called.</doc>
