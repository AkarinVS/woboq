<dec f='llvm/llvm/tools/opt/NewPMDriver.h' l='66' type='bool llvm::runPassPipeline(llvm::StringRef Arg0, llvm::Module &amp; M, llvm::TargetMachine * TM, llvm::TargetLibraryInfoImpl * TLII, llvm::ToolOutputFile * Out, llvm::ToolOutputFile * ThinLinkOut, llvm::ToolOutputFile * OptRemarkFile, llvm::StringRef PassPipeline, ArrayRef&lt;llvm::StringRef&gt; PassInfos, opt_tool::OutputKind OK, opt_tool::VerifierKind VK, bool ShouldPreserveAssemblyUseListOrder, bool ShouldPreserveBitcodeUseListOrder, bool EmitSummaryIndex, bool EmitModuleHash, bool EnableDebugify, bool Coroutines)'/>
<def f='llvm/llvm/tools/opt/NewPMDriver.cpp' l='229' ll='465' type='bool llvm::runPassPipeline(llvm::StringRef Arg0, llvm::Module &amp; M, llvm::TargetMachine * TM, llvm::TargetLibraryInfoImpl * TLII, llvm::ToolOutputFile * Out, llvm::ToolOutputFile * ThinLTOLinkOut, llvm::ToolOutputFile * OptRemarkFile, llvm::StringRef PassPipeline, ArrayRef&lt;llvm::StringRef&gt; Passes, llvm::opt_tool::OutputKind OK, llvm::opt_tool::VerifierKind VK, bool ShouldPreserveAssemblyUseListOrder, bool ShouldPreserveBitcodeUseListOrder, bool EmitSummaryIndex, bool EmitModuleHash, bool EnableDebugify, bool Coroutines)'/>
<doc f='llvm/llvm/tools/opt/NewPMDriver.h' l='57'>/// Driver function to run the new pass manager over a module.
///
/// This function only exists factored away from opt.cpp in order to prevent
/// inclusion of the new pass manager headers and the old headers into the same
/// file. It&apos;s interface is consequentially somewhat ad-hoc, but will go away
/// when the transition finishes.
///
/// ThinLTOLinkOut is only used when OK is OK_OutputThinLTOBitcode, and can be
/// nullptr.</doc>
<use f='llvm/llvm/tools/opt/opt.cpp' l='787' u='c' c='main'/>
