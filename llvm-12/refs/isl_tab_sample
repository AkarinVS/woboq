<dec f='llvm/polly/lib/External/isl/isl_sample.h' l='30' type='isl_vec * isl_tab_sample(struct isl_tab * tab)'/>
<use f='llvm/polly/lib/External/isl/isl_affine_hull.c' l='302' u='c' c='outside_point'/>
<use f='llvm/polly/lib/External/isl/isl_affine_hull.c' l='539' u='c' c='uset_affine_hull_bounded'/>
<def f='llvm/polly/lib/External/isl/isl_sample.c' l='378' ll='530' type='isl_vec * isl_tab_sample(struct isl_tab * tab)'/>
<use f='llvm/polly/lib/External/isl/isl_sample.c' l='667' u='c' c='sample_bounded'/>
<doc f='llvm/polly/lib/External/isl/isl_sample.c' l='323'>/* Given a tableau representing a set, find and return
 * an integer point in the set, if there is any.
 *
 * We perform a depth first search
 * for an integer point, by scanning all possible values in the range
 * attained by a basis vector, where an initial basis may have been set
 * by the calling function.  Otherwise an initial basis that exploits
 * the equalities in the tableau is created.
 * tab-&gt;n_zero is currently ignored and is clobbered by this function.
 *
 * The tableau is allowed to have unbounded direction, but then
 * the calling function needs to set an initial basis, with the
 * unbounded directions last and with tab-&gt;n_unbounded set
 * to the number of unbounded directions.
 * Furthermore, the calling functions needs to add shifted copies
 * of all constraints involving unbounded directions to ensure
 * that any feasible rational value in these directions can be rounded
 * up to yield a feasible integer value.
 * In particular, let B define the given basis x&apos; = B x
 * and let T be the inverse of B, i.e., X = T x&apos;.
 * Let a x + c &gt;= 0 be a constraint of the set represented by the tableau,
 * or a T x&apos; + c &gt;= 0 in terms of the given basis.  Assume that
 * the bounded directions have an integer value, then we can safely
 * round up the values for the unbounded directions if we make sure
 * that x&apos; not only satisfies the original constraint, but also
 * the constraint &quot;a T x&apos; + c + s &gt;= 0&quot; with s the sum of all
 * negative values in the last n_unbounded entries of &quot;a T&quot;.
 * The calling function therefore needs to add the constraint
 * a x + c + s &gt;= 0.  The current function then scans the first
 * directions for an integer value and once those have been found,
 * it can compute &quot;T ceil(B x)&quot; to yield an integer point in the set.
 * Note that during the search, the first rows of B may be changed
 * by a basis reduction, but the last n_unbounded rows of B remain
 * unaltered and are also not mixed into the first rows.
 *
 * The search is implemented iteratively.  &quot;level&quot; identifies the current
 * basis vector.  &quot;init&quot; is true if we want the first value at the current
 * level and false if we want the next value.
 *
 * At the start of each level, we first check if we can find a solution
 * using greedy search.  If not, we continue with the exhaustive search.
 *
 * The initial basis is the identity matrix.  If the range in some direction
 * contains more than one integer value, we perform basis reduction based
 * on the value of ctx-&gt;opt-&gt;gbr
 *	- ISL_GBR_NEVER:	never perform basis reduction
 *	- ISL_GBR_ONCE:		only perform basis reduction the first
 *				time such a range is encountered
 *	- ISL_GBR_ALWAYS:	always perform basis reduction when
 *				such a range is encountered
 *
 * When ctx-&gt;opt-&gt;gbr is set to ISL_GBR_ALWAYS, then we allow the basis
 * reduction computation to return early.  That is, as soon as it
 * finds a reasonable first direction.
 */</doc>
<use f='llvm/polly/lib/External/isl/isl_tab_pip.c' l='3038' u='c' c='gbr_get_sample'/>
