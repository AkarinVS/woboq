<dec f='llvm/llvm/lib/Target/AArch64/AArch64ISelLowering.h' l='939' type='llvm::SDValue llvm::AArch64TargetLowering::LowerSVEStructLoad(unsigned int Intrinsic, ArrayRef&lt;llvm::SDValue&gt; LoadOps, llvm::EVT VT, llvm::SelectionDAG &amp; DAG, const llvm::SDLoc &amp; DL) const'/>
<def f='llvm/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp' l='11349' ll='11379' type='llvm::SDValue llvm::AArch64TargetLowering::LowerSVEStructLoad(unsigned int Intrinsic, ArrayRef&lt;llvm::SDValue&gt; LoadOps, llvm::EVT VT, llvm::SelectionDAG &amp; DAG, const llvm::SDLoc &amp; DL) const'/>
<use f='llvm/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp' l='15882' u='c' c='_ZNK4llvm21AArch64TargetLowering17PerformDAGCombineEPNS_6SDNodeERNS_14TargetLowering15DAGCombinerInfoE'/>
<doc f='llvm/llvm/lib/Target/AArch64/AArch64ISelLowering.cpp' l='11329'>// Lower an SVE structured load intrinsic returning a tuple type to target
// specific intrinsic taking the same input but returning a multi-result value
// of the split tuple type.
//
// E.g. Lowering an LD3:
//
//  call &lt;vscale x 12 x i32&gt; @llvm.aarch64.sve.ld3.nxv12i32(
//                                                    &lt;vscale x 4 x i1&gt; %pred,
//                                                    &lt;vscale x 4 x i32&gt;* %addr)
//
//  Output DAG:
//
//    t0: ch = EntryToken
//        t2: nxv4i1,ch = CopyFromReg t0, Register:nxv4i1 %0
//        t4: i64,ch = CopyFromReg t0, Register:i64 %1
//    t5: nxv4i32,nxv4i32,nxv4i32,ch = AArch64ISD::SVE_LD3 t0, t2, t4
//    t6: nxv12i32 = concat_vectors t5, t5:1, t5:2
//
// This is called pre-legalization to avoid widening/splitting issues with
// non-power-of-2 tuple types used for LD3, such as nxv12i32.</doc>
