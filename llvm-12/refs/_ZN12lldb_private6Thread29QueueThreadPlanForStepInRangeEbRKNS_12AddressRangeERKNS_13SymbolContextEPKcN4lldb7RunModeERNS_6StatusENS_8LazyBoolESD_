<dec f='llvm/lldb/include/lldb/Target/Thread.h' l='744' type='lldb::ThreadPlanSP lldb_private::Thread::QueueThreadPlanForStepInRange(bool abort_other_plans, const lldb_private::AddressRange &amp; range, const lldb_private::SymbolContext &amp; addr_context, const char * step_in_target, lldb::RunMode stop_other_threads, lldb_private::Status &amp; status, lldb_private::LazyBool step_in_avoids_code_without_debug_info = eLazyBoolCalculate, lldb_private::LazyBool step_out_avoids_code_without_debug_info = eLazyBoolCalculate)'/>
<doc f='llvm/lldb/include/lldb/Target/Thread.h' l='697'>/// Queues the plan used to step through an address range, stepping into
  /// functions.
  ///
  /// \param[in] abort_other_plans
  ///    \b true if we discard the currently queued plans and replace them with
  ///    this one.
  ///    Otherwise this plan will go on the end of the plan stack.
  ///
  /// \param[in] type
  ///    Type of step to do, only eStepTypeInto and eStepTypeOver are supported
  ///    by this plan.
  ///
  /// \param[in] range
  ///    The address range to step through.
  ///
  /// \param[in] addr_context
  ///    When dealing with stepping through inlined functions the current PC is
  ///    not enough information to know
  ///    what &quot;step&quot; means.  For instance a series of nested inline functions
  ///    might start at the same address.
  //     The \a addr_context provides the current symbol context the step
  ///    is supposed to be out of.
  //   FIXME: Currently unused.
  ///
  /// \param[in] step_in_target
  ///    Name if function we are trying to step into.  We will step out if we
  ///    don&apos;t land in that function.
  ///
  /// \param[in] stop_other_threads
  ///    \b true if we will stop other threads while we single step this one.
  ///
  /// \param[out] status
  ///     A status with an error if queuing failed.
  ///
  /// \param[in] step_in_avoids_code_without_debug_info
  ///    If eLazyBoolYes we will step out if we step into code with no debug
  ///    info.
  ///    If eLazyBoolCalculate we will consult the default set in the thread.
  ///
  /// \param[in] step_out_avoids_code_without_debug_info
  ///    If eLazyBoolYes, if the step over steps out it will continue to step
  ///    out till it comes to a frame with debug info.
  ///    If eLazyBoolCalculate, it will consult the default set in the thread.
  ///
  /// \return
  ///     A shared pointer to the newly queued thread plan, or nullptr if the
  ///     plan could not be queued.</doc>
<use f='llvm/lldb/source/API/SBThread.cpp' l='611' u='c' c='_ZN4lldb8SBThread8StepIntoEPKcjRNS_7SBErrorENS_7RunModeE'/>
<use f='llvm/lldb/source/API/SBThreadPlan.cpp' l='300' u='c' c='_ZN4lldb12SBThreadPlan29QueueThreadPlanForStepInRangeERNS_9SBAddressEmRNS_7SBErrorE'/>
<use f='llvm/lldb/source/Commands/CommandObjectThread.cpp' l='494' u='c' c='_ZN39CommandObjectThreadStepWithTypeAndScope9DoExecuteERN12lldb_private4ArgsERNS0_19CommandReturnObjectE'/>
<def f='llvm/lldb/source/Target/Thread.cpp' l='1286' ll='1304' type='lldb::ThreadPlanSP lldb_private::Thread::QueueThreadPlanForStepInRange(bool abort_other_plans, const lldb_private::AddressRange &amp; range, const lldb_private::SymbolContext &amp; addr_context, const char * step_in_target, lldb::RunMode stop_other_threads, lldb_private::Status &amp; status, lldb_private::LazyBool step_in_avoids_code_without_debug_info = eLazyBoolCalculate, lldb_private::LazyBool step_out_avoids_code_without_debug_info = eLazyBoolCalculate)'/>
<use f='llvm/lldb/source/Target/Thread.cpp' l='1314' u='c' c='_ZN12lldb_private6Thread29QueueThreadPlanForStepInRangeEbRKNS_9LineEntryERKNS_13SymbolContextEPKcN4lldb7RunModeERNS_6StatusENS_8LazyBoolESD_'/>
<use f='llvm/lldb/source/Target/ThreadPlanShouldStopHere.cpp' l='129' u='c' c='_ZN12lldb_private24ThreadPlanShouldStopHere27DefaultStepFromHereCallbackEPNS_10ThreadPlanERNS_5FlagsEN4lldb15FrameComparisonERNS_6StatusEPv'/>
