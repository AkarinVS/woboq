<dec f='llvm/lld/ELF/Target.h' l='222' type='void lld::elf::addPPC64SaveRestore()'/>
<def f='llvm/lld/ELF/Arch/PPC64.cpp' l='259' ll='276' type='void lld::elf::addPPC64SaveRestore()'/>
<doc f='llvm/lld/ELF/Arch/PPC64.cpp' l='248'>// Implements some save and restore functions as described by ELF V2 ABI to be
// compatible with GCC. With GCC -Os, when the number of call-saved registers
// exceeds a certain threshold, GCC generates _savegpr0_* _restgpr0_* calls and
// expects the linker to define them. See
// https://sourceware.org/pipermail/binutils/2002-February/017444.html and
// https://sourceware.org/pipermail/binutils/2004-August/036765.html . This is
// weird because libgcc.a would be the natural place. The linker generation
// approach has the advantage that the linker can generate multiple copies to
// avoid long branch thunks. However, we don&apos;t consider the advantage
// significant enough to complicate our trunk implementation, so we take the
// simple approach and synthesize .text sections providing the implementation.</doc>
<use f='llvm/lld/ELF/Writer.cpp' l='272' u='c' c='_ZN3lld3elf18addReservedSymbolsEv'/>
