<use f='llvm/lldb/include/lldb/Core/MappedHash.h' l='225' u='c' c='_ZNK10MappedHash11MemoryTable4FindEN4llvm9StringRefERNS0_4PairE'/>
<dec f='llvm/lldb/include/lldb/Core/MappedHash.h' l='279' type='MappedHash::MemoryTable::Result MappedHash::MemoryTable::GetHashDataForName(llvm::StringRef name, lldb::offset_t * hash_data_offset_ptr, MappedHash::MemoryTable::Pair &amp; pair) const'/>
<doc f='llvm/lldb/include/lldb/Core/MappedHash.h' l='265'>// This method must be implemented in any subclasses and it must try to
    // read one &quot;Pair&quot; at the offset pointed to by the &quot;hash_data_offset_ptr&quot;
    // parameter. This offset should be updated as bytes are consumed and a
    // value &quot;Result&quot; enum should be returned. If the &quot;name&quot; matches the full
    // name for the &quot;pair.key&quot; (which must be filled in by this call), then the
    // HashData in the pair (&quot;pair.value&quot;) should be extracted and filled in
    // and &quot;eResultKeyMatch&quot; should be returned. If &quot;name&quot; doesn&apos;t match this
    // string for the key, then &quot;eResultKeyMismatch&quot; should be returned and all
    // data for the current HashData must be consumed or skipped and the
    // &quot;hash_data_offset_ptr&quot; offset needs to be updated to point to the next
    // HashData. If the end of the HashData objects for a given hash value have
    // been reached, then &quot;eResultEndOfHashData&quot; should be returned. If
    // anything else goes wrong during parsing, return &quot;eResultError&quot; and the
    // corresponding &quot;Find()&quot; function will be canceled and return false.</doc>
<ovr f='llvm/lldb/source/Plugins/SymbolFile/DWARF/HashedNameToDIE.cpp' l='335' c='_ZNK15DWARFMappedHash11MemoryTable18GetHashDataForNameEN4llvm9StringRefEPmRN10MappedHash11MemoryTableIjNS_6HeaderESt6vectorINS_7DIEInfoESaIS8_EEE4PairE'/>
