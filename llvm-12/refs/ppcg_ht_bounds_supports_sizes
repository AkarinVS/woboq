<dec f='llvm/polly/lib/External/ppcg/hybrid.h' l='22' type='isl_bool ppcg_ht_bounds_supports_sizes(ppcg_ht_bounds * bounds, isl_multi_val * sizes)'/>
<def f='llvm/polly/lib/External/ppcg/hybrid.c' l='1991' ll='2018' type='isl_bool ppcg_ht_bounds_supports_sizes(ppcg_ht_bounds * bounds, isl_multi_val * sizes)'/>
<use f='llvm/polly/lib/External/ppcg/hybrid.c' l='2032' u='c' c='check_width'/>
<doc f='llvm/polly/lib/External/ppcg/hybrid.c' l='1963'>/* Is the tile size specified by &quot;sizes&quot; wide enough in the first space
 * dimension, i.e., the base of the hexagon?  This ensures that,
 * after hybrid tiling using &quot;bounds&quot; and these sizes,
 * neighboring hexagons in the same phase are far enough apart
 * that they do not depend on each other.
 * The test is only meaningful if the bounds are valid.
 *
 * Let st be (half) the size in the time dimension and s0 the base
 * size in the first space dimension.  Let delta be the dependence
 * distance in either positive or negative direction.  In principle,
 * it should be enough to have s0 + 1 &gt; delta, i.e., s0 &gt;= delta.
 * However, in case of fractional delta, the tile is not extended
 * with delta * (st - 1), but instead with floor(delta * (st - 1)).
 * The condition therefore needs to be adjusted to
 *
 *	s0 + 1 &gt; delta + 2 {delta * (st - 1)}
 *
 * (with {} the fractional part) to account for the two slanted sides.
 * The condition in the paper &quot;Hybrid Hexagonal/Classical Tiling for GPUs&quot;
 * translates to
 *
 *	s0 &gt;= delta + {delta * (st - 1)}
 *
 * Since 1 &gt; frac(delta * (st - 1)), this condition implies
 * the condition above.
 *
 * The condition is checked for both directions.
 */</doc>
