<dec f='llvm/compiler-rt/lib/asan/asan_interface_internal.h' l='116' type='void __asan_poison_memory_region(const volatile void * addr, __sanitizer::uptr size)'/>
<def f='llvm/compiler-rt/lib/asan/asan_poisoning.cpp' l='101' ll='139' type='void __asan_poison_memory_region(const volatile void * addr, __sanitizer::uptr size)'/>
<doc f='llvm/compiler-rt/lib/asan/asan_poisoning.cpp' l='91'>// Current implementation of __asan_(un)poison_memory_region doesn&apos;t check
// that user program (un)poisons the memory it owns. It poisons memory
// conservatively, and unpoisons progressively to make sure asan shadow
// mapping invariant is preserved (see detailed mapping description here:
// https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm).
//
// * if user asks to poison region [left, right), the program poisons
// at least [left, AlignDown(right)).
// * if user asks to unpoison region [left, right), the program unpoisons
// at most [AlignDown(left), right).</doc>
<use f='llvm/compiler-rt/lib/asan/asan_rtl.cpp' l='289' u='c' c='__asan::force_interface_symbols'/>
