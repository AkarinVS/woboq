<dec f='llvm/llvm/include/llvm/Analysis/ValueTracking.h' l='407' type='void llvm::getUnderlyingObjects(const llvm::Value * V, SmallVectorImpl&lt;const llvm::Value *&gt; &amp; Objects, llvm::LoopInfo * LI = nullptr, unsigned int MaxLookup = 6)'/>
<doc f='llvm/llvm/include/llvm/Analysis/ValueTracking.h' l='379'>/// This method is similar to getUnderlyingObject except that it can
  /// look through phi and select instructions and return multiple objects.
  ///
  /// If LoopInfo is passed, loop phis are further analyzed.  If a pointer
  /// accesses different objects in each iteration, we don&apos;t look through the
  /// phi node. E.g. consider this loop nest:
  ///
  ///   int **A;
  ///   for (i)
  ///     for (j) {
  ///        A[i][j] = A[i-1][j] * B[j]
  ///     }
  ///
  /// This is transformed by Load-PRE to stash away A[i] for the next iteration
  /// of the outer loop:
  ///
  ///   Curr = A[0];          // Prev_0
  ///   for (i: 1..N) {
  ///     Prev = Curr;        // Prev = PHI (Prev_0, Curr)
  ///     Curr = A[i];
  ///     for (j: 0..N) {
  ///        Curr[j] = Prev[j] * B[j]
  ///     }
  ///   }
  ///
  /// Since A[i] and A[i-1] are independent pointers, getUnderlyingObjects
  /// should not assume that Curr and Prev share the same underlying object thus
  /// it shouldn&apos;t look through the phi above.</doc>
<use f='llvm/llvm/lib/Analysis/GlobalsModRef.cpp' l='920' u='c' c='_ZN4llvm15GlobalsAAResult24getModRefInfoForArgumentEPKNS_8CallBaseEPKNS_11GlobalValueERNS_11AAQueryInfoE'/>
<use f='llvm/llvm/lib/Analysis/InstructionSimplify.cpp' l='2603' u='c' c='_ZL18computePointerICmpRKN4llvm10DataLayoutEPKNS_17TargetLibraryInfoEPKNS_13DominatorTreeENS_7CmpInst9PredicateEPNS_15AssumptionCacheEPKNS_11Instructi10406885'/>
<use f='llvm/llvm/lib/Analysis/InstructionSimplify.cpp' l='2604' u='c' c='_ZL18computePointerICmpRKN4llvm10DataLayoutEPKNS_17TargetLibraryInfoEPKNS_13DominatorTreeENS_7CmpInst9PredicateEPNS_15AssumptionCacheEPKNS_11Instructi10406885'/>
<use f='llvm/llvm/lib/Analysis/LoopAccessAnalysis.cpp' l='936' u='c' c='_ZN12_GLOBAL__N_114AccessAnalysis18processMemAccessesEv'/>
<def f='llvm/llvm/lib/Analysis/ValueTracking.cpp' l='4178' ll='4216' type='void llvm::getUnderlyingObjects(const llvm::Value * V, SmallVectorImpl&lt;const llvm::Value *&gt; &amp; Objects, llvm::LoopInfo * LI = nullptr, unsigned int MaxLookup = 6)'/>
<use f='llvm/llvm/lib/Analysis/ValueTracking.cpp' l='4257' u='c' c='_ZN4llvm30getUnderlyingObjectsForCodeGenEPKNS_5ValueERNS_15SmallVectorImplIPS0_EE'/>
<use f='llvm/llvm/lib/CodeGen/GlobalISel/IRTranslator.cpp' l='1850' u='c' c='_ZN4llvm12IRTranslator23translateKnownIntrinsicERKNS_8CallInstEjRNS_16MachineIRBuilderE'/>
<use f='llvm/llvm/lib/CodeGen/MachinePipeliner.cpp' l='725' u='c' c='_ZL20getUnderlyingObjectsPKN4llvm12MachineInstrERNS_15SmallVectorImplIPKNS_5ValueEEE'/>
<use f='llvm/llvm/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.cpp' l='6643' u='c' c='_ZN4llvm19SelectionDAGBuilder18visitIntrinsicCallERKNS_8CallInstEj'/>
<use f='llvm/llvm/lib/Target/Mips/MipsDelaySlotFiller.cpp' l='544' u='c' c='_ZNK12_GLOBAL__N_111MemDefsUses20getUnderlyingObjectsERKN4llvm12MachineInstrERNS1_15SmallVectorImplINS1_12PointerUnionIJPKNS1_5ValueEPKNS1_17PseudoSourceValueEEEEEE'/>
<use f='llvm/llvm/lib/Target/NVPTX/NVPTXISelDAGToDAG.cpp' l='707' u='c' c='_ZL13canLowerToLDGPN4llvm9MemSDNodeERKNS_14NVPTXSubtargetEjPNS_15MachineFunctionE'/>
<use f='llvm/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp' l='1533' u='c' c='_ZN12_GLOBAL__N_113DFSanFunction10loadShadowEPN4llvm5ValueEmmPNS1_11InstructionE'/>
<use f='llvm/llvm/lib/Transforms/Scalar/DeadStoreElimination.cpp' l='953' u='c' c='_ZL14handleEndBlockRN4llvm10BasicBlockEPNS_9AAResultsEPNS_23MemoryDependenceResultsEPKNS_17TargetLibraryInfoERNS_8DenseMapIPNS_11InstructionESt3mapIll11714691'/>
<use f='llvm/llvm/lib/Transforms/Utils/InlineFunction.cpp' l='1075' u='c' c='_ZL21AddAliasScopeMetadataRN4llvm8CallBaseERNS_8ValueMapIPKNS_5ValueENS_14WeakTrackingVHENS_14ValueMapConfigIS5_NS_3sys10SmartMutexILb0EEEEEEERKNS_10D5245488'/>
