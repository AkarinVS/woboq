<dec f='llvm/polly/lib/External/isl/include/isl/map.h' l='671' type='isl_map * isl_map_coalesce(isl_map * map)'/>
<use f='llvm/polly/lib/External/isl/include/isl/isl-noexceptions.h' l='8094' u='c' c='_ZNK3isl12noexceptions3map8coalesceEv'/>
<use f='llvm/polly/lib/External/isl/isl_ast_build.c' l='2384' u='c' c='isl_ast_build_get_separation_class'/>
<use f='llvm/polly/lib/External/isl/isl_ast_codegen.c' l='242' u='c' c='generate_domain'/>
<def f='llvm/polly/lib/External/isl/isl_coalesce.c' l='4179' ll='4243' type='isl_map * isl_map_coalesce(isl_map * map)'/>
<use f='llvm/polly/lib/External/isl/isl_coalesce.c' l='4251' u='c' c='isl_set_coalesce'/>
<doc f='llvm/polly/lib/External/isl/isl_coalesce.c' l='4154'>/* For each pair of basic maps in the map, check if the union of the two
 * can be represented by a single basic map.
 * If so, replace the pair by the single basic map and start over.
 *
 * We factor out any (hidden) common factor from the constraint
 * coefficients to improve the detection of adjacent constraints.
 * Note that this function does not call isl_basic_map_gauss,
 * but it does make sure that only a single copy of the basic map
 * is affected.  This means that isl_basic_map_gauss may have
 * to be called at the end of the computation (in update_basic_maps)
 * on this single copy to ensure that
 * the basic maps are not left in an unexpected state.
 *
 * Since we are constructing the tableaus of the basic maps anyway,
 * we exploit them to detect implicit equalities and redundant constraints.
 * This also helps the coalescing as it can ignore the redundant constraints.
 * In order to avoid confusion, we make all implicit equalities explicit
 * in the basic maps.  If the basic map only has a single reference
 * (this happens in particular if it was modified by
 * isl_basic_map_reduce_coefficients), then isl_basic_map_gauss
 * does not get called on the result.  The call to
 * isl_basic_map_gauss in update_basic_maps resolves this as well.
 * For each basic map, we also compute the hash of the apparent affine hull
 * for use in coalesce.
 */</doc>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2361' u='c' c='test_coalesce_special'/>
<use f='llvm/polly/lib/External/isl/isl_test.c' l='2370' u='c' c='test_coalesce_special'/>
<use f='llvm/polly/lib/External/isl/isl_transitive_closure.c' l='814' u='c' c='construct_extended_path'/>
<use f='llvm/polly/lib/External/isl/isl_transitive_closure.c' l='1138' u='c' c='compose'/>
<use f='llvm/polly/lib/External/isl/isl_transitive_closure.c' l='1574' u='c' c='floyd_warshall_iterate'/>
<use f='llvm/polly/lib/External/isl/isl_transitive_closure.c' l='2058' u='c' c='isl_map_power'/>
<use f='llvm/polly/lib/External/isl/isl_transitive_closure.c' l='2111' u='c' c='isl_map_reaching_path_lengths'/>
<use f='llvm/polly/lib/External/isl/isl_transitive_closure.c' l='2570' u='c' c='isl_map_transitive_closure'/>
<use f='llvm/polly/lib/External/isl/isl_power_templ.c' l='40' macro='1' u='c' c='isl_map_fixed_power'/>
<use f='llvm/polly/lib/External/isl/isl_power_templ.c' l='51' macro='1' u='c' c='isl_map_fixed_power'/>
<use f='llvm/polly/lib/External/isl/isl_union_map.c' l='2123' u='a' c='isl_union_map_coalesce'/>
<use f='llvm/polly/lib/External/ppcg/hybrid.c' l='1143' u='c' c='collect_deps'/>
