<dec f='llvm/polly/lib/External/isl/isl_ast_build_private.h' l='220' type='isl_ast_build * isl_ast_build_product(isl_ast_build * build, isl_space * embedding)'/>
<def f='llvm/polly/lib/External/isl/isl_ast_build.c' l='1834' ll='1908' type='isl_ast_build * isl_ast_build_product(isl_ast_build * build, isl_space * space)'/>
<doc f='llvm/polly/lib/External/isl/isl_ast_build.c' l='1812'>/* Update &quot;build&quot; for use in a (possibly nested) code generation.  That is,
 * extend &quot;build&quot; from an AST build on some domain O to an AST build
 * on domain [O -&gt; S], with S corresponding to &quot;space&quot;.
 * If the original domain is a parameter domain, then the new domain is
 * simply S.
 * &quot;iterators&quot; is a list of iterators for S, but the number of elements
 * may be smaller or greater than the number of set dimensions of S.
 * If &quot;keep_iterators&quot; is set, then any extra ids in build-&gt;iterators
 * are reused for S.  Otherwise, these extra ids are dropped.
 *
 * We first update build-&gt;outer_pos to the current depth.
 * This depth is zero in case this is the outermost code generation.
 *
 * We then add additional ids such that the number of iterators is at least
 * equal to the dimension of the new build domain.
 *
 * If the original domain is parametric, then we are constructing
 * an isl_ast_build for the outer code generation and we pass control
 * to isl_ast_build_init.
 *
 * Otherwise, we adjust the fields of &quot;build&quot; to include &quot;space&quot;.
 */</doc>
<use f='llvm/polly/lib/External/isl/isl_ast_codegen.c' l='4978' u='c' c='generate_code_in_space'/>
<use f='llvm/polly/lib/External/isl/isl_ast_codegen.c' l='5263' u='c' c='build_ast_from_band'/>
<use f='llvm/polly/lib/External/isl/isl_ast_codegen.c' l='5868' u='c' c='build_ast_from_domain'/>
