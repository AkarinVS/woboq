<dec f='llvm/llvm/lib/Target/AMDGPU/SIISelLowering.h' l='382' type='bool llvm::SITargetLowering::isFMAFasterThanFMulAndFAdd(const llvm::MachineFunction &amp; MF, llvm::EVT VT) const'/>
<inh f='llvm/llvm/include/llvm/CodeGen/TargetLowering.h' l='2690' c='_ZNK4llvm18TargetLoweringBase26isFMAFasterThanFMulAndFAddERKNS_15MachineFunctionENS_3EVTE'/>
<def f='llvm/llvm/lib/Target/AMDGPU/SIISelLowering.cpp' l='4287' ll='4315' type='bool llvm::SITargetLowering::isFMAFasterThanFMulAndFAdd(const llvm::MachineFunction &amp; MF, llvm::EVT VT) const'/>
<use f='llvm/llvm/lib/Target/AMDGPU/SIISelLowering.cpp' l='10112' u='c' c='_ZNK4llvm16SITargetLowering14getFusedOpcodeERKNS_12SelectionDAGEPKNS_6SDNodeES6_'/>
<doc f='llvm/llvm/lib/Target/AMDGPU/SIISelLowering.cpp' l='4272'>// Answering this is somewhat tricky and depends on the specific device which
// have different rates for fma or all f64 operations.
//
// v_fma_f64 and v_mul_f64 always take the same number of cycles as each other
// regardless of which device (although the number of cycles differs between
// devices), so it is always profitable for f64.
//
// v_fma_f32 takes 4 or 16 cycles depending on the device, so it is profitable
// only on full rate devices. Normally, we should prefer selecting v_mad_f32
// which we can always do even without fused FP ops since it returns the same
// result as the separate operations and since it is always full
// rate. Therefore, we lie and report that it is not faster for f32. v_mad_f32
// however does not support denormals, so we do report fma as faster if we have
// a fast fma device and require denormals.
//</doc>
