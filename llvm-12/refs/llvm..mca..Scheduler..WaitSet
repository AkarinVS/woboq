<dec f='llvm/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h' l='111' type='std::vector&lt;InstRef&gt;'/>
<use f='llvm/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h' l='244' u='m' c='_ZNK4llvm3mca9Scheduler14isWaitSetEmptyEv'/>
<offset>256</offset>
<doc f='llvm/llvm/include/llvm/MCA/HardwareUnits/Scheduler.h' l='79'>// Instructions dispatched to the Scheduler are internally classified based on
  // the instruction stage (see Instruction::InstrStage).
  //
  // An Instruction dispatched to the Scheduler is added to the WaitSet if not
  // all its register operands are available, and at least one latency is
  // unknown.  By construction, the WaitSet only contains instructions that are
  // in the IS_DISPATCHED stage.
  //
  // An Instruction transitions from the WaitSet to the PendingSet if the
  // instruction is not ready yet, but the latency of every register read is
  // known.  Instructions in the PendingSet can only be in the IS_PENDING or
  // IS_READY stage.  Only IS_READY instructions that are waiting on memory
  // dependencies can be added to the PendingSet.
  //
  // Instructions in the PendingSet are immediately dominated only by
  // instructions that have already been issued to the underlying pipelines.  In
  // the presence of bottlenecks caused by data dependencies, the PendingSet can
  // be inspected to identify problematic data dependencies between
  // instructions.
  //
  // An instruction is moved to the ReadySet when all register operands become
  // available, and all memory dependencies are met.  Instructions that are
  // moved from the PendingSet to the ReadySet must transition to the &apos;IS_READY&apos;
  // stage.
  //
  // On every cycle, the Scheduler checks if it can promote instructions from the
  // PendingSet to the ReadySet.
  //
  // An Instruction is moved from the ReadySet to the `IssuedSet` when it starts
  // exection. This event also causes an instruction state transition (i.e. from
  // state IS_READY, to state IS_EXECUTING). An Instruction leaves the IssuedSet
  // only when it reaches the write-back stage.</doc>
<use f='llvm/llvm/lib/MCA/HardwareUnits/Scheduler.cpp' l='159' u='m' c='_ZN4llvm3mca9Scheduler19promoteToPendingSetERNS_15SmallVectorImplINS0_7InstRefEEE'/>
<use f='llvm/llvm/lib/MCA/HardwareUnits/Scheduler.cpp' l='159' u='m' c='_ZN4llvm3mca9Scheduler19promoteToPendingSetERNS_15SmallVectorImplINS0_7InstRefEEE'/>
<use f='llvm/llvm/lib/MCA/HardwareUnits/Scheduler.cpp' l='188' u='m' c='_ZN4llvm3mca9Scheduler19promoteToPendingSetERNS_15SmallVectorImplINS0_7InstRefEEE'/>
<use f='llvm/llvm/lib/MCA/HardwareUnits/Scheduler.cpp' l='188' u='m' c='_ZN4llvm3mca9Scheduler19promoteToPendingSetERNS_15SmallVectorImplINS0_7InstRefEEE'/>
<use f='llvm/llvm/lib/MCA/HardwareUnits/Scheduler.cpp' l='280' c='_ZN4llvm3mca9Scheduler10cycleEventERNS_15SmallVectorImplISt4pairImmEEERNS2_INS0_7InstRefEEES9_S9_'/>
<use f='llvm/llvm/lib/MCA/HardwareUnits/Scheduler.cpp' l='310' u='m' c='_ZN4llvm3mca9Scheduler8dispatchERNS0_7InstRefE'/>
