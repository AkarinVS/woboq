<dec f='llvm/llvm/lib/Transforms/InstCombine/InstCombineInternal.h' l='190' type='bool llvm::InstCombinerImpl::shouldChangeType(unsigned int FromBitWidth, unsigned int ToBitWidth) const'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp' l='2184' u='c' c='_ZN4llvm16InstCombinerImpl15matchSAddSubSatERNS_10SelectInstE'/>
<def f='llvm/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp' l='214' ll='235' type='bool llvm::InstCombinerImpl::shouldChangeType(unsigned int FromWidth, unsigned int ToWidth) const'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp' l='250' u='c' c='_ZNK4llvm16InstCombinerImpl16shouldChangeTypeEPNS_4TypeES2_'/>
<use f='llvm/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp' l='2975' u='c' c='_ZN4llvm16InstCombinerImpl15visitSwitchInstERNS_10SwitchInstE'/>
<doc f='llvm/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp' l='205'>/// Return true if it is desirable to convert an integer computation from a
/// given bit width to a new bit width.
/// We don&apos;t want to convert from a legal to an illegal type or from a smaller
/// to a larger illegal type. A width of &apos;1&apos; is always treated as a legal type
/// because i1 is a fundamental type in IR, and there are many specialized
/// optimizations for i1 types. Widths of 8, 16 or 32 are equally treated as
/// legal to convert to, in order to open up more combining opportunities.
/// NOTE: this treats i8, i16 and i32 specially, due to them being so common
/// from frontend languages.</doc>
