<dec f='llvm/polly/lib/External/isl/isl_basis_reduction.h' l='21' type='struct isl_tab * isl_tab_compute_reduced_basis(struct isl_tab * tab)'/>
<def f='llvm/polly/lib/External/isl/basis_reduction_templ.c' l='49' ll='306' type='struct isl_tab * isl_tab_compute_reduced_basis(struct isl_tab * tab)'/>
<use f='llvm/polly/lib/External/isl/basis_reduction_templ.c' l='344' u='c' c='isl_basic_set_reduced_basis'/>
<doc f='llvm/polly/lib/External/isl/basis_reduction_templ.c' l='28'>/* Compute a reduced basis for the set represented by the tableau &quot;tab&quot;.
 * tab-&gt;basis, which must be initialized by the calling function to an affine
 * unimodular basis, is updated to reflect the reduced basis.
 * The first tab-&gt;n_zero rows of the basis (ignoring the constant row)
 * are assumed to correspond to equalities and are left untouched.
 * tab-&gt;n_zero is updated to reflect any additional equalities that
 * have been detected in the first rows of the new basis.
 * The final tab-&gt;n_unbounded rows of the basis are assumed to correspond
 * to unbounded directions and are also left untouched.
 * In particular this means that the remaining rows are assumed to
 * correspond to bounded directions.
 *
 * This function implements the algorithm described in
 * &quot;An Implementation of the Generalized Basis Reduction Algorithm
 *  for Integer Programming&quot; of Cook el al. to compute a reduced basis.
 * We use \epsilon = 1/4.
 *
 * If ctx-&gt;opt-&gt;gbr_only_first is set, the user is only interested
 * in the first direction.  In this case we stop the basis reduction when
 * the width in the first direction becomes smaller than 2.
 */</doc>
<use f='llvm/polly/lib/External/isl/isl_sample.c' l='473' u='c' c='isl_tab_sample'/>
<use f='llvm/polly/lib/External/isl/isl_scan.c' l='139' u='c' c='isl_basic_set_scan'/>
