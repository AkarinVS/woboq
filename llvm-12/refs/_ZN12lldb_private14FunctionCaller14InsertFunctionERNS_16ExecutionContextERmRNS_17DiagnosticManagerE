<dec f='llvm/lldb/include/lldb/Expression/FunctionCaller.h' l='119' type='bool lldb_private::FunctionCaller::InsertFunction(lldb_private::ExecutionContext &amp; exe_ctx, lldb::addr_t &amp; args_addr_ref, lldb_private::DiagnosticManager &amp; diagnostic_manager)'/>
<def f='llvm/lldb/source/Expression/FunctionCaller.cpp' l='211' ll='226' type='bool lldb_private::FunctionCaller::InsertFunction(lldb_private::ExecutionContext &amp; exe_ctx, lldb::addr_t &amp; args_addr_ref, lldb_private::DiagnosticManager &amp; diagnostic_manager)'/>
<use f='llvm/lldb/source/Expression/FunctionCaller.cpp' l='338' u='c' c='_ZN12lldb_private14FunctionCaller15ExecuteFunctionERNS_16ExecutionContextEPmRKNS_25EvaluateExpressionOptionsERNS_17DiagnosticManagerERNS_5ValueE'/>
<doc f='llvm/lldb/include/lldb/Expression/FunctionCaller.h' l='103'>/// Insert the default function wrapper and its default argument struct
  ///
  /// \param[in] exe_ctx
  ///     The execution context to insert the function and its arguments
  ///     into.
  ///
  /// \param[in,out] args_addr_ref
  ///     The address of the structure to write the arguments into.  May
  ///     be LLDB_INVALID_ADDRESS; if it is, a new structure is allocated
  ///     and args_addr_ref is pointed to it.
  ///
  /// \param[in] diagnostic_manager
  ///     The diagnostic manager to report errors to.
  ///
  /// \return
  ///     True on success; false otherwise.</doc>
<use f='llvm/lldb/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntime.cpp' l='179' u='c' c='_ZN12lldb_private16AppleObjCRuntime20GetObjectDescriptionERNS_6StreamERNS_5ValueEPNS_21ExecutionContextScopeE'/>
