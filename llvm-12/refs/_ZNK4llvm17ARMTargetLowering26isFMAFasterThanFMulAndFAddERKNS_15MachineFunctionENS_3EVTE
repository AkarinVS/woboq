<dec f='llvm/llvm/lib/Target/ARM/ARMISelLowering.h' l='801' type='bool llvm::ARMTargetLowering::isFMAFasterThanFMulAndFAdd(const llvm::MachineFunction &amp; MF, llvm::EVT VT) const'/>
<inh f='llvm/llvm/include/llvm/CodeGen/TargetLowering.h' l='2690' c='_ZNK4llvm18TargetLoweringBase26isFMAFasterThanFMulAndFAddERKNS_15MachineFunctionENS_3EVTE'/>
<def f='llvm/llvm/lib/Target/ARM/ARMISelLowering.cpp' l='16875' ll='16895' type='bool llvm::ARMTargetLowering::isFMAFasterThanFMulAndFAdd(const llvm::MachineFunction &amp; MF, llvm::EVT VT) const'/>
<doc f='llvm/llvm/lib/Target/ARM/ARMISelLowering.cpp' l='16863'>/// isFMAFasterThanFMulAndFAdd - Return true if an FMA operation is faster
/// than a pair of fmul and fadd instructions. fmuladd intrinsics will be
/// expanded to FMAs when this method returns true, otherwise fmuladd is
/// expanded to fmul + fadd.
///
/// ARM supports both fused and unfused multiply-add operations; we already
/// lower a pair of fmul and fadd to the latter so it&apos;s not clear that there
/// would be a gain or that the gain would be worthwhile enough to risk
/// correctness bugs.
///
/// For MVE, we set this to true as it helps simplify the need for some
/// patterns (and we don&apos;t have the non-fused floating point instruction).</doc>
