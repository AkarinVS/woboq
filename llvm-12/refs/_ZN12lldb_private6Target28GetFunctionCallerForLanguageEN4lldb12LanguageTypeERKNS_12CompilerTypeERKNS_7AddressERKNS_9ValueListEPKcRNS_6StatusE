<dec f='llvm/lldb/include/lldb/Target/Target.h' l='1078' type='lldb_private::FunctionCaller * lldb_private::Target::GetFunctionCallerForLanguage(lldb::LanguageType language, const lldb_private::CompilerType &amp; return_type, const lldb_private::Address &amp; function_address, const lldb_private::ValueList &amp; arg_value_list, const char * name, lldb_private::Status &amp; error)'/>
<doc f='llvm/lldb/include/lldb/Target/Target.h' l='1070'>// Creates a FunctionCaller for the given language, the rest of the
  // parameters have the same meaning as for the FunctionCaller constructor.
  // Since a FunctionCaller can&apos;t be
  // IR Interpreted, it makes no sense to call this with an
  // ExecutionContextScope that lacks
  // a Process.
  // Returns a new-ed object which the caller owns.</doc>
<use f='llvm/lldb/source/Expression/UtilityFunction.cpp' l='77' u='c' c='_ZN12lldb_private15UtilityFunction18MakeFunctionCallerERKNS_12CompilerTypeERKNS_9ValueListESt10shared_ptrINS_6ThreadEERNS_6StatusE'/>
<use f='llvm/lldb/source/Plugins/LanguageRuntime/CPlusPlus/ItaniumABI/ItaniumABILanguageRuntime.cpp' l='571' u='c' c='_ZN12lldb_private25ItaniumABILanguageRuntime27GetExceptionObjectForThreadESt10shared_ptrINS_6ThreadEE'/>
<use f='llvm/lldb/source/Plugins/LanguageRuntime/ObjC/AppleObjCRuntime/AppleObjCRuntime.cpp' l='169' u='c' c='_ZN12lldb_private16AppleObjCRuntime20GetObjectDescriptionERNS_6StreamERNS_5ValueEPNS_21ExecutionContextScopeE'/>
<def f='llvm/lldb/source/Target/Target.cpp' l='2274' ll='2295' type='lldb_private::FunctionCaller * lldb_private::Target::GetFunctionCallerForLanguage(lldb::LanguageType language, const lldb_private::CompilerType &amp; return_type, const lldb_private::Address &amp; function_address, const lldb_private::ValueList &amp; arg_value_list, const char * name, lldb_private::Status &amp; error)'/>
