<dec f='ffmpeg/libavcodec/h2645_parse.h' l='109' type='int ff_h2645_packet_split(H2645Packet * pkt, const uint8_t * buf, int length, void * logctx, int is_nalff, int nal_length_size, enum AVCodecID codec_id, int small_padding, int use_ref)'/>
<use f='ffmpeg/libavcodec/cbs_h2645.c' l='553' u='c' c='cbs_h2645_split_fragment'/>
<use f='ffmpeg/libavcodec/cbs_h2645.c' l='577' u='c' c='cbs_h2645_split_fragment'/>
<use f='ffmpeg/libavcodec/cbs_h2645.c' l='631' u='c' c='cbs_h2645_split_fragment'/>
<use f='ffmpeg/libavcodec/cbs_h2645.c' l='648' u='c' c='cbs_h2645_split_fragment'/>
<doc f='ffmpeg/libavcodec/h2645_parse.h' l='95'>/**
 * Split an input packet into NAL units.
 *
 * If data == raw_data holds true for a NAL unit of the returned pkt, then
 * said NAL unit does not contain any emulation_prevention_three_byte and
 * the data is contained in the input buffer pointed to by buf.
 * Otherwise, the unescaped data is part of the rbsp_buffer described by the
 * packet&apos;s H2645RBSP.
 *
 * If the packet&apos;s rbsp_buffer_ref is not NULL, the underlying AVBuffer must
 * own rbsp_buffer. If not and rbsp_buffer is not NULL, use_ref must be 0.
 * If use_ref is set, rbsp_buffer will be reference-counted and owned by
 * the underlying AVBuffer of rbsp_buffer_ref.
 */</doc>
<use f='ffmpeg/libavcodec/extract_extradata_bsf.c' l='160' u='c' c='extract_extradata_h2645'/>
<def f='ffmpeg/libavcodec/h2645_parse.c' l='392' ll='521' type='int ff_h2645_packet_split(H2645Packet * pkt, const uint8_t * buf, int length, void * logctx, int is_nalff, int nal_length_size, enum AVCodecID codec_id, int small_padding, int use_ref)'/>
<use f='ffmpeg/libavcodec/h264_parse.c' l='370' u='c' c='decode_extradata_ps'/>
<use f='ffmpeg/libavcodec/h264dec.c' l='580' u='c' c='decode_nal_units'/>
<use f='ffmpeg/libavcodec/hevc_parse.c' l='32' u='c' c='hevc_decode_nal_units'/>
<use f='ffmpeg/libavcodec/hevc_parser.c' l='199' u='c' c='parse_nal_units'/>
<use f='ffmpeg/libavcodec/hevcdec.c' l='3155' u='c' c='decode_nal_units'/>
