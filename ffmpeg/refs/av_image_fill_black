<dec f='ffmpeg/libavutil/imgutils.h' l='282' type='int av_image_fill_black(uint8_t ** dst_data, const ptrdiff_t * dst_linesize, enum AVPixelFormat pix_fmt, enum AVColorRange range, int width, int height)'/>
<doc f='ffmpeg/libavutil/imgutils.h' l='259'>/**
 * Overwrite the image data with black. This is suitable for filling a
 * sub-rectangle of an image, meaning the padding between the right most pixel
 * and the left most pixel on the next line will not be overwritten. For some
 * formats, the image size might be rounded up due to inherent alignment.
 *
 * If the pixel format has alpha, the alpha is cleared to opaque.
 *
 * This can return an error if the pixel format is not supported. Normally, all
 * non-hwaccel pixel formats should be supported.
 *
 * Passing NULL for dst_data is allowed. Then the function returns whether the
 * operation would have succeeded. (It can return an error if the pix_fmt is
 * not supported.)
 *
 * @param dst_data      data pointers to destination image
 * @param dst_linesize  linesizes for the destination image
 * @param pix_fmt       the pixel format of the image
 * @param range         the color range of the image (important for colorspaces such as YUV)
 * @param width         the width of the image in pixels
 * @param height        the height of the image in pixels
 * @return 0 if the image data was cleared, a negative AVERROR code otherwise
 */</doc>
<use f='ffmpeg/libavcodec/wcmv.c' l='162' u='c' c='decode_frame'/>
<def f='ffmpeg/libavutil/imgutils.c' l='586' ll='696' type='int av_image_fill_black(uint8_t ** dst_data, const ptrdiff_t * dst_linesize, enum AVPixelFormat pix_fmt, enum AVColorRange range, int width, int height)'/>
