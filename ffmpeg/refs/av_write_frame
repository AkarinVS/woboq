<dec f='ffmpeg/libavformat/avformat.h' l='2509' type='int av_write_frame(AVFormatContext * s, AVPacket * pkt)'/>
<doc f='ffmpeg/libavformat/avformat.h' l='2472'>/**
 * Write a packet to an output media file.
 *
 * This function passes the packet directly to the muxer, without any buffering
 * or reordering. The caller is responsible for correctly interleaving the
 * packets if the format requires it. Callers that want libavformat to handle
 * the interleaving should call av_interleaved_write_frame() instead of this
 * function.
 *
 * @param s media file handle
 * @param pkt The packet containing the data to be written. Note that unlike
 *            av_interleaved_write_frame(), this function does not take
 *            ownership of the packet passed to it (though some muxers may make
 *            an internal reference to the input packet).
 *            &lt;br&gt;
 *            This parameter can be NULL (at any time, not just at the end), in
 *            order to immediately flush data buffered within the muxer, for
 *            muxers that buffer up data internally before writing it to the
 *            output.
 *            &lt;br&gt;
 *            Packet&apos;s @ref AVPacket.stream_index &quot;stream_index&quot; field must be
 *            set to the index of the corresponding stream in @ref
 *            AVFormatContext.streams &quot;s-&gt;streams&quot;.
 *            &lt;br&gt;
 *            The timestamps (@ref AVPacket.pts &quot;pts&quot;, @ref AVPacket.dts &quot;dts&quot;)
 *            must be set to correct values in the stream&apos;s timebase (unless the
 *            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then
 *            they can be set to AV_NOPTS_VALUE).
 *            The dts for subsequent packets passed to this function must be strictly
 *            increasing when compared in their respective timebases (unless the
 *            output format is flagged with the AVFMT_TS_NONSTRICT, then they
 *            merely have to be nondecreasing).  @ref AVPacket.duration
 *            &quot;duration&quot;) should also be set if known.
 * @return &lt; 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush
 *
 * @see av_interleaved_write_frame()
 */</doc>
<use f='ffmpeg/libavformat/dashenc.c' l='466' u='c' c='flush_dynbuf'/>
<use f='ffmpeg/libavformat/dashenc.c' l='2201' u='c' c='dash_write_packet'/>
<use f='ffmpeg/libavformat/fifo.c' l='167' u='c' c='fifo_thread_flush_output'/>
<use f='ffmpeg/libavformat/fifo.c' l='206' u='c' c='fifo_thread_write_packet'/>
<use f='ffmpeg/libavformat/hlsenc.c' l='545' u='c' c='flush_dynbuf'/>
<use f='ffmpeg/libavformat/hlsenc.c' l='2509' u='c' c='hls_write_packet'/>
<use f='ffmpeg/libavformat/hlsenc.c' l='2679' u='c' c='hls_write_packet'/>
<use f='ffmpeg/libavformat/hlsenc.c' l='2764' u='c' c='hls_write_trailer'/>
<use f='ffmpeg/libavformat/mpegtsenc.c' l='1769' u='c' c='mpegts_write_packet_internal'/>
<def f='ffmpeg/libavformat/mux.c' l='1212' ll='1257' type='int av_write_frame(AVFormatContext * s, AVPacket * in)'/>
<use f='ffmpeg/libavformat/mux.c' l='1342' u='c' c='ff_write_chained'/>
<use f='ffmpeg/libavformat/mux.c' l='1395' u='c' c='write_uncoded_frame_internal'/>
<use f='ffmpeg/libavformat/rtpenc_mpegts.c' l='149' u='c' c='rtp_mpegts_write_packet'/>
<use f='ffmpeg/libavformat/rtpenc_mpegts.c' l='169' u='c' c='rtp_mpegts_write_packet'/>
<use f='ffmpeg/libavformat/segment.c' l='369' u='c' c='segment_end'/>
<use f='ffmpeg/libavformat/segment.c' l='832' u='c' c='seg_write_header'/>
<use f='ffmpeg/libavformat/smoothstreamingenc.c' l='515' u='c' c='ism_flush'/>
<use f='ffmpeg/libavformat/webm_chunk.c' l='198' u='c' c='chunk_end'/>
<use f='ffmpeg/libavformat/webm_chunk.c' l='247' u='c' c='webm_chunk_write_packet'/>
