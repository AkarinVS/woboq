<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"><title>marshalling.h source code [halide/build-apps/abseil-cpp/absl/flags/marshalling.h] - Woboq Code Browser</title>
<link rel="stylesheet" href="../../../../.././data/qtcreator.css" title="QtCreator"/>
<link rel="alternate stylesheet" href="../../../../.././data/kdevelop.css" title="KDevelop"/>
<script type="text/javascript" src="../../../../.././data/jquery/jquery.min.js"></script>
<script type="text/javascript" src="../../../../.././data/jquery/jquery-ui.min.js"></script>
<script>var file = 'halide/build-apps/abseil-cpp/absl/flags/marshalling.h'; var root_path = '../../../../..'; var data_path = '../../../../.././data'; var ecma_script_api_version = 2;</script>
<script src='../../../../.././data/codebrowser.js'></script>
</head>
<body><div id='header'><h1 id='breadcrumb'><span>Browse the source code of </span><a href='../../../..'>halide</a>/<a href='../../..'>build-apps</a>/<a href='../..'>abseil-cpp</a>/<a href='..'>absl</a>/<a href='./'>flags</a>/<a href='marshalling.h.html'>marshalling.h</a></h1></div>
<hr/><div id='content'><table class="code">
<tr><th id="1">1</th><td><i>//</i></td></tr>
<tr><th id="2">2</th><td><i>//  Copyright 2019 The Abseil Authors.</i></td></tr>
<tr><th id="3">3</th><td><i>//</i></td></tr>
<tr><th id="4">4</th><td><i>// Licensed under the Apache License, Version 2.0 (the "License");</i></td></tr>
<tr><th id="5">5</th><td><i>// you may not use this file except in compliance with the License.</i></td></tr>
<tr><th id="6">6</th><td><i>// You may obtain a copy of the License at</i></td></tr>
<tr><th id="7">7</th><td><i>//</i></td></tr>
<tr><th id="8">8</th><td><i>//      <a href="https://www.apache.org/licenses/LICENSE-2.0">https://www.apache.org/licenses/LICENSE-2.0</a></i></td></tr>
<tr><th id="9">9</th><td><i>//</i></td></tr>
<tr><th id="10">10</th><td><i>// Unless required by applicable law or agreed to in writing, software</i></td></tr>
<tr><th id="11">11</th><td><i>// distributed under the License is distributed on an "AS IS" BASIS,</i></td></tr>
<tr><th id="12">12</th><td><i>// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</i></td></tr>
<tr><th id="13">13</th><td><i>// See the License for the specific language governing permissions and</i></td></tr>
<tr><th id="14">14</th><td><i>// limitations under the License.</i></td></tr>
<tr><th id="15">15</th><td><i>//</i></td></tr>
<tr><th id="16">16</th><td><i>// -----------------------------------------------------------------------------</i></td></tr>
<tr><th id="17">17</th><td><i>// File: marshalling.h</i></td></tr>
<tr><th id="18">18</th><td><i>// -----------------------------------------------------------------------------</i></td></tr>
<tr><th id="19">19</th><td><i>//</i></td></tr>
<tr><th id="20">20</th><td><i>// This header file defines the API for extending Abseil flag support to</i></td></tr>
<tr><th id="21">21</th><td><i>// custom types, and defines the set of overloads for fundamental types.</i></td></tr>
<tr><th id="22">22</th><td><i>//</i></td></tr>
<tr><th id="23">23</th><td><i>// Out of the box, the Abseil flags library supports the following types:</i></td></tr>
<tr><th id="24">24</th><td><i>//</i></td></tr>
<tr><th id="25">25</th><td><i>// * `bool`</i></td></tr>
<tr><th id="26">26</th><td><i>// * `int16_t`</i></td></tr>
<tr><th id="27">27</th><td><i>// * `uint16_t`</i></td></tr>
<tr><th id="28">28</th><td><i>// * `int32_t`</i></td></tr>
<tr><th id="29">29</th><td><i>// * `uint32_t`</i></td></tr>
<tr><th id="30">30</th><td><i>// * `int64_t`</i></td></tr>
<tr><th id="31">31</th><td><i>// * `uint64_t`</i></td></tr>
<tr><th id="32">32</th><td><i>// * `float`</i></td></tr>
<tr><th id="33">33</th><td><i>// * `double`</i></td></tr>
<tr><th id="34">34</th><td><i>// * `std::string`</i></td></tr>
<tr><th id="35">35</th><td><i>// * `std::vector&lt;std::string&gt;`</i></td></tr>
<tr><th id="36">36</th><td><i>// * `absl::LogSeverity` (provided natively for layering reasons)</i></td></tr>
<tr><th id="37">37</th><td><i>//</i></td></tr>
<tr><th id="38">38</th><td><i>// Note that support for integral types is implemented using overloads for</i></td></tr>
<tr><th id="39">39</th><td><i>// variable-width fundamental types (`short`, `int`, `long`, etc.). However,</i></td></tr>
<tr><th id="40">40</th><td><i>// you should prefer the fixed-width integral types (`int32_t`, `uint64_t`,</i></td></tr>
<tr><th id="41">41</th><td><i>// etc.) we've noted above within flag definitions.</i></td></tr>
<tr><th id="42">42</th><td><i>//</i></td></tr>
<tr><th id="43">43</th><td><i>// In addition, several Abseil libraries provide their own custom support for</i></td></tr>
<tr><th id="44">44</th><td><i>// Abseil flags. Documentation for these formats is provided in the type's</i></td></tr>
<tr><th id="45">45</th><td><i>// `AbslParseFlag()` definition.</i></td></tr>
<tr><th id="46">46</th><td><i>//</i></td></tr>
<tr><th id="47">47</th><td><i>// The Abseil time library provides the following support for civil time values:</i></td></tr>
<tr><th id="48">48</th><td><i>//</i></td></tr>
<tr><th id="49">49</th><td><i>// * `absl::CivilSecond`</i></td></tr>
<tr><th id="50">50</th><td><i>// * `absl::CivilMinute`</i></td></tr>
<tr><th id="51">51</th><td><i>// * `absl::CivilHour`</i></td></tr>
<tr><th id="52">52</th><td><i>// * `absl::CivilDay`</i></td></tr>
<tr><th id="53">53</th><td><i>// * `absl::CivilMonth`</i></td></tr>
<tr><th id="54">54</th><td><i>// * `absl::CivilYear`</i></td></tr>
<tr><th id="55">55</th><td><i>//</i></td></tr>
<tr><th id="56">56</th><td><i>// and also provides support for the following absolute time values:</i></td></tr>
<tr><th id="57">57</th><td><i>//</i></td></tr>
<tr><th id="58">58</th><td><i>// * `absl::Duration`</i></td></tr>
<tr><th id="59">59</th><td><i>// * `absl::Time`</i></td></tr>
<tr><th id="60">60</th><td><i>//</i></td></tr>
<tr><th id="61">61</th><td><i>// Additional support for Abseil types will be noted here as it is added.</i></td></tr>
<tr><th id="62">62</th><td><i>//</i></td></tr>
<tr><th id="63">63</th><td><i>// You can also provide your own custom flags by adding overloads for</i></td></tr>
<tr><th id="64">64</th><td><i>// `AbslParseFlag()` and `AbslUnparseFlag()` to your type definitions. (See</i></td></tr>
<tr><th id="65">65</th><td><i>// below.)</i></td></tr>
<tr><th id="66">66</th><td><i>//</i></td></tr>
<tr><th id="67">67</th><td><i>// -----------------------------------------------------------------------------</i></td></tr>
<tr><th id="68">68</th><td><i>// Adding Type Support for Abseil Flags</i></td></tr>
<tr><th id="69">69</th><td><i>// -----------------------------------------------------------------------------</i></td></tr>
<tr><th id="70">70</th><td><i>//</i></td></tr>
<tr><th id="71">71</th><td><i>// To add support for your user-defined type, add overloads of `AbslParseFlag()`</i></td></tr>
<tr><th id="72">72</th><td><i>// and `AbslUnparseFlag()` as free (non-member) functions to your type. If `T`</i></td></tr>
<tr><th id="73">73</th><td><i>// is a class type, these functions can be friend function definitions. These</i></td></tr>
<tr><th id="74">74</th><td><i>// overloads must be added to the same namespace where the type is defined, so</i></td></tr>
<tr><th id="75">75</th><td><i>// that they can be discovered by Argument-Dependent Lookup (ADL).</i></td></tr>
<tr><th id="76">76</th><td><i>//</i></td></tr>
<tr><th id="77">77</th><td><i>// Example:</i></td></tr>
<tr><th id="78">78</th><td><i>//</i></td></tr>
<tr><th id="79">79</th><td><i>//   namespace foo {</i></td></tr>
<tr><th id="80">80</th><td><i>//</i></td></tr>
<tr><th id="81">81</th><td><i>//   enum OutputMode { kPlainText, kHtml };</i></td></tr>
<tr><th id="82">82</th><td><i>//</i></td></tr>
<tr><th id="83">83</th><td><i>//   // AbslParseFlag converts from a string to OutputMode.</i></td></tr>
<tr><th id="84">84</th><td><i>//   // Must be in same namespace as OutputMode.</i></td></tr>
<tr><th id="85">85</th><td><i>//</i></td></tr>
<tr><th id="86">86</th><td><i>//   // Parses an OutputMode from the command line flag value `text. Returns</i></td></tr>
<tr><th id="87">87</th><td><i>//   // `true` and sets `*mode` on success; returns `false` and sets `*error`</i></td></tr>
<tr><th id="88">88</th><td><i>//   // on failure.</i></td></tr>
<tr><th id="89">89</th><td><i>//   bool AbslParseFlag(absl::string_view text,</i></td></tr>
<tr><th id="90">90</th><td><i>//                      OutputMode* mode,</i></td></tr>
<tr><th id="91">91</th><td><i>//                      std::string* error) {</i></td></tr>
<tr><th id="92">92</th><td><i>//     if (text == "plaintext") {</i></td></tr>
<tr><th id="93">93</th><td><i>//       *mode = kPlainText;</i></td></tr>
<tr><th id="94">94</th><td><i>//       return true;</i></td></tr>
<tr><th id="95">95</th><td><i>//     }</i></td></tr>
<tr><th id="96">96</th><td><i>//     if (text == "html") {</i></td></tr>
<tr><th id="97">97</th><td><i>//       *mode = kHtml;</i></td></tr>
<tr><th id="98">98</th><td><i>//      return true;</i></td></tr>
<tr><th id="99">99</th><td><i>//     }</i></td></tr>
<tr><th id="100">100</th><td><i>//     *error = "unknown value for enumeration";</i></td></tr>
<tr><th id="101">101</th><td><i>//     return false;</i></td></tr>
<tr><th id="102">102</th><td><i>//  }</i></td></tr>
<tr><th id="103">103</th><td><i>//</i></td></tr>
<tr><th id="104">104</th><td><i>//  // AbslUnparseFlag converts from an OutputMode to a string.</i></td></tr>
<tr><th id="105">105</th><td><i>//  // Must be in same namespace as OutputMode.</i></td></tr>
<tr><th id="106">106</th><td><i>//</i></td></tr>
<tr><th id="107">107</th><td><i>//  // Returns a textual flag value corresponding to the OutputMode `mode`.</i></td></tr>
<tr><th id="108">108</th><td><i>//  std::string AbslUnparseFlag(OutputMode mode) {</i></td></tr>
<tr><th id="109">109</th><td><i>//    switch (mode) {</i></td></tr>
<tr><th id="110">110</th><td><i>//      case kPlainText: return "plaintext";</i></td></tr>
<tr><th id="111">111</th><td><i>//      case kHtml: return "html";</i></td></tr>
<tr><th id="112">112</th><td><i>//    }</i></td></tr>
<tr><th id="113">113</th><td><i>//    return absl::StrCat(mode);</i></td></tr>
<tr><th id="114">114</th><td><i>//  }</i></td></tr>
<tr><th id="115">115</th><td><i>//</i></td></tr>
<tr><th id="116">116</th><td><i>// Notice that neither `AbslParseFlag()` nor `AbslUnparseFlag()` are class</i></td></tr>
<tr><th id="117">117</th><td><i>// members, but free functions. `AbslParseFlag/AbslUnparseFlag()` overloads</i></td></tr>
<tr><th id="118">118</th><td><i>// for a type should only be declared in the same file and namespace as said</i></td></tr>
<tr><th id="119">119</th><td><i>// type. The proper `AbslParseFlag/AbslUnparseFlag()` implementations for a</i></td></tr>
<tr><th id="120">120</th><td><i>// given type will be discovered via Argument-Dependent Lookup (ADL).</i></td></tr>
<tr><th id="121">121</th><td><i>//</i></td></tr>
<tr><th id="122">122</th><td><i>// `AbslParseFlag()` may need, in turn, to parse simpler constituent types</i></td></tr>
<tr><th id="123">123</th><td><i>// using `absl::ParseFlag()`. For example, a custom struct `MyFlagType`</i></td></tr>
<tr><th id="124">124</th><td><i>// consisting of a `std::pair&lt;int, std::string&gt;` would add an `AbslParseFlag()`</i></td></tr>
<tr><th id="125">125</th><td><i>// overload for its `MyFlagType` like so:</i></td></tr>
<tr><th id="126">126</th><td><i>//</i></td></tr>
<tr><th id="127">127</th><td><i>// Example:</i></td></tr>
<tr><th id="128">128</th><td><i>//</i></td></tr>
<tr><th id="129">129</th><td><i>//   namespace my_flag_type {</i></td></tr>
<tr><th id="130">130</th><td><i>//</i></td></tr>
<tr><th id="131">131</th><td><i>//   struct MyFlagType {</i></td></tr>
<tr><th id="132">132</th><td><i>//     std::pair&lt;int, std::string&gt; my_flag_data;</i></td></tr>
<tr><th id="133">133</th><td><i>//   };</i></td></tr>
<tr><th id="134">134</th><td><i>//</i></td></tr>
<tr><th id="135">135</th><td><i>//   bool AbslParseFlag(absl::string_view text, MyFlagType* flag,</i></td></tr>
<tr><th id="136">136</th><td><i>//                      std::string* err);</i></td></tr>
<tr><th id="137">137</th><td><i>//</i></td></tr>
<tr><th id="138">138</th><td><i>//   std::string AbslUnparseFlag(const MyFlagType&amp;);</i></td></tr>
<tr><th id="139">139</th><td><i>//</i></td></tr>
<tr><th id="140">140</th><td><i>//   // Within the implementation, `AbslParseFlag()` will, in turn invoke</i></td></tr>
<tr><th id="141">141</th><td><i>//   // `absl::ParseFlag()` on its constituent `int` and `std::string` types</i></td></tr>
<tr><th id="142">142</th><td><i>//   // (which have built-in Abseil flag support.</i></td></tr>
<tr><th id="143">143</th><td><i>//</i></td></tr>
<tr><th id="144">144</th><td><i>//   bool AbslParseFlag(absl::string_view text, MyFlagType* flag,</i></td></tr>
<tr><th id="145">145</th><td><i>//                      std::string* err) {</i></td></tr>
<tr><th id="146">146</th><td><i>//     std::pair&lt;absl::string_view, absl::string_view&gt; tokens =</i></td></tr>
<tr><th id="147">147</th><td><i>//         absl::StrSplit(text, ',');</i></td></tr>
<tr><th id="148">148</th><td><i>//     if (!absl::ParseFlag(tokens.first, &amp;flag-&gt;my_flag_data.first, err))</i></td></tr>
<tr><th id="149">149</th><td><i>//         return false;</i></td></tr>
<tr><th id="150">150</th><td><i>//     if (!absl::ParseFlag(tokens.second, &amp;flag-&gt;my_flag_data.second, err))</i></td></tr>
<tr><th id="151">151</th><td><i>//         return false;</i></td></tr>
<tr><th id="152">152</th><td><i>//     return true;</i></td></tr>
<tr><th id="153">153</th><td><i>//   }</i></td></tr>
<tr><th id="154">154</th><td><i>//</i></td></tr>
<tr><th id="155">155</th><td><i>//   // Similarly, for unparsing, we can simply invoke `absl::UnparseFlag()` on</i></td></tr>
<tr><th id="156">156</th><td><i>//   // the constituent types.</i></td></tr>
<tr><th id="157">157</th><td><i>//   std::string AbslUnparseFlag(const MyFlagType&amp; flag) {</i></td></tr>
<tr><th id="158">158</th><td><i>//     return absl::StrCat(absl::UnparseFlag(flag.my_flag_data.first),</i></td></tr>
<tr><th id="159">159</th><td><i>//                         ",",</i></td></tr>
<tr><th id="160">160</th><td><i>//                         absl::UnparseFlag(flag.my_flag_data.second));</i></td></tr>
<tr><th id="161">161</th><td><i>//   }</i></td></tr>
<tr><th id="162">162</th><td><u>#<span data-ppcond="162">ifndef</span> <span class="macro" data-ref="_M/ABSL_FLAGS_MARSHALLING_H_">ABSL_FLAGS_MARSHALLING_H_</span></u></td></tr>
<tr><th id="163">163</th><td><u>#define <dfn class="macro" id="_M/ABSL_FLAGS_MARSHALLING_H_" data-ref="_M/ABSL_FLAGS_MARSHALLING_H_">ABSL_FLAGS_MARSHALLING_H_</dfn></u></td></tr>
<tr><th id="164">164</th><td></td></tr>
<tr><th id="165">165</th><td><u>#include &lt;string&gt;</u></td></tr>
<tr><th id="166">166</th><td><u>#include &lt;vector&gt;</u></td></tr>
<tr><th id="167">167</th><td></td></tr>
<tr><th id="168">168</th><td><u>#include <a href="../base/config.h.html">"absl/base/config.h"</a></u></td></tr>
<tr><th id="169">169</th><td><u>#include <a href="../strings/string_view.h.html">"absl/strings/string_view.h"</a></u></td></tr>
<tr><th id="170">170</th><td></td></tr>
<tr><th id="171">171</th><td><b>namespace</b> <span class="namespace">absl</span> {</td></tr>
<tr><th id="172">172</th><td><a class="macro" href="../base/config.h.html#125" title="inline namespace lts_2020_02_25 {" data-ref="_M/ABSL_NAMESPACE_BEGIN">ABSL_NAMESPACE_BEGIN</a></td></tr>
<tr><th id="173">173</th><td><b>namespace</b> <span class="namespace">flags_internal</span> {</td></tr>
<tr><th id="174">174</th><td></td></tr>
<tr><th id="175">175</th><td><i>// Overloads of `AbslParseFlag()` and `AbslUnparseFlag()` for fundamental types.</i></td></tr>
<tr><th id="176">176</th><td><em>bool</em> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPbPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" title='absl::lts_2020_02_25::flags_internal::AbslParseFlag' data-ref="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPbPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPbPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE">AbslParseFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="../strings/string_view.h.html#absl::lts_2020_02_25::string_view" title='absl::lts_2020_02_25::string_view' data-ref="absl::lts_2020_02_25::string_view" data-ref-filename="absl..lts_2020_02_25..string_view">string_view</a>, <em>bool</em>*, <span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>*);</td></tr>
<tr><th id="177">177</th><td><em>bool</em> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPsPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" title='absl::lts_2020_02_25::flags_internal::AbslParseFlag' data-ref="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPsPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPsPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE">AbslParseFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="../strings/string_view.h.html#absl::lts_2020_02_25::string_view" title='absl::lts_2020_02_25::string_view' data-ref="absl::lts_2020_02_25::string_view" data-ref-filename="absl..lts_2020_02_25..string_view">string_view</a>, <em>short</em>*, <span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>*);           <i>// NOLINT</i></td></tr>
<tr><th id="178">178</th><td><em>bool</em> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPtPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" title='absl::lts_2020_02_25::flags_internal::AbslParseFlag' data-ref="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPtPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPtPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE">AbslParseFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="../strings/string_view.h.html#absl::lts_2020_02_25::string_view" title='absl::lts_2020_02_25::string_view' data-ref="absl::lts_2020_02_25::string_view" data-ref-filename="absl..lts_2020_02_25..string_view">string_view</a>, <em>unsigned</em> <em>short</em>*, <span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>*);  <i>// NOLINT</i></td></tr>
<tr><th id="179">179</th><td><em>bool</em> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPiPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" title='absl::lts_2020_02_25::flags_internal::AbslParseFlag' data-ref="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPiPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPiPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE">AbslParseFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="../strings/string_view.h.html#absl::lts_2020_02_25::string_view" title='absl::lts_2020_02_25::string_view' data-ref="absl::lts_2020_02_25::string_view" data-ref-filename="absl..lts_2020_02_25..string_view">string_view</a>, <em>int</em>*, <span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>*);             <i>// NOLINT</i></td></tr>
<tr><th id="180">180</th><td><em>bool</em> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPjPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" title='absl::lts_2020_02_25::flags_internal::AbslParseFlag' data-ref="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPjPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPjPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE">AbslParseFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="../strings/string_view.h.html#absl::lts_2020_02_25::string_view" title='absl::lts_2020_02_25::string_view' data-ref="absl::lts_2020_02_25::string_view" data-ref-filename="absl..lts_2020_02_25..string_view">string_view</a>, <em>unsigned</em> <em>int</em>*, <span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>*);    <i>// NOLINT</i></td></tr>
<tr><th id="181">181</th><td><em>bool</em> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPlPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" title='absl::lts_2020_02_25::flags_internal::AbslParseFlag' data-ref="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPlPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPlPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE">AbslParseFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="../strings/string_view.h.html#absl::lts_2020_02_25::string_view" title='absl::lts_2020_02_25::string_view' data-ref="absl::lts_2020_02_25::string_view" data-ref-filename="absl..lts_2020_02_25..string_view">string_view</a>, <em>long</em>*, <span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>*);            <i>// NOLINT</i></td></tr>
<tr><th id="182">182</th><td><em>bool</em> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPmPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" title='absl::lts_2020_02_25::flags_internal::AbslParseFlag' data-ref="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPmPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPmPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE">AbslParseFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="../strings/string_view.h.html#absl::lts_2020_02_25::string_view" title='absl::lts_2020_02_25::string_view' data-ref="absl::lts_2020_02_25::string_view" data-ref-filename="absl..lts_2020_02_25..string_view">string_view</a>, <em>unsigned</em> <em>long</em>*, <span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>*);   <i>// NOLINT</i></td></tr>
<tr><th id="183">183</th><td><em>bool</em> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPxPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" title='absl::lts_2020_02_25::flags_internal::AbslParseFlag' data-ref="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPxPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPxPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE">AbslParseFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="../strings/string_view.h.html#absl::lts_2020_02_25::string_view" title='absl::lts_2020_02_25::string_view' data-ref="absl::lts_2020_02_25::string_view" data-ref-filename="absl..lts_2020_02_25..string_view">string_view</a>, <em>long</em> <em>long</em>*, <span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>*);       <i>// NOLINT</i></td></tr>
<tr><th id="184">184</th><td><em>bool</em> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPyPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" title='absl::lts_2020_02_25::flags_internal::AbslParseFlag' data-ref="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPyPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPyPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE">AbslParseFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="../strings/string_view.h.html#absl::lts_2020_02_25::string_view" title='absl::lts_2020_02_25::string_view' data-ref="absl::lts_2020_02_25::string_view" data-ref-filename="absl..lts_2020_02_25..string_view">string_view</a>, <em>unsigned</em> <em>long</em> <em>long</em>*,             <i>// NOLINT</i></td></tr>
<tr><th id="185">185</th><td>                   <span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>*);</td></tr>
<tr><th id="186">186</th><td><em>bool</em> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPfPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" title='absl::lts_2020_02_25::flags_internal::AbslParseFlag' data-ref="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPfPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPfPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE">AbslParseFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="../strings/string_view.h.html#absl::lts_2020_02_25::string_view" title='absl::lts_2020_02_25::string_view' data-ref="absl::lts_2020_02_25::string_view" data-ref-filename="absl..lts_2020_02_25..string_view">string_view</a>, <em>float</em>*, <span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>*);</td></tr>
<tr><th id="187">187</th><td><em>bool</em> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPdPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" title='absl::lts_2020_02_25::flags_internal::AbslParseFlag' data-ref="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPdPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPdPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE">AbslParseFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="../strings/string_view.h.html#absl::lts_2020_02_25::string_view" title='absl::lts_2020_02_25::string_view' data-ref="absl::lts_2020_02_25::string_view" data-ref-filename="absl..lts_2020_02_25..string_view">string_view</a>, <em>double</em>*, <span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>*);</td></tr>
<tr><th id="188">188</th><td><em>bool</em> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_" title='absl::lts_2020_02_25::flags_internal::AbslParseFlag' data-ref="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_">AbslParseFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="../strings/string_view.h.html#absl::lts_2020_02_25::string_view" title='absl::lts_2020_02_25::string_view' data-ref="absl::lts_2020_02_25::string_view" data-ref-filename="absl..lts_2020_02_25..string_view">string_view</a>, <span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>*, <span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>*);</td></tr>
<tr><th id="189">189</th><td><em>bool</em> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS9_EEPS9_" title='absl::lts_2020_02_25::flags_internal::AbslParseFlag' data-ref="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS9_EEPS9_" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal13AbslParseFlagENS0_11string_viewEPSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS9_EEPS9_">AbslParseFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="../strings/string_view.h.html#absl::lts_2020_02_25::string_view" title='absl::lts_2020_02_25::string_view' data-ref="absl::lts_2020_02_25::string_view" data-ref-filename="absl..lts_2020_02_25..string_view">string_view</a>, <span class="namespace">std::</span><span class='type' title='std::vector' data-ref="std::vector" data-ref-filename="std..vector">vector</span>&lt;<span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>&gt;*, <span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>*);</td></tr>
<tr><th id="190">190</th><td></td></tr>
<tr><th id="191">191</th><td><b>template</b> &lt;<b>typename</b> T&gt;</td></tr>
<tr><th id="192">192</th><td><em>bool</em> <dfn class="decl def fn" id="_ZN4absl14lts_2020_02_2514flags_internal15InvokeParseFlagENS0_11string_viewEPT_PNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" title='absl::lts_2020_02_25::flags_internal::InvokeParseFlag' data-ref="_ZN4absl14lts_2020_02_2514flags_internal15InvokeParseFlagENS0_11string_viewEPT_PNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal15InvokeParseFlagENS0_11string_viewEPT_PNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE">InvokeParseFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="../strings/string_view.h.html#absl::lts_2020_02_25::string_view" title='absl::lts_2020_02_25::string_view' data-ref="absl::lts_2020_02_25::string_view" data-ref-filename="absl..lts_2020_02_25..string_view">string_view</a> <dfn class="local col1 decl" id="1input" title='input' data-type='absl::string_view' data-ref="1input" data-ref-filename="1input">input</dfn>, T* <dfn class="local col2 decl" id="2dst" title='dst' data-type='T *' data-ref="2dst" data-ref-filename="2dst">dst</dfn>, <span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>* <dfn class="local col3 decl" id="3err" title='err' data-type='std::string *' data-ref="3err" data-ref-filename="3err">err</dfn>) {</td></tr>
<tr><th id="193">193</th><td>  <i>// Comment on next line provides a good compiler error message if T</i></td></tr>
<tr><th id="194">194</th><td><i>  // does not have AbslParseFlag(absl::string_view, T*, std::string*).</i></td></tr>
<tr><th id="195">195</th><td>  <b>return</b> AbslParseFlag(<a class="local col1 ref" href="#1input" title='input' data-ref="1input" data-ref-filename="1input">input</a>, <a class="local col2 ref" href="#2dst" title='dst' data-ref="2dst" data-ref-filename="2dst">dst</a>, <a class="local col3 ref" href="#3err" title='err' data-ref="3err" data-ref-filename="3err">err</a>);  <i>// Is T missing AbslParseFlag?</i></td></tr>
<tr><th id="196">196</th><td>}</td></tr>
<tr><th id="197">197</th><td></td></tr>
<tr><th id="198">198</th><td><i>// Strings and std:: containers do not have the same overload resolution</i></td></tr>
<tr><th id="199">199</th><td><i>// considerations as fundamental types. Naming these 'AbslUnparseFlag' means we</i></td></tr>
<tr><th id="200">200</th><td><i>// can avoid the need for additional specializations of Unparse (below).</i></td></tr>
<tr><th id="201">201</th><td><span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal15AbslUnparseFlagB5cxx11ENS0_11string_viewE" title='absl::lts_2020_02_25::flags_internal::AbslUnparseFlag' data-ref="_ZN4absl14lts_2020_02_2514flags_internal15AbslUnparseFlagB5cxx11ENS0_11string_viewE" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal15AbslUnparseFlagB5cxx11ENS0_11string_viewE">AbslUnparseFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="../strings/string_view.h.html#absl::lts_2020_02_25::string_view" title='absl::lts_2020_02_25::string_view' data-ref="absl::lts_2020_02_25::string_view" data-ref-filename="absl..lts_2020_02_25..string_view">string_view</a> <dfn class="local col4 decl" id="4v" title='v' data-type='absl::string_view' data-ref="4v" data-ref-filename="4v">v</dfn>);</td></tr>
<tr><th id="202">202</th><td><span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal15AbslUnparseFlagERKSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS8_EE" title='absl::lts_2020_02_25::flags_internal::AbslUnparseFlag' data-ref="_ZN4absl14lts_2020_02_2514flags_internal15AbslUnparseFlagERKSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS8_EE" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal15AbslUnparseFlagERKSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS8_EE">AbslUnparseFlag</dfn>(<em>const</em> <span class="namespace">std::</span><span class='type' title='std::vector' data-ref="std::vector" data-ref-filename="std..vector">vector</span>&lt;<span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>&gt;&amp;);</td></tr>
<tr><th id="203">203</th><td></td></tr>
<tr><th id="204">204</th><td><b>template</b> &lt;<b>typename</b> T&gt;</td></tr>
<tr><th id="205">205</th><td><span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span> <dfn class="decl def fn" id="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11ERKT_" title='absl::lts_2020_02_25::flags_internal::Unparse' data-ref="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11ERKT_" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11ERKT_">Unparse</dfn>(<em>const</em> T&amp; <dfn class="local col5 decl" id="5v" title='v' data-type='const T &amp;' data-ref="5v" data-ref-filename="5v">v</dfn>) {</td></tr>
<tr><th id="206">206</th><td>  <i>// Comment on next line provides a good compiler error message if T does not</i></td></tr>
<tr><th id="207">207</th><td><i>  // have UnparseFlag.</i></td></tr>
<tr><th id="208">208</th><td>  <b>return</b> AbslUnparseFlag(<a class="local col5 ref" href="#5v" title='v' data-ref="5v" data-ref-filename="5v">v</a>);  <i>// Is T missing AbslUnparseFlag?</i></td></tr>
<tr><th id="209">209</th><td>}</td></tr>
<tr><th id="210">210</th><td></td></tr>
<tr><th id="211">211</th><td><i>// Overloads for builtin types.</i></td></tr>
<tr><th id="212">212</th><td><span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Eb" title='absl::lts_2020_02_25::flags_internal::Unparse' data-ref="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Eb" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Eb">Unparse</dfn>(<em>bool</em> <dfn class="local col6 decl" id="6v" title='v' data-type='bool' data-ref="6v" data-ref-filename="6v">v</dfn>);</td></tr>
<tr><th id="213">213</th><td><span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Es" title='absl::lts_2020_02_25::flags_internal::Unparse' data-ref="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Es" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Es">Unparse</dfn>(<em>short</em> <dfn class="local col7 decl" id="7v" title='v' data-type='short' data-ref="7v" data-ref-filename="7v">v</dfn>);               <i>// NOLINT</i></td></tr>
<tr><th id="214">214</th><td><span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Et" title='absl::lts_2020_02_25::flags_internal::Unparse' data-ref="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Et" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Et">Unparse</dfn>(<em>unsigned</em> <em>short</em> <dfn class="local col8 decl" id="8v" title='v' data-type='unsigned short' data-ref="8v" data-ref-filename="8v">v</dfn>);      <i>// NOLINT</i></td></tr>
<tr><th id="215">215</th><td><span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Ei" title='absl::lts_2020_02_25::flags_internal::Unparse' data-ref="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Ei" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Ei">Unparse</dfn>(<em>int</em> <dfn class="local col9 decl" id="9v" title='v' data-type='int' data-ref="9v" data-ref-filename="9v">v</dfn>);                 <i>// NOLINT</i></td></tr>
<tr><th id="216">216</th><td><span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Ej" title='absl::lts_2020_02_25::flags_internal::Unparse' data-ref="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Ej" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Ej">Unparse</dfn>(<em>unsigned</em> <em>int</em> <dfn class="local col0 decl" id="10v" title='v' data-type='unsigned int' data-ref="10v" data-ref-filename="10v">v</dfn>);        <i>// NOLINT</i></td></tr>
<tr><th id="217">217</th><td><span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11El" title='absl::lts_2020_02_25::flags_internal::Unparse' data-ref="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11El" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11El">Unparse</dfn>(<em>long</em> <dfn class="local col1 decl" id="11v" title='v' data-type='long' data-ref="11v" data-ref-filename="11v">v</dfn>);                <i>// NOLINT</i></td></tr>
<tr><th id="218">218</th><td><span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Em" title='absl::lts_2020_02_25::flags_internal::Unparse' data-ref="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Em" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Em">Unparse</dfn>(<em>unsigned</em> <em>long</em> <dfn class="local col2 decl" id="12v" title='v' data-type='unsigned long' data-ref="12v" data-ref-filename="12v">v</dfn>);       <i>// NOLINT</i></td></tr>
<tr><th id="219">219</th><td><span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Ex" title='absl::lts_2020_02_25::flags_internal::Unparse' data-ref="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Ex" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Ex">Unparse</dfn>(<em>long</em> <em>long</em> <dfn class="local col3 decl" id="13v" title='v' data-type='long long' data-ref="13v" data-ref-filename="13v">v</dfn>);           <i>// NOLINT</i></td></tr>
<tr><th id="220">220</th><td><span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Ey" title='absl::lts_2020_02_25::flags_internal::Unparse' data-ref="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Ey" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Ey">Unparse</dfn>(<em>unsigned</em> <em>long</em> <em>long</em> <dfn class="local col4 decl" id="14v" title='v' data-type='unsigned long long' data-ref="14v" data-ref-filename="14v">v</dfn>);  <i>// NOLINT</i></td></tr>
<tr><th id="221">221</th><td><span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Ef" title='absl::lts_2020_02_25::flags_internal::Unparse' data-ref="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Ef" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Ef">Unparse</dfn>(<em>float</em> <dfn class="local col5 decl" id="15v" title='v' data-type='float' data-ref="15v" data-ref-filename="15v">v</dfn>);</td></tr>
<tr><th id="222">222</th><td><span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Ed" title='absl::lts_2020_02_25::flags_internal::Unparse' data-ref="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Ed" data-ref-filename="_ZN4absl14lts_2020_02_2514flags_internal7UnparseB5cxx11Ed">Unparse</dfn>(<em>double</em> <dfn class="local col6 decl" id="16v" title='v' data-type='double' data-ref="16v" data-ref-filename="16v">v</dfn>);</td></tr>
<tr><th id="223">223</th><td></td></tr>
<tr><th id="224">224</th><td>}  <i>// namespace flags_internal</i></td></tr>
<tr><th id="225">225</th><td></td></tr>
<tr><th id="226">226</th><td><i>// ParseFlag()</i></td></tr>
<tr><th id="227">227</th><td><i>//</i></td></tr>
<tr><th id="228">228</th><td><i>// Parses a string value into a flag value of type `T`. Do not add overloads of</i></td></tr>
<tr><th id="229">229</th><td><i>// this function for your type directly; instead, add an `AbslParseFlag()`</i></td></tr>
<tr><th id="230">230</th><td><i>// free function as documented above.</i></td></tr>
<tr><th id="231">231</th><td><i>//</i></td></tr>
<tr><th id="232">232</th><td><i>// Some implementations of `AbslParseFlag()` for types which consist of other,</i></td></tr>
<tr><th id="233">233</th><td><i>// constituent types which already have Abseil flag support, may need to call</i></td></tr>
<tr><th id="234">234</th><td><i>// `absl::ParseFlag()` on those consituent string values. (See above.)</i></td></tr>
<tr><th id="235">235</th><td><b>template</b> &lt;<b>typename</b> T&gt;</td></tr>
<tr><th id="236">236</th><td><b>inline</b> <em>bool</em> <dfn class="decl def fn" id="_ZN4absl14lts_2020_02_259ParseFlagENS0_11string_viewEPT_PNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" title='absl::lts_2020_02_25::ParseFlag' data-ref="_ZN4absl14lts_2020_02_259ParseFlagENS0_11string_viewEPT_PNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" data-ref-filename="_ZN4absl14lts_2020_02_259ParseFlagENS0_11string_viewEPT_PNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE">ParseFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="../strings/string_view.h.html#absl::lts_2020_02_25::string_view" title='absl::lts_2020_02_25::string_view' data-ref="absl::lts_2020_02_25::string_view" data-ref-filename="absl..lts_2020_02_25..string_view">string_view</a> <dfn class="local col7 decl" id="17input" title='input' data-type='absl::string_view' data-ref="17input" data-ref-filename="17input">input</dfn>, T* <dfn class="local col8 decl" id="18dst" title='dst' data-type='T *' data-ref="18dst" data-ref-filename="18dst">dst</dfn>, <span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>* <dfn class="local col9 decl" id="19error" title='error' data-type='std::string *' data-ref="19error" data-ref-filename="19error">error</dfn>) {</td></tr>
<tr><th id="237">237</th><td>  <b>return</b> <span class="namespace">flags_internal::</span>InvokeParseFlag(<a class="local col7 ref" href="#17input" title='input' data-ref="17input" data-ref-filename="17input">input</a>, <a class="local col8 ref" href="#18dst" title='dst' data-ref="18dst" data-ref-filename="18dst">dst</a>, <a class="local col9 ref" href="#19error" title='error' data-ref="19error" data-ref-filename="19error">error</a>);</td></tr>
<tr><th id="238">238</th><td>}</td></tr>
<tr><th id="239">239</th><td></td></tr>
<tr><th id="240">240</th><td><i>// UnparseFlag()</i></td></tr>
<tr><th id="241">241</th><td><i>//</i></td></tr>
<tr><th id="242">242</th><td><i>// Unparses a flag value of type `T` into a string value. Do not add overloads</i></td></tr>
<tr><th id="243">243</th><td><i>// of this function for your type directly; instead, add an `AbslUnparseFlag()`</i></td></tr>
<tr><th id="244">244</th><td><i>// free function as documented above.</i></td></tr>
<tr><th id="245">245</th><td><i>//</i></td></tr>
<tr><th id="246">246</th><td><i>// Some implementations of `AbslUnparseFlag()` for types which consist of other,</i></td></tr>
<tr><th id="247">247</th><td><i>// constituent types which already have Abseil flag support, may want to call</i></td></tr>
<tr><th id="248">248</th><td><i>// `absl::UnparseFlag()` on those constituent types. (See above.)</i></td></tr>
<tr><th id="249">249</th><td><b>template</b> &lt;<b>typename</b> T&gt;</td></tr>
<tr><th id="250">250</th><td><b>inline</b> <span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span> <dfn class="decl def fn" id="_ZN4absl14lts_2020_02_2511UnparseFlagB5cxx11ERKT_" title='absl::lts_2020_02_25::UnparseFlag' data-ref="_ZN4absl14lts_2020_02_2511UnparseFlagB5cxx11ERKT_" data-ref-filename="_ZN4absl14lts_2020_02_2511UnparseFlagB5cxx11ERKT_">UnparseFlag</dfn>(<em>const</em> T&amp; <dfn class="local col0 decl" id="20v" title='v' data-type='const T &amp;' data-ref="20v" data-ref-filename="20v">v</dfn>) {</td></tr>
<tr><th id="251">251</th><td>  <b>return</b> <span class="namespace">flags_internal::</span>Unparse(<a class="local col0 ref" href="#20v" title='v' data-ref="20v" data-ref-filename="20v">v</a>);</td></tr>
<tr><th id="252">252</th><td>}</td></tr>
<tr><th id="253">253</th><td></td></tr>
<tr><th id="254">254</th><td><i>// Overloads for `absl::LogSeverity` can't (easily) appear alongside that type's</i></td></tr>
<tr><th id="255">255</th><td><i>// definition because it is layered below flags.  See proper documentation in</i></td></tr>
<tr><th id="256">256</th><td><i>// base/log_severity.h.</i></td></tr>
<tr><th id="257">257</th><td><b>enum</b> <b>class</b> <dfn class="type" id="absl::lts_2020_02_25::LogSeverity" title='absl::lts_2020_02_25::LogSeverity' data-ref="absl::lts_2020_02_25::LogSeverity" data-ref-filename="absl..lts_2020_02_25..LogSeverity">LogSeverity</dfn> : <em>int</em>;</td></tr>
<tr><th id="258">258</th><td><em>bool</em> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2513AbslParseFlagENS0_11string_viewEPNS0_11LogSeverityEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" title='absl::lts_2020_02_25::AbslParseFlag' data-ref="_ZN4absl14lts_2020_02_2513AbslParseFlagENS0_11string_viewEPNS0_11LogSeverityEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE" data-ref-filename="_ZN4absl14lts_2020_02_2513AbslParseFlagENS0_11string_viewEPNS0_11LogSeverityEPNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE">AbslParseFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="../strings/string_view.h.html#absl::lts_2020_02_25::string_view" title='absl::lts_2020_02_25::string_view' data-ref="absl::lts_2020_02_25::string_view" data-ref-filename="absl..lts_2020_02_25..string_view">string_view</a>, <span class="namespace">absl::</span><a class="type" href="#absl::lts_2020_02_25::LogSeverity" title='absl::lts_2020_02_25::LogSeverity' data-ref="absl::lts_2020_02_25::LogSeverity" data-ref-filename="absl..lts_2020_02_25..LogSeverity">LogSeverity</a>*, <span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span>*);</td></tr>
<tr><th id="259">259</th><td><span class="namespace">std::</span><span class='typedef' title='std::string' data-type='basic_string&lt;char&gt;' data-ref="std::string" data-ref-filename="std..string">string</span> <dfn class="decl fn" id="_ZN4absl14lts_2020_02_2515AbslUnparseFlagB5cxx11ENS0_11LogSeverityE" title='absl::lts_2020_02_25::AbslUnparseFlag' data-ref="_ZN4absl14lts_2020_02_2515AbslUnparseFlagB5cxx11ENS0_11LogSeverityE" data-ref-filename="_ZN4absl14lts_2020_02_2515AbslUnparseFlagB5cxx11ENS0_11LogSeverityE">AbslUnparseFlag</dfn>(<span class="namespace">absl::</span><a class="type" href="#absl::lts_2020_02_25::LogSeverity" title='absl::lts_2020_02_25::LogSeverity' data-ref="absl::lts_2020_02_25::LogSeverity" data-ref-filename="absl..lts_2020_02_25..LogSeverity">LogSeverity</a>);</td></tr>
<tr><th id="260">260</th><td></td></tr>
<tr><th id="261">261</th><td><a class="macro" href="../base/config.h.html#127" title="}" data-ref="_M/ABSL_NAMESPACE_END">ABSL_NAMESPACE_END</a></td></tr>
<tr><th id="262">262</th><td>}  <i>// namespace absl</i></td></tr>
<tr><th id="263">263</th><td></td></tr>
<tr><th id="264">264</th><td><u>#<span data-ppcond="162">endif</span>  // ABSL_FLAGS_MARSHALLING_H_</u></td></tr>
<tr><th id="265">265</th><td></td></tr>
</table><hr/><p id='footer'>
Generated while processing <a href='flag.cc.html'>halide/build-apps/abseil-cpp/absl/flags/flag.cc</a><br/>Generated on <em>2021-Aug-05</em> from project halide revision <em>v12.0.1</em>