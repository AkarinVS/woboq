<dec f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='309' type='void absl::lts_2020_02_25::Mutex::Await(const absl::lts_2020_02_25::Condition &amp; cond)'/>
<doc f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='269'>// ---------------------------------------------------------------------------
  // Conditional Critical Regions
  // ---------------------------------------------------------------------------

  // Conditional usage of a `Mutex` can occur using two distinct paradigms:
  //
  //   * Use of `Mutex` member functions with `Condition` objects.
  //   * Use of the separate `CondVar` abstraction.
  //
  // In general, prefer use of `Condition` and the `Mutex` member functions
  // listed below over `CondVar`. When there are multiple threads waiting on
  // distinctly different conditions, however, a battery of `CondVar`s may be
  // more efficient. This section discusses use of `Condition` objects.
  //
  // `Mutex` contains member functions for performing lock operations only under
  // certain conditions, of class `Condition`. For correctness, the `Condition`
  // must return a boolean that is a pure function, only of state protected by
  // the `Mutex`. The condition must be invariant w.r.t. environmental state
  // such as thread, cpu id, or time, and must be `noexcept`. The condition will
  // always be invoked with the mutex held in at least read mode, so you should
  // not block it for long periods or sleep it on a timer.
  //
  // Since a condition must not depend directly on the current time, use
  // `*WithTimeout()` member function variants to make your condition
  // effectively true after a given duration, or `*WithDeadline()` variants to
  // make your condition effectively true after a given time.
  //
  // The condition function should have no side-effects aside from debug
  // logging; as a special exception, the function may acquire other mutexes
  // provided it releases all those that it acquires.  (This exception was
  // required to allow logging.)

  // Mutex::Await()
  //
  // Unlocks this `Mutex` and blocks until simultaneously both `cond` is `true`
  // and this `Mutex` can be reacquired, then reacquires this `Mutex` in the
  // same mode in which it was previously held. If the condition is initially
  // `true`, `Await()` *may* skip the release/re-acquire step.
  //
  // `Await()` requires that this thread holds this `Mutex` in some mode.</doc>
<use f='halide/build-apps/abseil-cpp/absl/synchronization/barrier.cc' l='39' u='c' c='_ZN4absl14lts_2020_02_257Barrier5BlockEv'/>
<use f='halide/build-apps/abseil-cpp/absl/synchronization/blocking_counter.cc' l='48' u='c' c='_ZN4absl14lts_2020_02_2515BlockingCounter4WaitEv'/>
<def f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.cc' l='1536' ll='1545' type='void absl::lts_2020_02_25::Mutex::Await(const absl::lts_2020_02_25::Condition &amp; cond)'/>
