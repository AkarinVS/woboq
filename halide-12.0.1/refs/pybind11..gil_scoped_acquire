<def f='halide/build/_deps/pybind11-src/include/pybind11/pybind11.h' l='2115' ll='2192'/>
<use f='halide/build/_deps/pybind11-src/include/pybind11/pybind11.h' l='2260' c='_ZN8pybind1117error_already_setD1Ev'/>
<size>16</size>
<doc f='halide/build/_deps/pybind11-src/include/pybind11/pybind11.h' l='2093'>/* The functions below essentially reproduce the PyGILState_* API using a RAII
 * pattern, but there are a few important differences:
 *
 * 1. When acquiring the GIL from an non-main thread during the finalization
 *    phase, the GILState API blindly terminates the calling thread, which
 *    is often not what is wanted. This API does not do this.
 *
 * 2. The gil_scoped_release function can optionally cut the relationship
 *    of a PyThreadState and its associated thread, which allows moving it to
 *    another thread (this is a fairly rare/advanced use case).
 *
 * 3. The reference count of an acquired thread state can be controlled. This
 *    can be handy to prevent cases where callbacks issued from an external
 *    thread would otherwise constantly construct and destroy thread state data
 *    structures.
 *
 * See the Python bindings of NanoGUI (http://github.com/wjakob/nanogui) for an
 * example which uses features 2 and 3 to migrate the Python thread of
 * execution to another thread (to run the event loop on the original thread,
 * in this case).
 */</doc>
<fun r='_ZN8pybind1118gil_scoped_acquireC1Ev'/>
<fun r='_ZN8pybind1118gil_scoped_acquire7inc_refEv'/>
<fun r='_ZN8pybind1118gil_scoped_acquire7dec_refEv'/>
<fun r='_ZN8pybind1118gil_scoped_acquire6disarmEv'/>
<fun r='_ZN8pybind1118gil_scoped_acquireD1Ev'/>
<mbr r='pybind11::gil_scoped_acquire::tstate' o='0' t='PyThreadState *'/>
<mbr r='pybind11::gil_scoped_acquire::release' o='64' t='bool'/>
<mbr r='pybind11::gil_scoped_acquire::active' o='72' t='bool'/>
