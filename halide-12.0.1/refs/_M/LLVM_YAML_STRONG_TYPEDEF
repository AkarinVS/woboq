<dec f='halide/llvm-install/include/llvm/Support/YAMLTraits.h' l='1668'/>
<use f='halide/llvm-install/include/llvm/Support/YAMLTraits.h' l='1687' u='c'/>
<use f='halide/llvm-install/include/llvm/Support/YAMLTraits.h' l='1688' u='c'/>
<use f='halide/llvm-install/include/llvm/Support/YAMLTraits.h' l='1689' u='c'/>
<use f='halide/llvm-install/include/llvm/Support/YAMLTraits.h' l='1690' u='c'/>
<doc f='halide/llvm-install/include/llvm/Support/YAMLTraits.h' l='1660'>/// YAML I/O does conversion based on types. But often native data types
/// are just a typedef of built in intergral types (e.g. int).  But the C++
/// type matching system sees through the typedef and all the typedefed types
/// look like a built in type. This will cause the generic YAML I/O conversion
/// to be used. To provide better control over the YAML conversion, you can
/// use this macro instead of typedef.  It will create a class with one field
/// and automatic conversion operators to and from the base type.
/// Based on BOOST_STRONG_TYPEDEF</doc>
