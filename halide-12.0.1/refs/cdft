<dec f='halide/build-apps/_deps/tflite-src/third_party/fft2d/fft.h' l='25' type='void cdft(int , int , double * , int * , double * )'/>
<def f='halide/build-apps/fft2d/fftsg.c' l='285' ll='302' type='void cdft(int n, int isgn, double * a, int * ip, double * w)'/>
<doc f='halide/build-apps/fft2d/fftsg.c' l='1'>/*
Fast Fourier/Cosine/Sine Transform
    dimension   :one
    data length :power of 2
    decimation  :frequency
    radix       :split-radix
    data        :inplace
    table       :use
functions
    cdft: Complex Discrete Fourier Transform
    rdft: Real Discrete Fourier Transform
    ddct: Discrete Cosine Transform
    ddst: Discrete Sine Transform
    dfct: Cosine Transform of RDFT (Real Symmetric DFT)
    dfst: Sine Transform of RDFT (Real Anti-symmetric DFT)
function prototypes
    void cdft(int, int, double *, int *, double *);
    void rdft(int, int, double *, int *, double *);
    void ddct(int, int, double *, int *, double *);
    void ddst(int, int, double *, int *, double *);
    void dfct(int, double *, double *, int *, double *);
    void dfst(int, double *, double *, int *, double *);
macro definitions
    USE_CDFT_PTHREADS : default=not defined
        CDFT_THREADS_BEGIN_N  : must be &gt;= 512, default=8192
        CDFT_4THREADS_BEGIN_N : must be &gt;= 512, default=65536
    USE_CDFT_WINTHREADS : default=not defined
        CDFT_THREADS_BEGIN_N  : must be &gt;= 512, default=32768
        CDFT_4THREADS_BEGIN_N : must be &gt;= 512, default=524288


-------- Complex DFT (Discrete Fourier Transform) --------
    [definition]
        &lt;case1&gt;
            X[k] = sum_j=0^n-1 x[j]*exp(2*pi*i*j*k/n), 0&lt;=k&lt;n
        &lt;case2&gt;
            X[k] = sum_j=0^n-1 x[j]*exp(-2*pi*i*j*k/n), 0&lt;=k&lt;n
        (notes: sum_j=0^n-1 is a summation from j=0 to n-1)
    [usage]
        &lt;case1&gt;
            ip[0] = 0; // first time only
            cdft(2*n, 1, a, ip, w);
        &lt;case2&gt;
            ip[0] = 0; // first time only
            cdft(2*n, -1, a, ip, w);
    [parameters]
        2*n            :data length (int)
                        n &gt;= 1, n = power of 2
        a[0...2*n-1]   :input/output data (double *)
                        input data
                            a[2*j] = Re(x[j]), 
                            a[2*j+1] = Im(x[j]), 0&lt;=j&lt;n
                        output data
                            a[2*k] = Re(X[k]), 
                            a[2*k+1] = Im(X[k]), 0&lt;=k&lt;n
        ip[0...*]      :work area for bit reversal (int *)
                        length of ip &gt;= 2+sqrt(n)
                        strictly, 
                        length of ip &gt;= 
                            2+(1&lt;&lt;(int)(log(n+0.5)/log(2))/2).
                        ip[0],ip[1] are pointers of the cos/sin table.
        w[0...n/2-1]   :cos/sin table (double *)
                        w[],ip[] are initialized if ip[0] == 0.
    [remark]
        Inverse of 
            cdft(2*n, -1, a, ip, w);
        is 
            cdft(2*n, 1, a, ip, w);
            for (j = 0; j &lt;= 2 * n - 1; j++) {
                a[j] *= 1.0 / n;
            }
        .


-------- Real DFT / Inverse of Real DFT --------
    [definition]
        &lt;case1&gt; RDFT
            R[k] = sum_j=0^n-1 a[j]*cos(2*pi*j*k/n), 0&lt;=k&lt;=n/2
            I[k] = sum_j=0^n-1 a[j]*sin(2*pi*j*k/n), 0&lt;k&lt;n/2
        &lt;case2&gt; IRDFT (excluding scale)
            a[k] = (R[0] + R[n/2]*cos(pi*k))/2 + 
                   sum_j=1^n/2-1 R[j]*cos(2*pi*j*k/n) + 
                   sum_j=1^n/2-1 I[j]*sin(2*pi*j*k/n), 0&lt;=k&lt;n
    [usage]
        &lt;case1&gt;
            ip[0] = 0; // first time only
            rdft(n, 1, a, ip, w);
        &lt;case2&gt;
            ip[0] = 0; // first time only
            rdft(n, -1, a, ip, w);
    [parameters]
        n              :data length (int)
                        n &gt;= 2, n = power of 2
        a[0...n-1]     :input/output data (double *)
                        &lt;case1&gt;
                            output data
                                a[2*k] = R[k], 0&lt;=k&lt;n/2
                                a[2*k+1] = I[k], 0&lt;k&lt;n/2
                                a[1] = R[n/2]
                        &lt;case2&gt;
                            input data
                                a[2*j] = R[j], 0&lt;=j&lt;n/2
                                a[2*j+1] = I[j], 0&lt;j&lt;n/2
                                a[1] = R[n/2]
        ip[0...*]      :work area for bit reversal (int *)
                        length of ip &gt;= 2+sqrt(n/2)
                        strictly, 
                        length of ip &gt;= 
                            2+(1&lt;&lt;(int)(log(n/2+0.5)/log(2))/2).
                        ip[0],ip[1] are pointers of the cos/sin table.
        w[0...n/2-1]   :cos/sin table (double *)
                        w[],ip[] are initialized if ip[0] == 0.
    [remark]
        Inverse of 
            rdft(n, 1, a, ip, w);
        is 
            rdft(n, -1, a, ip, w);
            for (j = 0; j &lt;= n - 1; j++) {
                a[j] *= 2.0 / n;
            }
        .


-------- DCT (Discrete Cosine Transform) / Inverse of DCT --------
    [definition]
        &lt;case1&gt; IDCT (excluding scale)
            C[k] = sum_j=0^n-1 a[j]*cos(pi*j*(k+1/2)/n), 0&lt;=k&lt;n
        &lt;case2&gt; DCT
            C[k] = sum_j=0^n-1 a[j]*cos(pi*(j+1/2)*k/n), 0&lt;=k&lt;n
    [usage]
        &lt;case1&gt;
            ip[0] = 0; // first time only
            ddct(n, 1, a, ip, w);
        &lt;case2&gt;
            ip[0] = 0; // first time only
            ddct(n, -1, a, ip, w);
    [parameters]
        n              :data length (int)
                        n &gt;= 2, n = power of 2
        a[0...n-1]     :input/output data (double *)
                        output data
                            a[k] = C[k], 0&lt;=k&lt;n
        ip[0...*]      :work area for bit reversal (int *)
                        length of ip &gt;= 2+sqrt(n/2)
                        strictly, 
                        length of ip &gt;= 
                            2+(1&lt;&lt;(int)(log(n/2+0.5)/log(2))/2).
                        ip[0],ip[1] are pointers of the cos/sin table.
        w[0...n*5/4-1] :cos/sin table (double *)
                        w[],ip[] are initialized if ip[0] == 0.
    [remark]
        Inverse of 
            ddct(n, -1, a, ip, w);
        is 
            a[0] *= 0.5;
            ddct(n, 1, a, ip, w);
            for (j = 0; j &lt;= n - 1; j++) {
                a[j] *= 2.0 / n;
            }
        .


-------- DST (Discrete Sine Transform) / Inverse of DST --------
    [definition]
        &lt;case1&gt; IDST (excluding scale)
            S[k] = sum_j=1^n A[j]*sin(pi*j*(k+1/2)/n), 0&lt;=k&lt;n
        &lt;case2&gt; DST
            S[k] = sum_j=0^n-1 a[j]*sin(pi*(j+1/2)*k/n), 0&lt;k&lt;=n
    [usage]
        &lt;case1&gt;
            ip[0] = 0; // first time only
            ddst(n, 1, a, ip, w);
        &lt;case2&gt;
            ip[0] = 0; // first time only
            ddst(n, -1, a, ip, w);
    [parameters]
        n              :data length (int)
                        n &gt;= 2, n = power of 2
        a[0...n-1]     :input/output data (double *)
                        &lt;case1&gt;
                            input data
                                a[j] = A[j], 0&lt;j&lt;n
                                a[0] = A[n]
                            output data
                                a[k] = S[k], 0&lt;=k&lt;n
                        &lt;case2&gt;
                            output data
                                a[k] = S[k], 0&lt;k&lt;n
                                a[0] = S[n]
        ip[0...*]      :work area for bit reversal (int *)
                        length of ip &gt;= 2+sqrt(n/2)
                        strictly, 
                        length of ip &gt;= 
                            2+(1&lt;&lt;(int)(log(n/2+0.5)/log(2))/2).
                        ip[0],ip[1] are pointers of the cos/sin table.
        w[0...n*5/4-1] :cos/sin table (double *)
                        w[],ip[] are initialized if ip[0] == 0.
    [remark]
        Inverse of 
            ddst(n, -1, a, ip, w);
        is 
            a[0] *= 0.5;
            ddst(n, 1, a, ip, w);
            for (j = 0; j &lt;= n - 1; j++) {
                a[j] *= 2.0 / n;
            }
        .


-------- Cosine Transform of RDFT (Real Symmetric DFT) --------
    [definition]
        C[k] = sum_j=0^n a[j]*cos(pi*j*k/n), 0&lt;=k&lt;=n
    [usage]
        ip[0] = 0; // first time only
        dfct(n, a, t, ip, w);
    [parameters]
        n              :data length - 1 (int)
                        n &gt;= 2, n = power of 2
        a[0...n]       :input/output data (double *)
                        output data
                            a[k] = C[k], 0&lt;=k&lt;=n
        t[0...n/2]     :work area (double *)
        ip[0...*]      :work area for bit reversal (int *)
                        length of ip &gt;= 2+sqrt(n/4)
                        strictly, 
                        length of ip &gt;= 
                            2+(1&lt;&lt;(int)(log(n/4+0.5)/log(2))/2).
                        ip[0],ip[1] are pointers of the cos/sin table.
        w[0...n*5/8-1] :cos/sin table (double *)
                        w[],ip[] are initialized if ip[0] == 0.
    [remark]
        Inverse of 
            a[0] *= 0.5;
            a[n] *= 0.5;
            dfct(n, a, t, ip, w);
        is 
            a[0] *= 0.5;
            a[n] *= 0.5;
            dfct(n, a, t, ip, w);
            for (j = 0; j &lt;= n; j++) {
                a[j] *= 2.0 / n;
            }
        .


-------- Sine Transform of RDFT (Real Anti-symmetric DFT) --------
    [definition]
        S[k] = sum_j=1^n-1 a[j]*sin(pi*j*k/n), 0&lt;k&lt;n
    [usage]
        ip[0] = 0; // first time only
        dfst(n, a, t, ip, w);
    [parameters]
        n              :data length + 1 (int)
                        n &gt;= 2, n = power of 2
        a[0...n-1]     :input/output data (double *)
                        output data
                            a[k] = S[k], 0&lt;k&lt;n
                        (a[0] is used for work area)
        t[0...n/2-1]   :work area (double *)
        ip[0...*]      :work area for bit reversal (int *)
                        length of ip &gt;= 2+sqrt(n/4)
                        strictly, 
                        length of ip &gt;= 
                            2+(1&lt;&lt;(int)(log(n/4+0.5)/log(2))/2).
                        ip[0],ip[1] are pointers of the cos/sin table.
        w[0...n*5/8-1] :cos/sin table (double *)
                        w[],ip[] are initialized if ip[0] == 0.
    [remark]
        Inverse of 
            dfst(n, a, t, ip, w);
        is 
            dfst(n, a, t, ip, w);
            for (j = 1; j &lt;= n - 1; j++) {
                a[j] *= 2.0 / n;
            }
        .


Appendix :
    The cos/sin table is recalculated when the larger table required.
    w[] and ip[] are compatible with all routines.
*/</doc>
<dec f='halide/build-apps/fft2d/fftsg2d.c' l='401' type='void cdft(int n, int isgn, double * a, int * ip, double * w)'/>
<use f='halide/build-apps/fft2d/fftsg2d.c' l='443' u='c' c='cdft2d'/>
<dec f='halide/build-apps/fft2d/fftsg2d.c' l='700' type='void cdft(int n, int isgn, double * a, int * ip, double * w)'/>
<use f='halide/build-apps/fft2d/fftsg2d.c' l='715' u='c' c='cdft2d_sub'/>
<use f='halide/build-apps/fft2d/fftsg2d.c' l='716' u='c' c='cdft2d_sub'/>
<use f='halide/build-apps/fft2d/fftsg2d.c' l='717' u='c' c='cdft2d_sub'/>
<use f='halide/build-apps/fft2d/fftsg2d.c' l='718' u='c' c='cdft2d_sub'/>
<use f='halide/build-apps/fft2d/fftsg2d.c' l='737' u='c' c='cdft2d_sub'/>
<use f='halide/build-apps/fft2d/fftsg2d.c' l='738' u='c' c='cdft2d_sub'/>
<use f='halide/build-apps/fft2d/fftsg2d.c' l='750' u='c' c='cdft2d_sub'/>
<dec f='halide/build-apps/fft2d/fftsg3d.c' l='861' type='void cdft(int n, int isgn, double * a, int * ip, double * w)'/>
<use f='halide/build-apps/fft2d/fftsg3d.c' l='868' u='c' c='xdft3da_sub'/>
<use f='halide/build-apps/fft2d/fftsg3d.c' l='887' u='c' c='xdft3da_sub'/>
<use f='halide/build-apps/fft2d/fftsg3d.c' l='888' u='c' c='xdft3da_sub'/>
<use f='halide/build-apps/fft2d/fftsg3d.c' l='889' u='c' c='xdft3da_sub'/>
<use f='halide/build-apps/fft2d/fftsg3d.c' l='890' u='c' c='xdft3da_sub'/>
<use f='halide/build-apps/fft2d/fftsg3d.c' l='909' u='c' c='xdft3da_sub'/>
<use f='halide/build-apps/fft2d/fftsg3d.c' l='910' u='c' c='xdft3da_sub'/>
<use f='halide/build-apps/fft2d/fftsg3d.c' l='922' u='c' c='xdft3da_sub'/>
<dec f='halide/build-apps/fft2d/fftsg3d.c' l='940' type='void cdft(int n, int isgn, double * a, int * ip, double * w)'/>
<use f='halide/build-apps/fft2d/fftsg3d.c' l='956' u='c' c='cdft3db_sub'/>
<use f='halide/build-apps/fft2d/fftsg3d.c' l='957' u='c' c='cdft3db_sub'/>
<use f='halide/build-apps/fft2d/fftsg3d.c' l='958' u='c' c='cdft3db_sub'/>
<use f='halide/build-apps/fft2d/fftsg3d.c' l='959' u='c' c='cdft3db_sub'/>
<use f='halide/build-apps/fft2d/fftsg3d.c' l='980' u='c' c='cdft3db_sub'/>
<use f='halide/build-apps/fft2d/fftsg3d.c' l='981' u='c' c='cdft3db_sub'/>
<use f='halide/build-apps/fft2d/fftsg3d.c' l='995' u='c' c='cdft3db_sub'/>
