<dec f='halide/build/include/Halide.h' l='30573' type='bool Halide::Internal::can_parallelize_rvar(const std::string &amp; rvar, const std::string &amp; func, const Halide::Internal::Definition &amp; r)'/>
<doc f='halide/build/include/Halide.h' l='30568'>/** Returns whether or not Halide can prove that it is safe to
 * parallelize an update definition across a specific variable. If
 * this returns true, it&apos;s definitely safe. If this returns false, it
 * may still be safe, but Halide couldn&apos;t prove it.
 */</doc>
<dec f='halide/src/ParallelRVar.h' l='22' type='bool Halide::Internal::can_parallelize_rvar(const std::string &amp; rvar, const std::string &amp; func, const Halide::Internal::Definition &amp; r)'/>
<use f='halide/src/Function.cpp' l='663' u='c' c='_ZN6Halide8Internal8Function13define_updateERKSt6vectorINS_4ExprESaIS3_EES5_'/>
<doc f='halide/src/ParallelRVar.h' l='17'>/** Returns whether or not Halide can prove that it is safe to
 * parallelize an update definition across a specific variable. If
 * this returns true, it&apos;s definitely safe. If this returns false, it
 * may still be safe, but Halide couldn&apos;t prove it.
 */</doc>
<def f='halide/src/ParallelRVar.cpp' l='93' ll='167' type='bool Halide::Internal::can_parallelize_rvar(const std::string &amp; v, const std::string &amp; f, const Halide::Internal::Definition &amp; r)'/>
<use f='halide/src/autoschedulers/mullapudi2016/AutoSchedule.cpp' l='1844' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_111Partitioner13analyze_groupERKNS2_5GroupEb'/>
<use f='halide/src/autoschedulers/mullapudi2016/AutoSchedule.cpp' l='2411' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_111Partitioner15vectorize_stageERKNS2_5GroupENS_5StageEiNS0_10DefinitionERKNS0_8FunctionEbRKNS_6TargetERSt3setINSt7__c12967337'/>
<use f='halide/src/autoschedulers/mullapudi2016/AutoSchedule.cpp' l='2748' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_111Partitioner27generate_group_cpu_scheduleERKNS2_5GroupERKNS_6TargetERKSt3mapINS1_6FStageES9_INSt7__cxx1112basic_stri4682444'/>
