<dec f='halide/halide-install/include/Halide.h' l='8018' type='Halide::Expr Halide::div_round_to_zero(Halide::Expr x, Halide::Expr y)'/>
<doc f='halide/halide-install/include/Halide.h' l='8013'>/** Divide two integers, rounding towards zero. This is the typical
 * behavior of most hardware architectures, which differs from
 * Halide&apos;s division operator, which is Euclidean (rounds towards
 * -infinity). Will throw a runtime error if y is zero, or if y is -1
 * and x is the minimum signed integer. */</doc>
<dec f='halide/build/include/Halide.h' l='8018' type='Halide::Expr Halide::div_round_to_zero(Halide::Expr x, Halide::Expr y)'/>
<doc f='halide/build/include/Halide.h' l='8013'>/** Divide two integers, rounding towards zero. This is the typical
 * behavior of most hardware architectures, which differs from
 * Halide&apos;s division operator, which is Euclidean (rounds towards
 * -infinity). Will throw a runtime error if y is zero, or if y is -1
 * and x is the minimum signed integer. */</doc>
<use f='halide/python_bindings/src/PyIROperator.cpp' l='170' u='a' c='_ZN6Halide14PythonBindings16define_operatorsERN8pybind117module_E'/>
<dec f='halide/src/IROperator.h' l='1213' type='Halide::Expr Halide::div_round_to_zero(Halide::Expr x, Halide::Expr y)'/>
<doc f='halide/src/IROperator.h' l='1208'>/** Divide two integers, rounding towards zero. This is the typical
 * behavior of most hardware architectures, which differs from
 * Halide&apos;s division operator, which is Euclidean (rounds towards
 * -infinity). Will throw a runtime error if y is zero, or if y is -1
 * and x is the minimum signed integer. */</doc>
<def f='halide/src/IROperator.cpp' l='2495' ll='2508' type='Halide::Expr Halide::div_round_to_zero(Halide::Expr x, Halide::Expr y)'/>
