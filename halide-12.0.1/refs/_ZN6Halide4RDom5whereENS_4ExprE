<dec f='halide/build/include/Halide.h' l='15669' type='void Halide::RDom::where(Halide::Expr predicate)'/>
<doc f='halide/build/include/Halide.h' l='15606'>/** Add a predicate to the RDom. An RDom may have multiple
     * predicates associated with it. An update definition that uses
     * an RDom only iterates over the subset points in the domain for
     * which all of its predicates are true. The predicate expression
     * obeys the same rules as the expressions used on the
     * right-hand-side of the corresponding update definition. It may
     * refer to the RDom&apos;s variables and free variables in the Func&apos;s
     * update definition. It may include calls to other Funcs, or make
     * recursive calls to the same Func. This permits iteration over
     * non-rectangular domains, or domains with sizes that vary with
     * some free variable, or domains with shapes determined by some
     * other Func.
     *
     * Note that once RDom is used in the update definition of some
     * Func, no new predicates can be added to the RDom.
     *
     * Consider a simple example:
     \code
     RDom r(0, 20, 0, 20);
     r.where(r.x &lt; r.y);
     r.where(r.x == 10);
     r.where(r.y &gt; 13);
     f(r.x, r.y) += 1;
     \endcode
     * This is equivalent to:
     \code
     for (int r.y = 0; r.y &lt; 20; r.y++) {
       if (r.y &gt; 13) {
         for (int r.x = 0; r.x &lt; 20; r.x++) {
           if (r.x == 10) {
             if (r.x &lt; r.y) {
               f[r.x, r.y] += 1;
             }
           }
         }
       }
     }
     \endcode
     *
     * Where possible Halide restricts the range of the containing for
     * loops to avoid the cases where the predicate is false so that
     * the if statement can be removed entirely. The case above would
     * be further simplified into:
     *
     \code
     for (int r.y = 14; r.y &lt; 20; r.y++) {
       f[r.x, r.y] += 1;
     }
     \endcode
     *
     * In general, the predicates that we can simplify away by
     * restricting loop ranges are inequalities that compare an inner
     * Var or RVar to some expression in outer Vars or RVars.
     *
     * You can also pack multiple conditions into one predicate like so:
     *
     \code
     RDom r(0, 20, 0, 20);
     r.where((r.x &lt; r.y) &amp;&amp; (r.x == 10) &amp;&amp; (r.y &gt; 13));
     f(r.x, r.y) += 1;
     \endcode
     *
     */</doc>
<use f='halide/python_bindings/src/PyRDom.cpp' l='42' u='a' c='_ZN6Halide14PythonBindings11define_rdomERN8pybind117module_E'/>
<dec f='halide/src/RDom.h' l='331' type='void Halide::RDom::where(Halide::Expr predicate)'/>
<doc f='halide/src/RDom.h' l='268'>/** Add a predicate to the RDom. An RDom may have multiple
     * predicates associated with it. An update definition that uses
     * an RDom only iterates over the subset points in the domain for
     * which all of its predicates are true. The predicate expression
     * obeys the same rules as the expressions used on the
     * right-hand-side of the corresponding update definition. It may
     * refer to the RDom&apos;s variables and free variables in the Func&apos;s
     * update definition. It may include calls to other Funcs, or make
     * recursive calls to the same Func. This permits iteration over
     * non-rectangular domains, or domains with sizes that vary with
     * some free variable, or domains with shapes determined by some
     * other Func.
     *
     * Note that once RDom is used in the update definition of some
     * Func, no new predicates can be added to the RDom.
     *
     * Consider a simple example:
     \code
     RDom r(0, 20, 0, 20);
     r.where(r.x &lt; r.y);
     r.where(r.x == 10);
     r.where(r.y &gt; 13);
     f(r.x, r.y) += 1;
     \endcode
     * This is equivalent to:
     \code
     for (int r.y = 0; r.y &lt; 20; r.y++) {
       if (r.y &gt; 13) {
         for (int r.x = 0; r.x &lt; 20; r.x++) {
           if (r.x == 10) {
             if (r.x &lt; r.y) {
               f[r.x, r.y] += 1;
             }
           }
         }
       }
     }
     \endcode
     *
     * Where possible Halide restricts the range of the containing for
     * loops to avoid the cases where the predicate is false so that
     * the if statement can be removed entirely. The case above would
     * be further simplified into:
     *
     \code
     for (int r.y = 14; r.y &lt; 20; r.y++) {
       f[r.x, r.y] += 1;
     }
     \endcode
     *
     * In general, the predicates that we can simplify away by
     * restricting loop ranges are inequalities that compare an inner
     * Var or RVar to some expression in outer Vars or RVars.
     *
     * You can also pack multiple conditions into one predicate like so:
     *
     \code
     RDom r(0, 20, 0, 20);
     r.where((r.x &lt; r.y) &amp;&amp; (r.x == 10) &amp;&amp; (r.y &gt; 13));
     f(r.x, r.y) += 1;
     \endcode
     *
     */</doc>
<use f='halide/src/Derivative.cpp' l='1760' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_126ReverseAccumulationVisitor30propagate_halide_function_callENS_4ExprERKNSt7__cxx1112basic_stringIcSt11char_traitsIcE10448212'/>
<use f='halide/src/DerivativeUtils.cpp' l='394' u='c' c='_ZN6Halide8Internal13solve_inverseENS_4ExprERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_'/>
<use f='halide/src/Func.cpp' l='857' u='c' c='_ZN6Halide5Stage7rfactorESt6vectorISt4pairINS_4RVarENS_3VarEESaIS5_EE'/>
<use f='halide/src/Func.cpp' l='863' u='c' c='_ZN6Halide5Stage7rfactorESt6vectorISt4pairINS_4RVarENS_3VarEESaIS5_EE'/>
<def f='halide/src/RDom.cpp' l='238' ll='244' type='void Halide::RDom::where(Halide::Expr predicate)'/>
<use f='halide/tutorial/lesson_17_predicated_rdom.cpp' l='58' u='c' c='main'/>
<use f='halide/tutorial/lesson_17_predicated_rdom.cpp' l='109' u='c' c='main'/>
<use f='halide/tutorial/lesson_17_predicated_rdom.cpp' l='110' u='c' c='main'/>
<use f='halide/tutorial/lesson_17_predicated_rdom.cpp' l='111' u='c' c='main'/>
<use f='halide/tutorial/lesson_17_predicated_rdom.cpp' l='164' u='c' c='main'/>
<use f='halide/tutorial/lesson_17_predicated_rdom.cpp' l='165' u='c' c='main'/>
<use f='halide/tutorial/lesson_17_predicated_rdom.cpp' l='172' u='c' c='main'/>
