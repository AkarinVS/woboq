<dec f='halide/halide-install/include/Halide.h' l='8256' type='Halide::Expr Halide::unsafe_promise_clamped(const Halide::Expr &amp; value, const Halide::Expr &amp; min, const Halide::Expr &amp; max)'/>
<doc f='halide/halide-install/include/Halide.h' l='8238'>/** Create an Expr that that promises another Expr is clamped but do
 * not generate code to check the assertion or modify the value. No
 * attempt is made to prove the bound at compile time. (If it is
 * proved false as a result of something else, an error might be
 * generated, but it is also possible the compiler will crash.) The
 * promised bound is used in bounds inference so it will allow
 * satisfying bounds checks as well as possibly aiding optimization.
 *
 * unsafe_promise_clamped returns its first argument, the Expr &apos;value&apos;
 *
 * This is a very easy way to make Halide generate erroneous code if
 * the bound promises is not kept. Use sparingly when there is no
 * other way to convey the information to the compiler and it is
 * required for a valuable optimization.
 *
 * Unsafe promises can be checked by turning on
 * Target::CheckUnsafePromises. This is intended for debugging only.
 */</doc>
<use f='halide/apps/hannk/halide/elementwise_generator.cpp' l='145' u='c' c='_ZN5hannk11Elementwise5buildEv'/>
<use f='halide/apps/hannk/halide/elementwise_generator.cpp' l='146' u='c' c='_ZN5hannk11Elementwise5buildEv'/>
<dec f='halide/build/include/Halide.h' l='8256' type='Halide::Expr Halide::unsafe_promise_clamped(const Halide::Expr &amp; value, const Halide::Expr &amp; min, const Halide::Expr &amp; max)'/>
<doc f='halide/build/include/Halide.h' l='8238'>/** Create an Expr that that promises another Expr is clamped but do
 * not generate code to check the assertion or modify the value. No
 * attempt is made to prove the bound at compile time. (If it is
 * proved false as a result of something else, an error might be
 * generated, but it is also possible the compiler will crash.) The
 * promised bound is used in bounds inference so it will allow
 * satisfying bounds checks as well as possibly aiding optimization.
 *
 * unsafe_promise_clamped returns its first argument, the Expr &apos;value&apos;
 *
 * This is a very easy way to make Halide generate erroneous code if
 * the bound promises is not kept. Use sparingly when there is no
 * other way to convey the information to the compiler and it is
 * required for a valuable optimization.
 *
 * Unsafe promises can be checked by turning on
 * Target::CheckUnsafePromises. This is intended for debugging only.
 */</doc>
<dec f='halide/src/IROperator.h' l='1451' type='Halide::Expr Halide::unsafe_promise_clamped(const Halide::Expr &amp; value, const Halide::Expr &amp; min, const Halide::Expr &amp; max)'/>
<doc f='halide/src/IROperator.h' l='1433'>/** Create an Expr that that promises another Expr is clamped but do
 * not generate code to check the assertion or modify the value. No
 * attempt is made to prove the bound at compile time. (If it is
 * proved false as a result of something else, an error might be
 * generated, but it is also possible the compiler will crash.) The
 * promised bound is used in bounds inference so it will allow
 * satisfying bounds checks as well as possibly aiding optimization.
 *
 * unsafe_promise_clamped returns its first argument, the Expr &apos;value&apos;
 *
 * This is a very easy way to make Halide generate erroneous code if
 * the bound promises is not kept. Use sparingly when there is no
 * other way to convey the information to the compiler and it is
 * required for a valuable optimization.
 *
 * Unsafe promises can be checked by turning on
 * Target::CheckUnsafePromises. This is intended for debugging only.
 */</doc>
<def f='halide/src/IROperator.cpp' l='1508' ll='1519' type='Halide::Expr Halide::unsafe_promise_clamped(const Halide::Expr &amp; value, const Halide::Expr &amp; min, const Halide::Expr &amp; max)'/>
