<def f='halide/build-apps/abseil-cpp/absl/base/internal/exponential_biased.h' l='74' ll='112'/>
<size>24</size>
<doc f='halide/build-apps/abseil-cpp/absl/base/internal/exponential_biased.h' l='27'>// ExponentialBiased provides a small and fast random number generator for a
// rounded exponential distribution. This generator manages very little state,
// and imposes no synchronization overhead. This makes it useful in specialized
// scenarios requiring minimum overhead, such as stride based periodic sampling.
//
// ExponentialBiased provides two closely related functions, GetSkipCount() and
// GetStride(), both returning a rounded integer defining a number of events
// required before some event with a given mean probability occurs.
//
// The distribution is useful to generate a random wait time or some periodic
// event with a given mean probability. For example, if an action is supposed to
// happen on average once every &apos;N&apos; events, then we can get a random &apos;stride&apos;
// counting down how long before the event to happen. For example, if we&apos;d want
// to sample one in every 1000 &apos;Frobber&apos; calls, our code could look like this:
//
//   Frobber::Frobber() {
//     stride_ = exponential_biased_.GetStride(1000);
//   }
//
//   void Frobber::Frob(int arg) {
//     if (--stride == 0) {
//       SampleFrob(arg);
//       stride_ = exponential_biased_.GetStride(1000);
//     }
//     ...
//   }
//
// The rounding of the return value creates a bias, especially for smaller means
// where the distribution of the fraction is not evenly distributed. We correct
// this bias by tracking the fraction we rounded up or down on each iteration,
// effectively tracking the distance between the cumulative value, and the
// rounded cumulative value. For example, given a mean of 2:
//
//   raw = 1.63076, cumulative = 1.63076, rounded = 2, bias = -0.36923
//   raw = 0.14624, cumulative = 1.77701, rounded = 2, bias =  0.14624
//   raw = 4.93194, cumulative = 6.70895, rounded = 7, bias = -0.06805
//   raw = 0.24206, cumulative = 6.95101, rounded = 7, bias =  0.24206
//   etc...
//
// Adjusting with rounding bias is relatively trivial:
//
//    double value = bias_ + exponential_distribution(mean)();
//    double rounded_value = std::round(value);
//    bias_ = value - rounded_value;
//    return rounded_value;
//
// This class is thread-compatible.</doc>
<smbr r='absl::lts_2020_02_25::base_internal::ExponentialBiased::kPrngNumBits' t='const int'/>
<fun r='_ZN4absl14lts_2020_02_2513base_internal17ExponentialBiased12GetSkipCountEl'/>
<fun r='_ZN4absl14lts_2020_02_2513base_internal17ExponentialBiased9GetStrideEl'/>
<fun r='_ZN4absl14lts_2020_02_2513base_internal17ExponentialBiased10NextRandomEm'/>
<fun r='_ZN4absl14lts_2020_02_2513base_internal17ExponentialBiased10InitializeEv'/>
<mbr r='absl::lts_2020_02_25::base_internal::ExponentialBiased::rng_' o='0' t='uint64_t'/>
<mbr r='absl::lts_2020_02_25::base_internal::ExponentialBiased::bias_' o='64' t='double'/>
<mbr r='absl::lts_2020_02_25::base_internal::ExponentialBiased::initialized_' o='128' t='bool'/>
<fun r='_ZN4absl14lts_2020_02_2513base_internal17ExponentialBiased10NextRandomEm'/>
<fun r='_ZN4absl14lts_2020_02_2513base_internal17ExponentialBiased12GetSkipCountEl'/>
<fun r='_ZN4absl14lts_2020_02_2513base_internal17ExponentialBiased9GetStrideEl'/>
<fun r='_ZN4absl14lts_2020_02_2513base_internal17ExponentialBiased10InitializeEv'/>
<use f='halide/build-apps/abseil-cpp/absl/base/internal/periodic_sampler.h' l='152'/>
<size>24</size>
<use f='halide/build-apps/abseil-cpp/absl/container/internal/hashtablez_sampler.cc' l='43'/>
<size>24</size>
