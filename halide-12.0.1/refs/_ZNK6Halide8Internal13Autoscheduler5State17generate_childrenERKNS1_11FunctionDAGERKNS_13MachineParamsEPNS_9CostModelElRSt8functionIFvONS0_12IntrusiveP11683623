<dec f='halide/src/autoschedulers/adams2019/State.h' l='81' type='void Halide::Internal::Autoscheduler::State::generate_children(const Halide::Internal::Autoscheduler::FunctionDAG &amp; dag, const Halide::MachineParams &amp; params, Halide::CostModel * cost_model, int64_t memory_limit, std::function&lt;void (IntrusivePtr&lt;State&gt; &amp;&amp;)&gt; &amp; accept_child, Halide::Internal::Autoscheduler::Cache * cache) const'/>
<use f='halide/src/autoschedulers/adams2019/AutoSchedule.cpp' l='422' u='c' c='_ZN6Halide8Internal13Autoscheduler21optimal_schedule_passERNS1_11FunctionDAGERKSt6vectorINS0_8FunctionESaIS5_EERKNS_13MachineParamsEPNS_9CostModelERSt14755906'/>
<doc f='halide/src/autoschedulers/adams2019/State.h' l='78'>// Generate the successor states to this state.
    // If they are not pruned by `calculate_cost()`,
    // then calls `accept_child()` on them.</doc>
<def f='halide/src/autoschedulers/adams2019/State.cpp' l='202' ll='529' type='void Halide::Internal::Autoscheduler::State::generate_children(const Halide::Internal::Autoscheduler::FunctionDAG &amp; dag, const Halide::MachineParams &amp; params, Halide::CostModel * cost_model, int64_t memory_limit, std::function&lt;void (IntrusivePtr&lt;State&gt; &amp;&amp;)&gt; &amp; accept_child, Halide::Internal::Autoscheduler::Cache * cache) const'/>
<doc f='halide/src/autoschedulers/adams2019/State.cpp' l='201'>// Generate the successor states to this state</doc>
