<dec f='halide/build/include/Halide.h' l='6102' type='2'/>
<use f='halide/build/include/Halide.h' l='6131' u='r' c='_ZNK6Halide8Internal3Dim7is_rvarEv'/>
<doc f='halide/build/include/Halide.h' l='6079'>/** The dim originated from an RVar. You must evaluate a Func at
     * distinct values of this RVar in increasing order over precisely
     * the interval specified in the RDom. ImpureRVars may not be
     * reordered with respect to other ImpureRVars.
     *
     * All RVars are impure by default. Those for which we can prove
     * no data hazards exist get promoted to PureRVar. There are two
     * instances in which ImpureRVars may be parallelized or reordered
     * even in the presence of hazards:
     *
     * 1) In the case of an update definition that has been proven to be
     * an associative and commutative reduction, reordering of
     * ImpureRVars is allowed, and parallelizing them is allowed if
     * the update has been made atomic.
     *
     * 2) ImpureRVars can also be reordered and parallelized if
     * Func::allow_race_conditions() has been set. This is the escape
     * hatch for when there are no hazards but the checks above failed
     * to prove that (RDom::where can encode arbitrary facts about
     * non-linear integer arithmetic, which is undecidable), or for
     * when you don&apos;t actually care about the non-determinism
     * introduced by data hazards (e.g. in the algorithm HOGWILD!).
     */</doc>
<dec f='halide/src/Schedule.h' l='385' type='2'/>
<use f='halide/src/Schedule.h' l='414' u='r' c='_ZNK6Halide8Internal3Dim7is_rvarEv'/>
<doc f='halide/src/Schedule.h' l='362'>/** The dim originated from an RVar. You must evaluate a Func at
     * distinct values of this RVar in increasing order over precisely
     * the interval specified in the RDom. ImpureRVars may not be
     * reordered with respect to other ImpureRVars.
     *
     * All RVars are impure by default. Those for which we can prove
     * no data hazards exist get promoted to PureRVar. There are two
     * instances in which ImpureRVars may be parallelized or reordered
     * even in the presence of hazards:
     *
     * 1) In the case of an update definition that has been proven to be
     * an associative and commutative reduction, reordering of
     * ImpureRVars is allowed, and parallelizing them is allowed if
     * the update has been made atomic.
     *
     * 2) ImpureRVars can also be reordered and parallelized if
     * Func::allow_race_conditions() has been set. This is the escape
     * hatch for when there are no hazards but the checks above failed
     * to prove that (RDom::where can encode arbitrary facts about
     * non-linear integer arithmetic, which is undecidable), or for
     * when you don&apos;t actually care about the non-determinism
     * introduced by data hazards (e.g. in the algorithm HOGWILD!).
     */</doc>
<use f='halide/src/Func.cpp' l='1172' u='r' c='_ZN6Halide5Stage4fuseERKNS_9VarOrRVarES3_S3_'/>
<use f='halide/src/Func.cpp' l='1173' u='r' c='_ZN6Halide5Stage4fuseERKNS_9VarOrRVarES3_S3_'/>
<use f='halide/src/Func.cpp' l='1174' u='r' c='_ZN6Halide5Stage4fuseERKNS_9VarOrRVarES3_S3_'/>
<use f='halide/src/Function.cpp' l='665' u='r' c='_ZN6Halide8Internal8Function13define_updateERKSt6vectorINS_4ExprESaIS3_EES5_'/>
<use f='halide/src/IRPrinter.cpp' l='376' c='_ZN6Halide8InternallsERSoRKNS0_7DimTypeE'/>
