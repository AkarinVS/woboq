<dec f='halide/build/include/HalideRuntime.h' l='912' type='int halide_memoization_cache_store(void * user_context, const uint8_t * cache_key, int32_t size, struct halide_buffer_t * realized_bounds, int32_t tuple_count, struct halide_buffer_t ** tuple_buffers, bool has_eviction_key, uint64_t eviction_key)'/>
<doc f='halide/build/include/HalideRuntime.h' l='895'>/** Given a cache key for a memoized result, currently constructed
 *  from the Func name and top-level Func name plus the arguments of
 *  the computation, store the result in the cache for futre access by
 *  halide_memoization_cache_lookup. (The internals of the cache key
 *  should be considered opaque by this function.) Data is copied out
 *  from the inputs and inputs are unmodified. The last argument is a
 *  list if halide_buffer_t pointers which represents the outputs of the
 *  memoized Func. If the Func does not return a Tuple, there will
 *  only be one halide_buffer_t in the list. The tuple_count parameters
 *  determines the length of the list.
 *
 * If there is a memory allocation failure, the store does not store
 * the data into the cache.
 *
 * If has_eviction_key is true, the entry is marked with eviction_key to
 * allow removing the key with halide_memoization_cache_evict.
 */</doc>
<dec f='halide/build/include/Halide.h' l='1010' type='int halide_memoization_cache_store(void * user_context, const uint8_t * cache_key, int32_t size, struct halide_buffer_t * realized_bounds, int32_t tuple_count, struct halide_buffer_t ** tuple_buffers, bool has_eviction_key, uint64_t eviction_key)'/>
<doc f='halide/build/include/Halide.h' l='993'>/** Given a cache key for a memoized result, currently constructed
 *  from the Func name and top-level Func name plus the arguments of
 *  the computation, store the result in the cache for futre access by
 *  halide_memoization_cache_lookup. (The internals of the cache key
 *  should be considered opaque by this function.) Data is copied out
 *  from the inputs and inputs are unmodified. The last argument is a
 *  list if halide_buffer_t pointers which represents the outputs of the
 *  memoized Func. If the Func does not return a Tuple, there will
 *  only be one halide_buffer_t in the list. The tuple_count parameters
 *  determines the length of the list.
 *
 * If there is a memory allocation failure, the store does not store
 * the data into the cache.
 *
 * If has_eviction_key is true, the entry is marked with eviction_key to
 * allow removing the key with halide_memoization_cache_evict.
 */</doc>
<dec f='halide/src/runtime/HalideRuntime.h' l='912' type='int halide_memoization_cache_store(void * user_context, const uint8_t * cache_key, int32_t size, struct halide_buffer_t * realized_bounds, int32_t tuple_count, struct halide_buffer_t ** tuple_buffers, bool has_eviction_key, uint64_t eviction_key)'/>
<doc f='halide/src/runtime/HalideRuntime.h' l='895'>/** Given a cache key for a memoized result, currently constructed
 *  from the Func name and top-level Func name plus the arguments of
 *  the computation, store the result in the cache for futre access by
 *  halide_memoization_cache_lookup. (The internals of the cache key
 *  should be considered opaque by this function.) Data is copied out
 *  from the inputs and inputs are unmodified. The last argument is a
 *  list if halide_buffer_t pointers which represents the outputs of the
 *  memoized Func. If the Func does not return a Tuple, there will
 *  only be one halide_buffer_t in the list. The tuple_count parameters
 *  determines the length of the list.
 *
 * If there is a memory allocation failure, the store does not store
 * the data into the cache.
 *
 * If has_eviction_key is true, the entry is marked with eviction_key to
 * allow removing the key with halide_memoization_cache_evict.
 */</doc>
<dec f='halide/build/tutorial/lesson_10_halide.h' l='984' type='int halide_memoization_cache_store(void * user_context, const uint8_t * cache_key, int32_t size, struct halide_buffer_t * realized_bounds, int32_t tuple_count, struct halide_buffer_t ** tuple_buffers, bool has_eviction_key, uint64_t eviction_key)'/>
<doc f='halide/build/tutorial/lesson_10_halide.h' l='967'>/** Given a cache key for a memoized result, currently constructed
 *  from the Func name and top-level Func name plus the arguments of
 *  the computation, store the result in the cache for futre access by
 *  halide_memoization_cache_lookup. (The internals of the cache key
 *  should be considered opaque by this function.) Data is copied out
 *  from the inputs and inputs are unmodified. The last argument is a
 *  list if halide_buffer_t pointers which represents the outputs of the
 *  memoized Func. If the Func does not return a Tuple, there will
 *  only be one halide_buffer_t in the list. The tuple_count parameters
 *  determines the length of the list.
 *
 * If there is a memory allocation failure, the store does not store
 * the data into the cache.
 *
 * If has_eviction_key is true, the entry is marked with eviction_key to
 * allow removing the key with halide_memoization_cache_evict.
 */</doc>
