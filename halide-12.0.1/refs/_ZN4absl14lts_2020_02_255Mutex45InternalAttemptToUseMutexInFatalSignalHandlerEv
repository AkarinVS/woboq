<dec f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='462' type='static void absl::lts_2020_02_25::Mutex::InternalAttemptToUseMutexInFatalSignalHandler()'/>
<doc f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='449'>// Mutex::InternalAttemptToUseMutexInFatalSignalHandler()
  //
  // Causes the `Mutex` implementation to prepare itself for re-entry caused by
  // future use of `Mutex` within a fatal signal handler. This method is
  // intended for use only for last-ditch attempts to log crash information.
  // It does not guarantee that attempts to use Mutexes within the handler will
  // not deadlock; it merely makes other faults less likely.
  //
  // WARNING:  This routine must be invoked from a signal handler, and the
  // signal handler must either loop forever or terminate the process.
  // Attempts to return from (or `longjmp` out of) the signal handler once this
  // call has been made may cause arbitrary program behaviour including
  // crashes and deadlocks.</doc>
<def f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.cc' l='579' ll='588' type='static void absl::lts_2020_02_25::Mutex::InternalAttemptToUseMutexInFatalSignalHandler()'/>
<doc f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.cc' l='573'>// We&apos;re in a fatal signal handler that hopes to use Mutex and to get
// lucky by not deadlocking.  We try to improve its chances of success
// by effectively disabling some of the consistency checks.  This will
// prevent certain ABSL_RAW_CHECK() statements from being triggered when
// re-rentry is detected.  The ABSL_RAW_CHECK() statements are those in the
// Mutex code checking that the &quot;waitp&quot; field has not been reused.</doc>
