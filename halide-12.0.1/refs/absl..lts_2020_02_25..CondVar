<use f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='504'/>
<def f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='771' ll='848'/>
<use f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='846' c='_ZN4absl14lts_2020_02_257CondVarC1ERKS1_'/>
<use f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='847' c='_ZN4absl14lts_2020_02_257CondVaraSERKS1_'/>
<use f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='847' c='_ZN4absl14lts_2020_02_257CondVaraSERKS1_'/>
<size>8</size>
<doc f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='736'>// -----------------------------------------------------------------------------
// CondVar
// -----------------------------------------------------------------------------
//
// A condition variable, reflecting state evaluated separately outside of the
// `Mutex` object, which can be signaled to wake callers.
// This class is not normally needed; use `Mutex` member functions such as
// `Mutex::Await()` and intrinsic `Condition` abstractions. In rare cases
// with many threads and many conditions, `CondVar` may be faster.
//
// The implementation may deliver signals to any condition variable at
// any time, even when no call to `Signal()` or `SignalAll()` is made; as a
// result, upon being awoken, you must check the logical condition you have
// been waiting upon.
//
// Examples:
//
// Usage for a thread waiting for some condition C protected by mutex mu:
//       mu.Lock();
//       while (!C) { cv-&gt;Wait(&amp;mu); }        // releases and reacquires mu
//       //  C holds; process data
//       mu.Unlock();
//
// Usage to wake T is:
//       mu.Lock();
//      // process data, possibly establishing C
//      if (C) { cv-&gt;Signal(); }
//      mu.Unlock();
//
// If C may be useful to more than one waiter, use `SignalAll()` instead of
// `Signal()`.
//
// With this implementation it is efficient to use `Signal()/SignalAll()` inside
// the locked region; this usage can make reasoning about your program easier.
//</doc>
<fun r='_ZN4absl14lts_2020_02_257CondVarC1Ev'/>
<fun r='_ZN4absl14lts_2020_02_257CondVarD1Ev'/>
<fun r='_ZN4absl14lts_2020_02_257CondVar4WaitEPNS0_5MutexE'/>
<fun r='_ZN4absl14lts_2020_02_257CondVar15WaitWithTimeoutEPNS0_5MutexENS0_8DurationE'/>
<fun r='_ZN4absl14lts_2020_02_257CondVar16WaitWithDeadlineEPNS0_5MutexENS0_4TimeE'/>
<fun r='_ZN4absl14lts_2020_02_257CondVar6SignalEv'/>
<fun r='_ZN4absl14lts_2020_02_257CondVar9SignalAllEv'/>
<fun r='_ZN4absl14lts_2020_02_257CondVar14EnableDebugLogEPKc'/>
<fun r='_ZN4absl14lts_2020_02_257CondVar10WaitCommonEPNS0_5MutexENS0_24synchronization_internal13KernelTimeoutE'/>
<fun r='_ZN4absl14lts_2020_02_257CondVar6RemoveEPNS0_13base_internal14PerThreadSynchE'/>
<fun r='_ZN4absl14lts_2020_02_257CondVar6WakeupEPNS0_13base_internal14PerThreadSynchE'/>
<mbr r='absl::lts_2020_02_25::CondVar::cv_' o='0' t='std::atomic&lt;intptr_t&gt;'/>
<fun r='_ZN4absl14lts_2020_02_257CondVarC1ERKS1_'/>
<fun r='_ZN4absl14lts_2020_02_257CondVaraSERKS1_'/>
<fun r='_ZN4absl14lts_2020_02_257CondVarC1Ev'/>
