<def f='halide/build-apps/abseil-cpp/absl/time/time.h' l='274' ll='277' type='int64_t absl::lts_2020_02_25::IDivDuration(absl::lts_2020_02_25::Duration num, absl::lts_2020_02_25::Duration den, absl::lts_2020_02_25::Duration * rem)'/>
<doc f='halide/build-apps/abseil-cpp/absl/time/time.h' l='246'>// IDivDuration()
//
// Divides a numerator `Duration` by a denominator `Duration`, returning the
// quotient and remainder. The remainder always has the same sign as the
// numerator. The returned quotient and remainder respect the identity:
//
//   numerator = denominator * quotient + remainder
//
// Returned quotients are capped to the range of `int64_t`, with the difference
// spilling into the remainder to uphold the above identity. This means that the
// remainder returned could differ from the remainder returned by
// `Duration::operator%` for huge quotients.
//
// See also the notes on `InfiniteDuration()` below regarding the behavior of
// division involving zero and infinite durations.
//
// Example:
//
//   constexpr absl::Duration a =
//       absl::Seconds(std::numeric_limits&lt;int64_t&gt;::max());  // big
//   constexpr absl::Duration b = absl::Nanoseconds(1);       // small
//
//   absl::Duration rem = a % b;
//   // rem == absl::ZeroDuration()
//
//   // Here, q would overflow int64_t, so rem accounts for the difference.
//   int64_t q = absl::IDivDuration(a, b, &amp;rem);
//   // q == std::numeric_limits&lt;int64_t&gt;::max(), rem == a - b * q</doc>
<use f='halide/build-apps/abseil-cpp/absl/time/duration.cc' l='788' u='c' c='_ZN4absl14lts_2020_02_2514FormatDurationB5cxx11ENS0_8DurationE'/>
<use f='halide/build-apps/abseil-cpp/absl/time/duration.cc' l='789' u='c' c='_ZN4absl14lts_2020_02_2514FormatDurationB5cxx11ENS0_8DurationE'/>
<use f='halide/build-apps/abseil-cpp/absl/time/time.cc' l='62' u='c' c='_ZN4absl14lts_2020_02_2512_GLOBAL__N_111FloorToUnitENS0_8DurationES2_'/>
