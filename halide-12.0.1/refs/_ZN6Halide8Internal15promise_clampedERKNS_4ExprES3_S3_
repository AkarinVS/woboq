<dec f='halide/build/include/Halide.h' l='8274' type='Halide::Expr Halide::Internal::promise_clamped(const Halide::Expr &amp; value, const Halide::Expr &amp; min, const Halide::Expr &amp; max)'/>
<doc f='halide/build/include/Halide.h' l='8259'>/**
 * FOR INTERNAL USE ONLY.
 *
 * An entirely unchecked version of unsafe_promise_clamped, used
 * inside the compiler as an annotation of the known bounds of an Expr
 * when it has proved something is bounded and wants to record that
 * fact for later passes (notably bounds inference) to exploit. This
 * gets introduced by GuardWithIf tail strategies, because the bounds
 * machinery has a hard time exploiting if statement conditions.
 *
 * Unlike unsafe_promise_clamped, this expression is
 * context-dependent, because &apos;value&apos; might be statically bounded at
 * some point in the IR (e.g. due to a containing if statement), but
 * not elsewhere.
 **/</doc>
<dec f='halide/src/IROperator.h' l='1469' type='Halide::Expr Halide::Internal::promise_clamped(const Halide::Expr &amp; value, const Halide::Expr &amp; min, const Halide::Expr &amp; max)'/>
<doc f='halide/src/IROperator.h' l='1454'>/**
 * FOR INTERNAL USE ONLY.
 *
 * An entirely unchecked version of unsafe_promise_clamped, used
 * inside the compiler as an annotation of the known bounds of an Expr
 * when it has proved something is bounded and wants to record that
 * fact for later passes (notably bounds inference) to exploit. This
 * gets introduced by GuardWithIf tail strategies, because the bounds
 * machinery has a hard time exploiting if statement conditions.
 *
 * Unlike unsafe_promise_clamped, this expression is
 * context-dependent, because &apos;value&apos; might be statically bounded at
 * some point in the IR (e.g. due to a containing if statement), but
 * not elsewhere.
 **/</doc>
<use f='halide/src/ApplySplit.cpp' l='65' u='c' c='_ZN6Halide8Internal11apply_splitERKNS0_5SplitEbRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERSt3mapIS9_NS_4ExprESt4lessIS9_ESaISt4pairISA_SD_EEE'/>
<def f='halide/src/IROperator.cpp' l='1522' ll='1532' type='Halide::Expr Halide::Internal::promise_clamped(const Halide::Expr &amp; value, const Halide::Expr &amp; min, const Halide::Expr &amp; max)'/>
