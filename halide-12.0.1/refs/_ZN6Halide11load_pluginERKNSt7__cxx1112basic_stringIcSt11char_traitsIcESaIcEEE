<dec f='halide/build/include/Halide.h' l='2812' type='void Halide::load_plugin(const std::string &amp; lib_name)'/>
<doc f='halide/build/include/Halide.h' l='2802'>/** Load a plugin in the form of a dynamic library (e.g. for custom autoschedulers).
 * If the string doesn&apos;t contain any . characters, the proper prefix and/or suffix
 * for the platform will be added:
 *
 *   foo -&gt; libfoo.so (Linux/OSX/etc -- note that .dylib is not supported)
 *   foo -&gt; foo.dll (Windows)
 *
 * otherwise, it is assumed to be an appropriate pathname.
 *
 * Any error in loading will assert-fail. */</doc>
<use f='halide/python_bindings/src/PyHalide.cpp' l='68' u='a' c='_ZL20pybind11_init_halideRN8pybind117module_E'/>
<dec f='halide/src/Util.h' l='60' type='void Halide::load_plugin(const std::string &amp; lib_name)'/>
<doc f='halide/src/Util.h' l='50'>/** Load a plugin in the form of a dynamic library (e.g. for custom autoschedulers).
 * If the string doesn&apos;t contain any . characters, the proper prefix and/or suffix
 * for the platform will be added:
 *
 *   foo -&gt; libfoo.so (Linux/OSX/etc -- note that .dylib is not supported)
 *   foo -&gt; foo.dll (Windows)
 *
 * otherwise, it is assumed to be an appropriate pathname.
 *
 * Any error in loading will assert-fail. */</doc>
<use f='halide/src/Generator.cpp' l='823' u='c' c='_ZN6Halide8Internal26generate_filter_main_innerEiPPcRSo'/>
<def f='halide/src/Util.cpp' l='659' ll='694' type='void Halide::load_plugin(const std::string &amp; lib_name)'/>
<use f='halide/src/autoschedulers/adams2019/test.cpp' l='62' u='c' c='main'/>
<use f='halide/src/autoschedulers/li2018/test.cpp' l='11' u='c' c='main'/>
