<def f='halide/llvm-install/include/llvm/Support/InstructionCost.h' l='79' ll='83' type='llvm::InstructionCost &amp; llvm::InstructionCost::operator+=(const llvm::InstructionCost &amp; RHS)'/>
<use f='halide/llvm-install/include/llvm/Support/InstructionCost.h' l='87' u='c' c='_ZN4llvm15InstructionCostpLEi'/>
<use f='halide/llvm-install/include/llvm/Support/InstructionCost.h' l='206' u='c' c='_ZN4llvmplERKNS_15InstructionCostES2_'/>
<doc f='halide/llvm-install/include/llvm/Support/InstructionCost.h' l='73'>/// For all of the arithmetic operators provided here any invalid state is
  /// perpetuated and cannot be removed. Once a cost becomes invalid it stays
  /// invalid, and it also inherits any invalid state from the RHS. Regardless
  /// of the state, arithmetic and comparisons work on the actual values in the
  /// same way as they would on a basic type, such as integer.</doc>
