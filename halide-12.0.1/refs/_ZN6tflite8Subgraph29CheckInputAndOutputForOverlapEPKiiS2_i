<dec f='halide/build-apps/_deps/tflite-src/tensorflow/lite/core/subgraph.h' l='463' type='TfLiteStatus tflite::Subgraph::CheckInputAndOutputForOverlap(const int * input_indices, int num_inputs, const int * output_indices, int num_outputs)'/>
<doc f='halide/build-apps/_deps/tflite-src/tensorflow/lite/core/subgraph.h' l='459'>// Check that the input indices and the output indices don&apos;t overlap.
  // This is needed because same tensor must not be used both as input and
  // output for an operator.
  // NOTE: this changes consistent_ to be false if indices are out of bounds.</doc>
<def f='halide/build-apps/_deps/tflite-src/tensorflow/lite/core/subgraph.cc' l='635' ll='650' type='TfLiteStatus tflite::Subgraph::CheckInputAndOutputForOverlap(const int * input_indices, int num_inputs, const int * output_indices, int num_outputs)'/>
<use f='halide/build-apps/_deps/tflite-src/tensorflow/lite/core/subgraph.cc' l='790' u='c' c='_ZN6tflite8Subgraph21AddNodeWithParametersERKSt6vectorIiSaIiEES5_S5_PKcmPvPK18TfLiteRegistrationPi'/>
<doc f='halide/build-apps/_deps/tflite-src/tensorflow/lite/core/subgraph.cc' l='625'>// We have two arrays and we need to check that elements from one array don&apos;t
// show up in the other. We could sort both arrays and then iterate with two
// pointers from start to finish always increasing the smaller one but since
// these arrays are usually short (&lt;25 elements for inputs, usually &lt;3 for
// outputs), this might be slower than the naive approach (if arrays have size n
// and m, with n &gt;&gt; m ~ O(1), first approach is O(nlogn) whereas the other is
// O(n)). Plus, sorting the input and output arrays might not be something we
// want as it destroys ordering of elements.
//
// If it turns out that this is an issue, we can switch to the other algorithm.</doc>
