<dec f='halide/build/include/Halide.h' l='17395' type='Halide::Func &amp; Halide::Func::vectorize(const Halide::VarOrRVar &amp; var, const Halide::Expr &amp; factor, Halide::TailStrategy tail = TailStrategy::Auto)'/>
<doc f='halide/build/include/Halide.h' l='17390'>/** Split a dimension by the given factor, then vectorize the
     * inner dimension. This is how you vectorize a loop of unknown
     * size. The variable to be vectorized should be the innermost
     * one. After this call, var refers to the outer dimension of the
     * split. &apos;factor&apos; must be an integer. */</doc>
<dec f='halide/src/Func.h' l='1515' type='Halide::Func &amp; Halide::Func::vectorize(const Halide::VarOrRVar &amp; var, const Halide::Expr &amp; factor, Halide::TailStrategy tail = TailStrategy::Auto)'/>
<doc f='halide/src/Func.h' l='1510'>/** Split a dimension by the given factor, then vectorize the
     * inner dimension. This is how you vectorize a loop of unknown
     * size. The variable to be vectorized should be the innermost
     * one. After this call, var refers to the outer dimension of the
     * split. &apos;factor&apos; must be an integer. */</doc>
<def f='halide/src/Func.cpp' l='2210' ll='2214' type='Halide::Func &amp; Halide::Func::vectorize(const Halide::VarOrRVar &amp; var, const Halide::Expr &amp; factor, Halide::TailStrategy tail = TailStrategy::Auto)'/>
<use f='halide/src/autoschedulers/adams2019/cost_model_generator.cpp' l='523' u='c' c='_ZN9CostModel8generateEv'/>
<use f='halide/src/autoschedulers/adams2019/cost_model_generator.cpp' l='549' u='c' c='_ZN9CostModel8generateEv'/>
<use f='halide/test/generator/example_generator.cpp' l='94' u='c' c='_ZN12_GLOBAL__N_17Example8scheduleEv'/>
<use f='halide/test/generator/mandelbrot_generator.cpp' l='85' u='c' c='_ZN12_GLOBAL__N_110Mandelbrot8generateEv'/>
<use f='halide/test/generator/memory_profiler_mandelbrot_generator.cpp' l='88' u='c' c='_ZN12_GLOBAL__N_110Mandelbrot8generateEv'/>
<use f='halide/test/generator/msan_generator.cpp' l='29' u='c' c='_ZN12_GLOBAL__N_14MSAN8scheduleEv'/>
<use f='halide/tutorial/lesson_08_scheduling_2.cpp' l='572' u='c' c='main'/>
<use f='halide/tutorial/lesson_08_scheduling_2.cpp' l='582' u='c' c='main'/>
<use f='halide/tutorial/lesson_09_update_definitions.cpp' l='252' u='c' c='main'/>
<use f='halide/tutorial/lesson_09_update_definitions.cpp' l='780' u='c' c='main'/>
<use f='halide/tutorial/lesson_10_aot_compilation_generate.cpp' l='65' u='c' c='main'/>
<use f='halide/tutorial/lesson_11_cross_compilation.cpp' l='41' u='c' c='main'/>
<use f='halide/tutorial/lesson_12_using_the_gpu.cpp' l='95' u='c' c='_ZN10MyPipeline16schedule_for_cpuEv'/>
<use f='halide/tutorial/lesson_12_using_the_gpu.cpp' l='105' u='c' c='_ZN10MyPipeline16schedule_for_cpuEv'/>
<use f='halide/tutorial/lesson_15_generators.cpp' l='158' u='c' c='_ZN17MySecondGenerator8generateEv'/>
<use f='halide/tutorial/lesson_18_parallel_associative_reductions.cpp' l='48' u='c' c='main'/>
<use f='halide/tutorial/lesson_18_parallel_associative_reductions.cpp' l='92' u='c' c='main'/>
<use f='halide/tutorial/lesson_18_parallel_associative_reductions.cpp' l='93' u='c' c='main'/>
<use f='halide/tutorial/lesson_18_parallel_associative_reductions.cpp' l='148' u='c' c='main'/>
<use f='halide/tutorial/lesson_18_parallel_associative_reductions.cpp' l='149' u='c' c='main'/>
<use f='halide/tutorial/lesson_18_parallel_associative_reductions.cpp' l='223' u='c' c='main'/>
<use f='halide/tutorial/lesson_18_parallel_associative_reductions.cpp' l='224' u='c' c='main'/>
<use f='halide/tutorial/lesson_18_parallel_associative_reductions.cpp' l='294' u='c' c='main'/>
<use f='halide/tutorial/lesson_18_parallel_associative_reductions.cpp' l='295' u='c' c='main'/>
<use f='halide/tutorial/lesson_19_wrapper_funcs.cpp' l='202' u='c' c='main'/>
<use f='halide/tutorial/lesson_19_wrapper_funcs.cpp' l='403' u='c' c='main'/>
<use f='halide/tutorial/lesson_19_wrapper_funcs.cpp' l='404' u='c' c='main'/>
