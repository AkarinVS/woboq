<dec f='halide/build/include/HalideRuntime.h' l='964' type='int halide_msan_check_buffer_is_initialized(void * user_context, struct halide_buffer_t * buffer, const char * buf_name)'/>
<doc f='halide/build/include/HalideRuntime.h' l='953'>/** Verify that the data pointed to by the halide_buffer_t is initialized (but *not* the halide_buffer_t itself),
 * using halide_msan_check_memory_is_initialized() for checking.
 *
 * The default implementation takes pains to only check the active memory ranges
 * (skipping padding), and sorting into ranges to always check the smallest number of
 * ranges, in monotonically increasing memory order.
 *
 * Most client code should never need to replace the default implementation.
 *
 * The return value should always be zero.
 */</doc>
<dec f='halide/build/include/Halide.h' l='1062' type='int halide_msan_check_buffer_is_initialized(void * user_context, struct halide_buffer_t * buffer, const char * buf_name)'/>
<doc f='halide/build/include/Halide.h' l='1051'>/** Verify that the data pointed to by the halide_buffer_t is initialized (but *not* the halide_buffer_t itself),
 * using halide_msan_check_memory_is_initialized() for checking.
 *
 * The default implementation takes pains to only check the active memory ranges
 * (skipping padding), and sorting into ranges to always check the smallest number of
 * ranges, in monotonically increasing memory order.
 *
 * Most client code should never need to replace the default implementation.
 *
 * The return value should always be zero.
 */</doc>
<dec f='halide/src/runtime/HalideRuntime.h' l='964' type='int halide_msan_check_buffer_is_initialized(void * user_context, struct halide_buffer_t * buffer, const char * buf_name)'/>
<doc f='halide/src/runtime/HalideRuntime.h' l='953'>/** Verify that the data pointed to by the halide_buffer_t is initialized (but *not* the halide_buffer_t itself),
 * using halide_msan_check_memory_is_initialized() for checking.
 *
 * The default implementation takes pains to only check the active memory ranges
 * (skipping padding), and sorting into ranges to always check the smallest number of
 * ranges, in monotonically increasing memory order.
 *
 * Most client code should never need to replace the default implementation.
 *
 * The return value should always be zero.
 */</doc>
<dec f='halide/build/tutorial/lesson_10_halide.h' l='1036' type='int halide_msan_check_buffer_is_initialized(void * user_context, struct halide_buffer_t * buffer, const char * buf_name)'/>
<doc f='halide/build/tutorial/lesson_10_halide.h' l='1025'>/** Verify that the data pointed to by the halide_buffer_t is initialized (but *not* the halide_buffer_t itself),
 * using halide_msan_check_memory_is_initialized() for checking.
 *
 * The default implementation takes pains to only check the active memory ranges
 * (skipping padding), and sorting into ranges to always check the smallest number of
 * ranges, in monotonically increasing memory order.
 *
 * Most client code should never need to replace the default implementation.
 *
 * The return value should always be zero.
 */</doc>
