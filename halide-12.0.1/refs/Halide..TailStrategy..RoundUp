<dec f='halide/halide-install/include/Halide.h' l='5756' type='0'/>
<use f='halide/apps/bgu/bgu_generator.cpp' l='643' u='r' c='_ZN12_GLOBAL__N_13BGU8generateEv'/>
<use f='halide/apps/bgu/bgu_generator.cpp' l='647' u='r' c='_ZN12_GLOBAL__N_13BGU8generateEv'/>
<use f='halide/apps/bgu/bgu_generator.cpp' l='651' u='r' c='_ZN12_GLOBAL__N_13BGU8generateEv'/>
<use f='halide/apps/bgu/bgu_generator.cpp' l='658' u='r' c='_ZN12_GLOBAL__N_13BGU8generateEv'/>
<use f='halide/apps/bgu/bgu_generator.cpp' l='671' u='r' c='_ZN12_GLOBAL__N_13BGU8generateEv'/>
<use f='halide/apps/bgu/bgu_generator.cpp' l='681' u='r' c='_ZN12_GLOBAL__N_13BGU8generateEv'/>
<doc f='halide/halide-install/include/Halide.h' l='5750'>/** Round up the extent to be a multiple of the split
     * factor. Not legal for RVars, as it would change the meaning
     * of the algorithm. Pros: generates the simplest, fastest
     * code. Cons: if used on a stage that reads from the input or
     * writes to the output, constrains the input or output size
     * to be a multiple of the split factor. */</doc>
<use f='halide/apps/bilateral_grid/bilateral_grid_generator.cpp' l='111' u='r' c='_ZN12_GLOBAL__N_113BilateralGrid8generateEv'/>
<use f='halide/apps/bilateral_grid/bilateral_grid_generator.cpp' l='112' u='r' c='_ZN12_GLOBAL__N_113BilateralGrid8generateEv'/>
<use f='halide/apps/bilateral_grid/bilateral_grid_generator.cpp' l='118' u='r' c='_ZN12_GLOBAL__N_113BilateralGrid8generateEv'/>
<use f='halide/apps/bilateral_grid/bilateral_grid_generator.cpp' l='119' u='r' c='_ZN12_GLOBAL__N_113BilateralGrid8generateEv'/>
<use f='halide/apps/camera_pipe/camera_pipe_generator.cpp' l='173' u='r' c='_ZN12_GLOBAL__N_18Demosaic8scheduleEv'/>
<use f='halide/apps/camera_pipe/camera_pipe_generator.cpp' l='523' u='r' c='_ZN12_GLOBAL__N_110CameraPipe8generateEv'/>
<use f='halide/apps/camera_pipe/camera_pipe_generator.cpp' l='525' u='r' c='_ZN12_GLOBAL__N_110CameraPipe8generateEv'/>
<use f='halide/apps/camera_pipe/camera_pipe_generator.cpp' l='543' u='r' c='_ZN12_GLOBAL__N_110CameraPipe8generateEv'/>
<use f='halide/apps/camera_pipe/camera_pipe_generator.cpp' l='550' u='r' c='_ZN12_GLOBAL__N_110CameraPipe8generateEv'/>
<use f='halide/apps/depthwise_separable_conv/depthwise_separable_conv_generator.cpp' l='161' u='r' c='_ZN12_GLOBAL__N_129DepthwiseSeparableConvolution8generateEv'/>
<use f='halide/apps/depthwise_separable_conv/depthwise_separable_conv_generator.cpp' l='274' u='r' c='_ZN12_GLOBAL__N_129DepthwiseSeparableConvolution8generateEv'/>
<use f='halide/apps/hannk/halide/conv_generator.cpp' l='207' u='r' c='_ZN5hannk4Conv8generateEv'/>
<use f='halide/apps/hannk/halide/conv_generator.cpp' l='227' u='r' c='_ZN5hannk4Conv8generateEv'/>
<use f='halide/apps/hannk/halide/conv_generator.cpp' l='240' u='r' c='_ZN5hannk4Conv8generateEv'/>
<use f='halide/apps/hannk/halide/conv_generator.cpp' l='257' u='r' c='_ZN5hannk4Conv8generateEv'/>
<use f='halide/apps/hannk/halide/conv_generator.cpp' l='281' u='r' c='_ZN5hannk4Conv8generateEv'/>
<use f='halide/apps/hannk/halide/conv_generator.cpp' l='285' u='r' c='_ZN5hannk4Conv8generateEv'/>
<use f='halide/apps/hannk/halide/conv_generator.cpp' l='292' u='r' c='_ZN5hannk4Conv8generateEv'/>
<use f='halide/apps/hannk/halide/depthwise_conv_generator.cpp' l='158' u='a' c='_ZN5hannk13DepthwiseConv8generateEv'/>
<use f='halide/apps/interpolate/interpolate_generator.cpp' l='86' u='r' c='_ZN12_GLOBAL__N_111Interpolate8generateEv'/>
<use f='halide/apps/interpolate/interpolate_generator.cpp' l='106' u='r' c='_ZN12_GLOBAL__N_111Interpolate8generateEv'/>
<use f='halide/apps/max_filter/max_filter_generator.cpp' l='82' u='r' c='_ZN12_GLOBAL__N_13Max8generateEv'/>
<use f='halide/apps/max_filter/max_filter_generator.cpp' l='84' u='r' c='_ZN12_GLOBAL__N_13Max8generateEv'/>
<dec f='halide/build/include/Halide.h' l='5756' type='0'/>
<doc f='halide/build/include/Halide.h' l='5750'>/** Round up the extent to be a multiple of the split
     * factor. Not legal for RVars, as it would change the meaning
     * of the algorithm. Pros: generates the simplest, fastest
     * code. Cons: if used on a stage that reads from the input or
     * writes to the output, constrains the input or output size
     * to be a multiple of the split factor. */</doc>
<use f='halide/python_bindings/src/PyEnums.cpp' l='58' u='r' c='_ZN6Halide14PythonBindings12define_enumsERN8pybind117module_E'/>
<dec f='halide/src/Schedule.h' l='39' type='0'/>
<doc f='halide/src/Schedule.h' l='33'>/** Round up the extent to be a multiple of the split
     * factor. Not legal for RVars, as it would change the meaning
     * of the algorithm. Pros: generates the simplest, fastest
     * code. Cons: if used on a stage that reads from the input or
     * writes to the output, constrains the input or output size
     * to be a multiple of the split factor. */</doc>
<use f='halide/src/ApplySplit.cpp' l='90' u='r' c='_ZN6Halide8Internal11apply_splitERKNS0_5SplitEbRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERSt3mapIS9_NS_4ExprESt4lessIS9_ESaISt4pairISA_SD_EEE'/>
<use f='halide/src/Func.cpp' l='1040' u='r' c='_ZN6Halide5Stage5splitERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_S8_RKNS_4ExprEbNS_12TailStrategyE'/>
<use f='halide/src/Func.cpp' l='1053' u='r' c='_ZN6Halide5Stage5splitERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_S8_RKNS_4ExprEbNS_12TailStrategyE'/>
<use f='halide/src/Func.cpp' l='1094' u='r' c='_ZN6Halide5Stage5splitERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_S8_RKNS_4ExprEbNS_12TailStrategyE'/>
<use f='halide/src/Func.cpp' l='1193' u='r' c='_ZN6Halide5Stage4fuseERKNS_9VarOrRVarES3_S3_'/>
<use f='halide/src/Func.cpp' l='1287' u='r' c='_ZN6Halide5Stage6purifyERKNS_9VarOrRVarES3_'/>
<use f='halide/src/Func.cpp' l='1469' u='r' c='_ZN6Halide5Stage6renameERKNS_9VarOrRVarES3_'/>
<use f='halide/src/IRPrinter.cpp' l='156' c='_ZN6HalidelsERSoRKNS_12TailStrategyE'/>
<use f='halide/src/autoschedulers/adams2019/LoopNest.cpp' l='1762' u='r' c='_ZNK6Halide8Internal13Autoscheduler8LoopNest5applyENS_9LoopLevelER14PerfectHashMapINS1_11FunctionDAG4Node5StageESt10unique_ptrINS2_18StageScheduleStat9334574'/>
<use f='halide/src/autoschedulers/adams2019/cost_model_generator.cpp' l='507' u='r' c='_ZN9CostModel8generateEv'/>
<use f='halide/src/autoschedulers/adams2019/cost_model_generator.cpp' l='514' u='r' c='_ZN9CostModel8generateEv'/>
<use f='halide/src/autoschedulers/mullapudi2016/AutoSchedule.cpp' l='2365' c='_ZN6Halide8Internal12_GLOBAL__N_111Partitioner9split_dimERKNS2_5GroupENS_5StageEiRKNS0_10DefinitionEbRKNS_9VarOrRVarERKNS_4ExprERKNSt7__cxx1112basic_s15602673'/>
