<def f='halide/build/include/Halide.h' l='23250' ll='23260'/>
<use f='halide/build/include/Halide.h' l='25866'/>
<use f='halide/build/include/Halide.h' l='25874' c='_ZNK6Halide16GeneratorContext17get_value_trackerEv'/>
<size>56</size>
<doc f='halide/build/include/Halide.h' l='23224'>/**
 * ValueTracker is an internal utility class that attempts to track and flag certain
 * obvious Stub-related errors at Halide compile time: it tracks the constraints set
 * on any Parameter-based argument (i.e., Input&lt;Buffer&gt; and Output&lt;Buffer&gt;) to
 * ensure that incompatible values aren&apos;t set.
 *
 * e.g.: if a Generator A requires stride[0] == 1,
 * and Generator B uses Generator A via stub, but requires stride[0] == 4,
 * we should be able to detect this at Halide compilation time, and fail immediately,
 * rather than producing code that fails at runtime and/or runs slowly due to
 * vectorization being unavailable.
 *
 * We do this by tracking the active values at entrance and exit to all user-provided
 * Generator methods (build()/generate()/schedule()); if we ever find more than two unique
 * values active, we know we have a potential conflict. (&quot;two&quot; here because the first
 * value is the default value for a given constraint.)
 *
 * Note that this won&apos;t catch all cases:
 * -- JIT compilation has no way to check for conflicts at the top-level
 * -- constraints that match the default value (e.g. if dim(0).set_stride(1) is the
 * first value seen by the tracker) will be ignored, so an explicit requirement set
 * this way can be missed
 *
 * Nevertheless, this is likely to be much better than nothing when composing multiple
 * layers of Stubs in a single fused result.
 */</doc>
<mbr r='Halide::Internal::ValueTracker::values_history' o='0' t='std::map&lt;std::string, std::vector&lt;std::vector&lt;Expr&gt; &gt; &gt;'/>
<mbr r='Halide::Internal::ValueTracker::max_unique_values' o='384' t='const size_t'/>
<fun r='_ZN6Halide8Internal12ValueTrackerC1Em'/>
<fun r='_ZN6Halide8Internal12ValueTracker12track_valuesERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorINS_4ExprESaISB_EE'/>
<def f='halide/src/Generator.h' l='316' ll='326'/>
<use f='halide/src/Generator.h' l='2932'/>
<use f='halide/src/Generator.h' l='2940' c='_ZNK6Halide16GeneratorContext17get_value_trackerEv'/>
<use f='halide/src/Generator.cpp' l='22' c='_ZN6Halide16GeneratorContextC1ERKNS_6TargetEbRKNS_13MachineParamsE'/>
<size>56</size>
<doc f='halide/src/Generator.h' l='290'>/**
 * ValueTracker is an internal utility class that attempts to track and flag certain
 * obvious Stub-related errors at Halide compile time: it tracks the constraints set
 * on any Parameter-based argument (i.e., Input&lt;Buffer&gt; and Output&lt;Buffer&gt;) to
 * ensure that incompatible values aren&apos;t set.
 *
 * e.g.: if a Generator A requires stride[0] == 1,
 * and Generator B uses Generator A via stub, but requires stride[0] == 4,
 * we should be able to detect this at Halide compilation time, and fail immediately,
 * rather than producing code that fails at runtime and/or runs slowly due to
 * vectorization being unavailable.
 *
 * We do this by tracking the active values at entrance and exit to all user-provided
 * Generator methods (build()/generate()/schedule()); if we ever find more than two unique
 * values active, we know we have a potential conflict. (&quot;two&quot; here because the first
 * value is the default value for a given constraint.)
 *
 * Note that this won&apos;t catch all cases:
 * -- JIT compilation has no way to check for conflicts at the top-level
 * -- constraints that match the default value (e.g. if dim(0).set_stride(1) is the
 * first value seen by the tracker) will be ignored, so an explicit requirement set
 * this way can be missed
 *
 * Nevertheless, this is likely to be much better than nothing when composing multiple
 * layers of Stubs in a single fused result.
 */</doc>
<mbr r='Halide::Internal::ValueTracker::values_history' o='0' t='std::map&lt;std::string, std::vector&lt;std::vector&lt;Expr&gt; &gt; &gt;'/>
<mbr r='Halide::Internal::ValueTracker::max_unique_values' o='384' t='const size_t'/>
<fun r='_ZN6Halide8Internal12ValueTrackerC1Em'/>
<fun r='_ZN6Halide8Internal12ValueTracker12track_valuesERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorINS_4ExprESaISB_EE'/>
<fun r='_ZN6Halide8Internal12ValueTracker12track_valuesERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorINS_4ExprESaISB_EE'/>
