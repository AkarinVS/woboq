<def f='halide/build-apps/eigen/Eigen/src/Core/NumTraits.h' l='122' ll='189'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/NumTraits.h' l='191'/>
<ovr f='halide/build-apps/eigen/Eigen/src/Core/NumTraits.h' l='194' c='Eigen::NumTraits'/>
<ovr f='halide/build-apps/eigen/Eigen/src/Core/NumTraits.h' l='201' c='Eigen::NumTraits'/>
<ovr f='halide/build-apps/eigen/Eigen/src/Core/NumTraits.h' l='207' c='Eigen::NumTraits'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/NumTraits.h' l='214'/>
<ovr f='halide/build-apps/eigen/Eigen/src/Core/NumTraits.h' l='263' c='Eigen::NumTraits'/>
<ovr f='halide/build-apps/eigen/Eigen/src/Core/NumTraits.h' l='287' c='Eigen::NumTraits'/>
<ovr f='halide/build-apps/eigen/Eigen/src/Core/arch/Default/Half.h' l='657' c='Eigen::NumTraits'/>
<ovr f='halide/build-apps/eigen/Eigen/src/Core/arch/Default/BFloat16.h' l='612' c='Eigen::NumTraits'/>
<doc f='halide/build-apps/eigen/Eigen/src/Core/NumTraits.h' l='80'>/** \class NumTraits
  * \ingroup Core_Module
  *
  * \brief Holds information about the various numeric (i.e. scalar) types allowed by Eigen.
  *
  * \tparam T the numeric type at hand
  *
  * This class stores enums, typedefs and static methods giving information about a numeric type.
  *
  * The provided data consists of:
  * \li A typedef \c Real, giving the &quot;real part&quot; type of \a T. If \a T is already real,
  *     then \c Real is just a typedef to \a T. If \a T is \c std::complex&lt;U&gt; then \c Real
  *     is a typedef to \a U.
  * \li A typedef \c NonInteger, giving the type that should be used for operations producing non-integral values,
  *     such as quotients, square roots, etc. If \a T is a floating-point type, then this typedef just gives
  *     \a T again. Note however that many Eigen functions such as internal::sqrt simply refuse to
  *     take integers. Outside of a few cases, Eigen doesn&apos;t do automatic type promotion. Thus, this typedef is
  *     only intended as a helper for code that needs to explicitly promote types.
  * \li A typedef \c Literal giving the type to use for numeric literals such as &quot;2&quot; or &quot;0.5&quot;. For instance, for \c std::complex&lt;U&gt;, Literal is defined as \c U.
  *     Of course, this type must be fully compatible with \a T. In doubt, just use \a T here.
  * \li A typedef \a Nested giving the type to use to nest a value inside of the expression tree. If you don&apos;t know what
  *     this means, just use \a T here.
  * \li An enum value \a IsComplex. It is equal to 1 if \a T is a \c std::complex
  *     type, and to 0 otherwise.
  * \li An enum value \a IsInteger. It is equal to \c 1 if \a T is an integer type such as \c int,
  *     and to \c 0 otherwise.
  * \li Enum values ReadCost, AddCost and MulCost representing a rough estimate of the number of CPU cycles needed
  *     to by move / add / mul instructions respectively, assuming the data is already stored in CPU registers.
  *     Stay vague here. No need to do architecture-specific stuff. If you don&apos;t know what this means, just use \c Eigen::HugeCost.
  * \li An enum value \a IsSigned. It is equal to \c 1 if \a T is a signed type and to 0 if \a T is unsigned.
  * \li An enum value \a RequireInitialization. It is equal to \c 1 if the constructor of the numeric type \a T must
  *     be called, and to 0 if it is safe not to call it. Default is 0 if \a T is an arithmetic type, and 1 otherwise.
  * \li An epsilon() function which, unlike &lt;a href=&quot;http://en.cppreference.com/w/cpp/types/numeric_limits/epsilon&quot;&gt;std::numeric_limits::epsilon()&lt;/a&gt;,
  *     it returns a \a Real instead of a \a T.
  * \li A dummy_precision() function returning a weak epsilon value. It is mainly used as a default
  *     value by the fuzzy comparison operators.
  * \li highest() and lowest() functions returning the highest and lowest possible values respectively.
  * \li digits10() function returning the number of decimal digits that can be represented without change. This is
  *     the analogue of &lt;a href=&quot;http://en.cppreference.com/w/cpp/types/numeric_limits/digits10&quot;&gt;std::numeric_limits&lt;T&gt;::digits10&lt;/a&gt;
  *     which is used as the default implementation if specialized.
  */</doc>
<fun r='_ZN5Eigen16GenericNumTraits7epsilonEv'/>
<fun r='_ZN5Eigen16GenericNumTraits8digits10Ev'/>
<fun r='_ZN5Eigen16GenericNumTraits6digitsEv'/>
<fun r='_ZN5Eigen16GenericNumTraits15dummy_precisionEv'/>
<fun r='_ZN5Eigen16GenericNumTraits7highestEv'/>
<fun r='_ZN5Eigen16GenericNumTraits6lowestEv'/>
<fun r='_ZN5Eigen16GenericNumTraits8infinityEv'/>
<fun r='_ZN5Eigen16GenericNumTraits9quiet_NaNEv'/>
<use f='halide/build-apps/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorCostModel.h' l='179' c='_ZN5Eigen15TensorCostModel10numThreadsEdRKNS_12TensorOpCostEi'/>
