<dec f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='487' type='bool absl::lts_2020_02_25::Mutex::LockSlowWithDeadline(absl::lts_2020_02_25::Mutex::MuHow how, const absl::lts_2020_02_25::Condition * cond, synchronization_internal::KernelTimeout t, int flags)'/>
<doc f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='486'>// wrappers around LockSlowLoop()</doc>
<use f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.cc' l='1506' u='c' c='_ZN4absl14lts_2020_02_255Mutex20LockWhenWithDeadlineERKNS0_9ConditionENS0_4TimeE'/>
<use f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.cc' l='1530' u='c' c='_ZN4absl14lts_2020_02_255Mutex26ReaderLockWhenWithDeadlineERKNS0_9ConditionENS0_4TimeE'/>
<use f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.cc' l='1756' u='c' c='_ZN4absl14lts_2020_02_255Mutex8LockSlowEPKNS0_6MuHowSEPKNS0_9ConditionEi'/>
<def f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.cc' l='1836' ll='1866' type='bool absl::lts_2020_02_25::Mutex::LockSlowWithDeadline(absl::lts_2020_02_25::Mutex::MuHow how, const absl::lts_2020_02_25::Condition * cond, absl::lts_2020_02_25::synchronization_internal::KernelTimeout t, int flags)'/>
<doc f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.cc' l='1827'>// Internal equivalent of *LockWhenWithDeadline(), where
//   &quot;t&quot; represents the absolute timeout; !t.has_timeout() means &quot;forever&quot;.
//   &quot;how&quot; is &quot;kShared&quot; (for ReaderLockWhen) or &quot;kExclusive&quot; (for LockWhen)
// In flags, bits are ored together:
// - kMuHasBlocked indicates that the client has already blocked on the call so
//   the designated waker bit must be cleared and waiting writers should not
//   obstruct this call
// - kMuIsCond indicates that this is a conditional acquire (condition variable,
//   Await,  LockWhen) so contention profiling should be suppressed.</doc>
