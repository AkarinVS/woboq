<dec f='halide/build/include/Halide.h' l='15175' type='void Halide::Pipeline::realize(Halide::Pipeline::RealizationArg output, const Halide::Target &amp; target = Halide::Target(), const Halide::ParamMap &amp; param_map = ParamMap::empty_map())'/>
<use f='halide/build/include/Halide.h' l='26085' u='c' c='_ZN6Halide8Internal13GeneratorBase7realizeENS_11RealizationE'/>
<doc f='halide/build/include/Halide.h' l='15166'>/** Evaluate this Pipeline into an existing allocated buffer or
     * buffers. If the buffer is also one of the arguments to the
     * function, strange things may happen, as the pipeline isn&apos;t
     * necessarily safe to run in-place. The realization should
     * contain one Buffer per tuple component per output Func. For
     * each individual output Func, all Buffers must have the same
     * shape, but the shape can vary across the different output
     * Funcs. This form of realize does *not* automatically copy data
     * back from the GPU. */</doc>
<use f='halide/python_bindings/src/PyPipeline.cpp' l='99' u='c' c='_ZN6Halide14PythonBindings15define_pipelineERN8pybind117module_E'/>
<use f='halide/python_bindings/src/PyPipeline.cpp' l='106' u='c' c='_ZN6Halide14PythonBindings15define_pipelineERN8pybind117module_E'/>
<dec f='halide/src/Pipeline.h' l='519' type='void Halide::Pipeline::realize(Halide::Pipeline::RealizationArg output, const Halide::Target &amp; target = Halide::Target(), const Halide::ParamMap &amp; param_map = ParamMap::empty_map())'/>
<doc f='halide/src/Pipeline.h' l='510'>/** Evaluate this Pipeline into an existing allocated buffer or
     * buffers. If the buffer is also one of the arguments to the
     * function, strange things may happen, as the pipeline isn&apos;t
     * necessarily safe to run in-place. The realization should
     * contain one Buffer per tuple component per output Func. For
     * each individual output Func, all Buffers must have the same
     * shape, but the shape can vary across the different output
     * Funcs. This form of realize does *not* automatically copy data
     * back from the GPU. */</doc>
<use f='halide/src/Func.cpp' l='3306' u='c' c='_ZN6Halide4Func7realizeENS_8Pipeline14RealizationArgERKNS_6TargetERKNS_8ParamMapE'/>
<use f='halide/src/Generator.h' l='3151' u='c' c='_ZN6Halide8Internal13GeneratorBase7realizeENS_11RealizationE'/>
<use f='halide/src/Pipeline.cpp' l='724' u='c' c='_ZN6Halide8Pipeline7realizeESt6vectorIiSaIiEERKNS_6TargetERKNS_8ParamMapE'/>
<use f='halide/src/Pipeline.cpp' l='730' u='c' c='_ZN6Halide8Pipeline7realizeESt6vectorIiSaIiEERKNS_6TargetERKNS_8ParamMapE'/>
<def f='halide/src/Pipeline.cpp' l='1068' ll='1175' type='void Halide::Pipeline::realize(Halide::Pipeline::RealizationArg outputs, const Halide::Target &amp; t = Halide::Target(), const Halide::ParamMap &amp; param_map = ParamMap::empty_map())'/>
