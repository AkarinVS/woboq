<dec f='halide/build-apps/eigen/Eigen/src/Geometry/Transform.h' l='607' type='void Eigen::Transform::computeScalingRotation(ScalingMatrixType * scaling, RotationMatrixType * rotation) const'/>
<def f='halide/build-apps/eigen/Eigen/src/Geometry/Transform.h' l='1125' ll='1141' type='void Eigen::Transform::computeScalingRotation(ScalingMatrixType * scaling, RotationMatrixType * rotation) const'/>
<doc f='halide/build-apps/eigen/Eigen/src/Geometry/Transform.h' l='1114'>/** decomposes the linear part of the transformation as a product scaling x rotation, the scaling being
  * not necessarily positive.
  *
  * If either pointer is zero, the corresponding computation is skipped.
  *
  *
  *
  * \svd_module
  *
  * \sa computeRotationScaling(), rotation(), class SVD
  */</doc>
