<def f='halide/tools/halide_benchmark.h' l='84' ll='96' type='double Halide::Tools::benchmark(uint64_t samples, uint64_t iterations, const std::function&lt;void ()&gt; &amp; op)'/>
<use f='halide/tools/halide_benchmark.h' l='176' u='c' c='_ZN6Halide5Tools9benchmarkERKSt8functionIFvvEERKNS0_15BenchmarkConfigE'/>
<use f='halide/tools/halide_benchmark.h' l='198' u='c' c='_ZN6Halide5Tools9benchmarkERKSt8functionIFvvEERKNS0_15BenchmarkConfigE'/>
<doc f='halide/tools/halide_benchmark.h' l='67'>// Benchmark the operation &apos;op&apos;. The number of iterations refers to
// how many times the operation is run for each time measurement, the
// result is the minimum over a number of samples runs. The result is the
// amount of time in seconds for one iteration.
//
// NOTE: it is usually simpler and more accurate to use the adaptive
// version of benchmark() later in this file; this function is provided
// for legacy code.
//
// IMPORTANT NOTE: Using this tool for timing GPU code may be misleading,
// as it does not account for time needed to synchronize to/from the GPU;
// if the callback doesn&apos;t include calls to device_sync(), the reported
// time may only be that to queue the requests; if the callback *does*
// include calls to device_sync(), it might exaggerate the sync overhead
// for real-world use. For now, callers using this to benchmark GPU
// code should measure with extreme caution.</doc>
<use f='halide/tutorial/lesson_16_rgb_run.cpp' l='66' u='c' c='main'/>
<use f='halide/tutorial/lesson_16_rgb_run.cpp' l='71' u='c' c='main'/>
<use f='halide/tutorial/lesson_16_rgb_run.cpp' l='92' u='c' c='main'/>
<use f='halide/tutorial/lesson_16_rgb_run.cpp' l='98' u='c' c='main'/>
<use f='halide/tutorial/lesson_16_rgb_run.cpp' l='108' u='c' c='main'/>
<use f='halide/tutorial/lesson_16_rgb_run.cpp' l='118' u='c' c='main'/>
<use f='halide/tutorial/lesson_21_auto_scheduler_run.cpp' l='39' u='c' c='main'/>
<use f='halide/tutorial/lesson_21_auto_scheduler_run.cpp' l='44' u='c' c='main'/>
