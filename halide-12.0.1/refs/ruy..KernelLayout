<def f='halide/build-apps/ruy/ruy/mat.h' l='166' ll='170'/>
<use f='halide/build-apps/ruy/ruy/mat.h' l='187'/>
<use f='halide/build-apps/ruy/ruy/mat.h' l='472' c='_ZN3ruy14ToKernelLayoutEv'/>
<use f='halide/build-apps/ruy/ruy/mat.h' l='473' c='_ZN3ruy14ToKernelLayoutEv'/>
<use f='halide/build-apps/ruy/ruy/create_trmul_params.h' l='43' c='_ZN3ruy6detail18CreatePackedLayoutERKNS_9MatLayoutERKNS_12KernelLayoutEPNS_10PMatLayoutE'/>
<use f='halide/build-apps/ruy/ruy/create_trmul_params.h' l='55' c='_ZN3ruy6detail18CreatePackedMatrixENS_4SideERKNS_12KernelLayoutEPNS_11TrMulParamsE'/>
<size>3</size>
<doc f='halide/build-apps/ruy/ruy/mat.h' l='152'>// KernelLayout describes small-scale block structure in a packed matrix layout.
// It&apos;s a runtime (as opposed to compile-time-constant) version of the
// FixedKernelLayout struct used to declare kernel layouts.
//
// This is is sometimes known as &quot;tiling&quot; in other contexts.
//
// For example, consider a packed matrix in column-major format with a
// column-major KernelLayout. The matrix logically has a shape of
// `[cols, rows]`. However, the matrix is laid out as though it were a 4D array
// of shape `[cols / kcols, rows / krows, kcols, krows]`.
//
// Note that in the case of kcols=1, krows=1, this degenerates to
// `[cols, rows, 1, 1]` which is equivalent to having no small-scale block
// structure.</doc>
<mbr r='ruy::KernelLayout::order' o='0' t='ruy::Order'/>
<mbr r='ruy::KernelLayout::rows' o='8' t='std::uint8_t'/>
<mbr r='ruy::KernelLayout::cols' o='16' t='std::uint8_t'/>
