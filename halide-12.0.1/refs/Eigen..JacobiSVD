<use f='halide/build-apps/eigen/Eigen/src/Core/MatrixBase.h' l='371' c='_ZNK5Eigen10MatrixBase9jacobiSvdEj'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='55' c='_ZN5Eigen8internal22qr_preconditioner_implIT_XT0_EXT1_ELb0EE8allocateERKNS_9JacobiSVDIS2_XT0_EEE'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='56' c='_ZN5Eigen8internal22qr_preconditioner_implIT_XT0_EXT1_ELb0EE3runERNS_9JacobiSVDIS2_XT0_EEERKS2_'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='76' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li3ELi1ELb1EE8allocateERKNS_9JacobiSVDIS2_Li3EEE'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='86' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li3ELi1ELb1EE3runERNS_9JacobiSVDIS2_Li3EEERKS2_'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='122' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li3ELi0ELb1EE8allocateERKNS_9JacobiSVDIS2_Li3EEE'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='133' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li3ELi0ELb1EE3runERNS_9JacobiSVDIS2_Li3EEERKS2_'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='159' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li2ELi1ELb1EE8allocateERKNS_9JacobiSVDIS2_Li2EEE'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='170' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li2ELi1ELb1EE3runERNS_9JacobiSVDIS2_Li2EEERKS2_'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='213' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li2ELi0ELb1EE8allocateERKNS_9JacobiSVDIS2_Li2EEE'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='225' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li2ELi0ELb1EE3runERNS_9JacobiSVDIS2_Li2EEERKS2_'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='258' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li1ELi1ELb1EE8allocateERKNS_9JacobiSVDIS2_Li1EEE'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='269' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li1ELi1ELb1EE3runERNS_9JacobiSVDIS2_Li1EEERKS2_'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='309' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li1ELi0ELb1EE8allocateERKNS_9JacobiSVDIS2_Li1EEE'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='321' c='_ZN5Eigen8internal22qr_preconditioner_implIT_Li1ELi0ELb1EE3runERNS_9JacobiSVDIS2_Li1EEERKS2_'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='356'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='364'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='427'/>
<def f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='488' ll='611'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='489'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='614' c='_ZN5Eigen9JacobiSVD8allocateEllj'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='664' c='_ZN5Eigen9JacobiSVD7computeERKT_j'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='663' c='_ZN5Eigen9JacobiSVD7computeERKT_j'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='797' c='_ZNK5Eigen10MatrixBase9jacobiSvdEj'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='800' c='_ZNK5Eigen10MatrixBase9jacobiSvdEj'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/BDCSVD.h' l='258' c='_ZN5Eigen6BDCSVD7computeERKT_j'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/BDCSVD.h' l='416' c='_ZN5Eigen6BDCSVD6divideElllll'/>
<use f='halide/build-apps/eigen/Eigen/src/Geometry/Quaternion.h' l='657' c='_ZN5Eigen14QuaternionBase17setFromTwoVectorsERKNS_10MatrixBaseITL0__EERKNS1_ITL0_0_EE'/>
<use f='halide/build-apps/eigen/Eigen/src/Geometry/Transform.h' l='1100' c='_ZNK5Eigen9Transform22computeRotationScalingEPTL0__PTL0_0_'/>
<use f='halide/build-apps/eigen/Eigen/src/Geometry/Transform.h' l='1129' c='_ZNK5Eigen9Transform22computeScalingRotationEPTL0__PTL0_0_'/>
<use f='halide/build-apps/eigen/Eigen/src/Geometry/Hyperplane.h' l='109' c='_ZN5Eigen10Hyperplane7ThroughERKNS_6MatrixIT_XLNS0_Ut_E0EELi1EXorLNS_14StorageOptionsE0EquaaeqLS3_0ELi1EneLi1ELi1ELS4_1EquaaeqLi1ELi1EneLS3_0ELi1ELS4_12901781'/>
<use f='halide/build-apps/eigen/Eigen/src/Geometry/Umeyama.h' l='131' c='_ZN5Eigen7umeyamaERKNS_10MatrixBaseIT_EERKNS0_IT0_EEb'/>
<doc f='halide/build-apps/eigen/Eigen/src/SVD/JacobiSVD.h' l='435'>/** \ingroup SVD_Module
  *
  *
  * \class JacobiSVD
  *
  * \brief Two-sided Jacobi SVD decomposition of a rectangular matrix
  *
  * \tparam _MatrixType the type of the matrix of which we are computing the SVD decomposition
  * \tparam QRPreconditioner this optional parameter allows to specify the type of QR decomposition that will be used internally
  *                        for the R-SVD step for non-square matrices. See discussion of possible values below.
  *
  * SVD decomposition consists in decomposing any n-by-p matrix \a A as a product
  *   \f[ A = U S V^* \f]
  * where \a U is a n-by-n unitary, \a V is a p-by-p unitary, and \a S is a n-by-p real positive matrix which is zero outside of its main diagonal;
  * the diagonal entries of S are known as the \em singular \em values of \a A and the columns of \a U and \a V are known as the left
  * and right \em singular \em vectors of \a A respectively.
  *
  * Singular values are always sorted in decreasing order.
  *
  * This JacobiSVD decomposition computes only the singular values by default. If you want \a U or \a V, you need to ask for them explicitly.
  *
  * You can ask for only \em thin \a U or \a V to be computed, meaning the following. In case of a rectangular n-by-p matrix, letting \a m be the
  * smaller value among \a n and \a p, there are only \a m singular vectors; the remaining columns of \a U and \a V do not correspond to actual
  * singular vectors. Asking for \em thin \a U or \a V means asking for only their \a m first columns to be formed. So \a U is then a n-by-m matrix,
  * and \a V is then a p-by-m matrix. Notice that thin \a U and \a V are all you need for (least squares) solving.
  *
  * Here&apos;s an example demonstrating basic usage:
  * \include JacobiSVD_basic.cpp
  * Output: \verbinclude JacobiSVD_basic.out
  *
  * This JacobiSVD class is a two-sided Jacobi R-SVD decomposition, ensuring optimal reliability and accuracy. The downside is that it&apos;s slower than
  * bidiagonalizing SVD algorithms for large square matrices; however its complexity is still \f$ O(n^2p) \f$ where \a n is the smaller dimension and
  * \a p is the greater dimension, meaning that it is still of the same order of complexity as the faster bidiagonalizing R-SVD algorithms.
  * In particular, like any R-SVD, it takes advantage of non-squareness in that its complexity is only linear in the greater dimension.
  *
  * If the input matrix has inf or nan coefficients, the result of the computation is undefined, but the computation is guaranteed to
  * terminate in finite (and reasonable) time.
  *
  * The possible values for QRPreconditioner are:
  * \li ColPivHouseholderQRPreconditioner is the default. In practice it&apos;s very safe. It uses column-pivoting QR.
  * \li FullPivHouseholderQRPreconditioner, is the safest and slowest. It uses full-pivoting QR.
  *     Contrary to other QRs, it doesn&apos;t allow computing thin unitaries.
  * \li HouseholderQRPreconditioner is the fastest, and less safe and accurate than the pivoting variants. It uses non-pivoting QR.
  *     This is very similar in safety and accuracy to the bidiagonalization process used by bidiagonalizing SVD algorithms (since bidiagonalization
  *     is inherently non-pivoting). However the resulting SVD is still more reliable than bidiagonalizing SVDs because the Jacobi-based iterarive
  *     process is more reliable than the optimized bidiagonal SVD iterations.
  * \li NoQRPreconditioner allows not to use a QR preconditioner at all. This is useful if you know that you will only be computing
  *     JacobiSVD decompositions of square matrices. Non-square matrices require a QR preconditioner. Using this option will result in
  *     faster compilation and smaller executable code. It won&apos;t significantly speed up computation, since JacobiSVD is always checking
  *     if QR preconditioning is needed before applying it anyway.
  *
  * \sa MatrixBase::jacobiSvd()
  */</doc>
<fun r='_ZN5Eigen9JacobiSVDC1Ev'/>
<fun r='_ZN5Eigen9JacobiSVDC1Ellj'/>
<fun r='_ZN5Eigen9JacobiSVDC1ERKT_j'/>
<fun r='_ZN5Eigen9JacobiSVD7computeERKT_j'/>
<fun r='_ZN5Eigen9JacobiSVD7computeERKT_'/>
<fun r='_ZN5Eigen9JacobiSVD8allocateEllj'/>
<mbr r='Eigen::JacobiSVD::m_workMatrix' t='Eigen::JacobiSVD::WorkMatrixType'/>
<mbr r='Eigen::JacobiSVD::m_qr_precond_morecols' t='internal::qr_preconditioner_impl&lt;MatrixType, QRPreconditioner, internal::PreconditionIfMoreColsThanRows&gt;'/>
<mbr r='Eigen::JacobiSVD::m_qr_precond_morerows' t='internal::qr_preconditioner_impl&lt;MatrixType, QRPreconditioner, internal::PreconditionIfMoreRowsThanCols&gt;'/>
<mbr r='Eigen::JacobiSVD::m_scaledMatrix' t='Eigen::JacobiSVD::MatrixType'/>
<fun r='_ZN5Eigen9JacobiSVD8allocateEllj'/>
<fun r='_ZN5Eigen9JacobiSVD7computeERKT_j'/>
<use f='halide/build-apps/eigen/lapack/svd.cpp' l='124' c='zgesvd_'/>
