<use f='halide/llvm-install/include/llvm/Analysis/TargetTransformInfo.h' l='2249' u='w' c='_ZN4llvm16TargetIRAnalysisC1ERKS0_'/>
<use f='halide/llvm-install/include/llvm/Analysis/TargetTransformInfo.h' l='2249' u='r' c='_ZN4llvm16TargetIRAnalysisC1ERKS0_'/>
<use f='halide/llvm-install/include/llvm/Analysis/TargetTransformInfo.h' l='2251' u='w' c='_ZN4llvm16TargetIRAnalysisC1EOS0_'/>
<use f='halide/llvm-install/include/llvm/Analysis/TargetTransformInfo.h' l='2251' u='a' c='_ZN4llvm16TargetIRAnalysisC1EOS0_'/>
<use f='halide/llvm-install/include/llvm/Analysis/TargetTransformInfo.h' l='2253' u='w' c='_ZN4llvm16TargetIRAnalysisaSERKS0_'/>
<use f='halide/llvm-install/include/llvm/Analysis/TargetTransformInfo.h' l='2253' u='r' c='_ZN4llvm16TargetIRAnalysisaSERKS0_'/>
<use f='halide/llvm-install/include/llvm/Analysis/TargetTransformInfo.h' l='2257' u='w' c='_ZN4llvm16TargetIRAnalysisaSEOS0_'/>
<use f='halide/llvm-install/include/llvm/Analysis/TargetTransformInfo.h' l='2257' u='a' c='_ZN4llvm16TargetIRAnalysisaSEOS0_'/>
<dec f='halide/llvm-install/include/llvm/Analysis/TargetTransformInfo.h' l='2277' type='std::function&lt;Result (const Function &amp;)&gt;'/>
<offset>0</offset>
<doc f='halide/llvm-install/include/llvm/Analysis/TargetTransformInfo.h' l='2267'>/// The callback used to produce a result.
  ///
  /// We use a completely opaque callback so that targets can provide whatever
  /// mechanism they desire for constructing the TTI for a given function.
  ///
  /// FIXME: Should we really use std::function? It&apos;s relatively inefficient.
  /// It might be possible to arrange for even stateful callbacks to outlive
  /// the analysis and thus use a function_ref which would be lighter weight.
  /// This may also be less error prone as the callback is likely to reference
  /// the external TargetMachine, and that reference needs to never dangle.</doc>
