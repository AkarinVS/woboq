<dec f='halide/halide-install/include/Halide.h' l='7313' type='Halide::Expr Halide::operator%(Halide::Expr a, Halide::Expr b)'/>
<use f='halide/halide-install/include/Halide.h' l='7553' u='c' c='_ZN6HalidermENS_4ExprEf'/>
<use f='halide/halide-install/include/Halide.h' l='7556' u='c' c='_ZN6HalidermEfNS_4ExprE'/>
<doc f='halide/halide-install/include/Halide.h' l='7303'>/** Return the first argument reduced modulo the second, doing any
 * necessary type coercion using \ref Internal::match_types. There are
 * two key differences between C-like languages and Halide for the
 * modulo operation, which complement the way division works.
 *
 * First, the result is never negative, so x % 2 is always zero or
 * one, unlike in C-like languages. x % -2 is equivalent, and is also
 * always zero or one. Second, mod by zero evaluates to zero (unlike
 * in C, where it faults). This makes modulo, like division, a
 * side-effect-free operation. */</doc>
<dec f='halide/build/include/Halide.h' l='7313' type='Halide::Expr Halide::operator%(Halide::Expr a, Halide::Expr b)'/>
<use f='halide/build/include/Halide.h' l='7553' u='c' c='_ZN6HalidermENS_4ExprEf'/>
<use f='halide/build/include/Halide.h' l='7556' u='c' c='_ZN6HalidermEfNS_4ExprE'/>
<doc f='halide/build/include/Halide.h' l='7303'>/** Return the first argument reduced modulo the second, doing any
 * necessary type coercion using \ref Internal::match_types. There are
 * two key differences between C-like languages and Halide for the
 * modulo operation, which complement the way division works.
 *
 * First, the result is never negative, so x % 2 is always zero or
 * one, unlike in C-like languages. x % -2 is equivalent, and is also
 * always zero or one. Second, mod by zero evaluates to zero (unlike
 * in C, where it faults). This makes modulo, like division, a
 * side-effect-free operation. */</doc>
<dec f='halide/src/IROperator.h' l='508' type='Halide::Expr Halide::operator%(Halide::Expr a, Halide::Expr b)'/>
<use f='halide/src/IROperator.h' l='748' u='c' c='_ZN6HalidermENS_4ExprEf'/>
<use f='halide/src/IROperator.h' l='751' u='c' c='_ZN6HalidermEfNS_4ExprE'/>
<doc f='halide/src/IROperator.h' l='498'>/** Return the first argument reduced modulo the second, doing any
 * necessary type coercion using \ref Internal::match_types. There are
 * two key differences between C-like languages and Halide for the
 * modulo operation, which complement the way division works.
 *
 * First, the result is never negative, so x % 2 is always zero or
 * one, unlike in C-like languages. x % -2 is equivalent, and is also
 * always zero or one. Second, mod by zero evaluates to zero (unlike
 * in C, where it faults). This makes modulo, like division, a
 * side-effect-free operation. */</doc>
<use f='halide/src/ApplySplit.cpp' l='41' u='c' c='_ZN6Halide8Internal11apply_splitERKNS0_5SplitEbRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERSt3mapIS9_NS_4ExprESt4lessIS9_ESaISt4pairISA_SD_EEE'/>
<use f='halide/src/ApplySplit.cpp' l='105' u='c' c='_ZN6Halide8Internal11apply_splitERKNS0_5SplitEbRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERSt3mapIS9_NS_4ExprESt4lessIS9_ESaISt4pairISA_SD_EEE'/>
<use f='halide/src/BoundaryConditions.cpp' l='100' u='c' c='_ZN6Halide18BoundaryConditions12repeat_imageERKNS_4FuncERKSt6vectorINS_5RangeESaIS5_EE'/>
<use f='halide/src/BoundaryConditions.cpp' l='141' u='c' c='_ZN6Halide18BoundaryConditions12mirror_imageERKNS_4FuncERKSt6vectorINS_5RangeESaIS5_EE'/>
<use f='halide/src/BoundaryConditions.cpp' l='183' u='c' c='_ZN6Halide18BoundaryConditions15mirror_interiorERKNS_4FuncERKSt6vectorINS_5RangeESaIS5_EE'/>
<use f='halide/src/Bounds.cpp' l='3193' u='c' c='_ZN6Halide8Internal11bounds_testEv'/>
<use f='halide/src/Bounds.cpp' l='3195' u='c' c='_ZN6Halide8Internal11bounds_testEv'/>
<use f='halide/src/CSE.cpp' l='426' u='c' c='_ZN6Halide8Internal8cse_testEv'/>
<use f='halide/src/CSE.cpp' l='430' u='c' c='_ZN6Halide8Internal8cse_testEv'/>
<use f='halide/src/Func.cpp' l='2315' u='c' c='_ZN6Halide4Func12align_boundsERKNS_3VarENS_4ExprES4_'/>
<def f='halide/src/IROperator.cpp' l='1649' ll='1653' type='Halide::Expr Halide::operator%(Halide::Expr a, Halide::Expr b)'/>
<use f='halide/src/IROperator.cpp' l='2515' u='c' c='_ZN6Halide17mod_round_to_zeroENS_4ExprES0_'/>
<use f='halide/src/LowerWarpShuffles.cpp' l='58' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_118reduce_expr_helperENS_4ExprERKS2_'/>
<use f='halide/src/LowerWarpShuffles.cpp' l='64' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_118reduce_expr_helperENS_4ExprERKS2_'/>
<use f='halide/src/LowerWarpShuffles.cpp' l='83' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_111reduce_exprENS_4ExprERKS2_RKNS0_5ScopeINS0_8IntervalEEE'/>
<use f='halide/src/LowerWarpShuffles.cpp' l='588' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_117LowerWarpShuffles14make_warp_loadENS_4TypeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_4ExprESC_'/>
<use f='halide/src/LowerWarpShuffles.cpp' l='591' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_117LowerWarpShuffles14make_warp_loadENS_4TypeERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKNS_4ExprESC_'/>
<use f='halide/src/StorageFolding.cpp' l='72' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_121FoldStorageOfFunction5visitEPKNS0_4CallE'/>
<use f='halide/src/StorageFolding.cpp' l='102' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_121FoldStorageOfFunction5visitEPKNS0_4CallE'/>
<use f='halide/src/StorageFolding.cpp' l='146' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_121FoldStorageOfFunction5visitEPKNS0_7ProvideE'/>
