<def f='halide/build/_deps/pybind11-src/include/pybind11/cast.h' l='792'/>
<def f='halide/build/_deps/pybind11-src/include/pybind11/cast.h' l='797' ll='802'/>
<use f='halide/build/_deps/pybind11-src/include/pybind11/cast.h' l='802'/>
<def f='halide/build/_deps/pybind11-src/include/pybind11/cast.h' l='807' ll='808'/>
<use f='halide/build/_deps/pybind11-src/include/pybind11/cast.h' l='808'/>
<use f='halide/build/_deps/pybind11-src/include/pybind11/cast.h' l='808'/>
<use f='halide/build/_deps/pybind11-src/include/pybind11/cast.h' l='928'/>
<use f='halide/build/_deps/pybind11-src/include/pybind11/cast.h' l='1612'/>
<use f='halide/build/_deps/pybind11-src/include/pybind11/cast.h' l='1681'/>
<doc f='halide/build/_deps/pybind11-src/include/pybind11/cast.h' l='790'>// std::is_copy_constructible isn&apos;t quite enough: it lets std::vector&lt;T&gt; (and similar) through when
// T is non-copyable, but code containing such a copy constructor fails to actually compile.</doc>
<doc f='halide/build/_deps/pybind11-src/include/pybind11/cast.h' l='794'>// Specialization for types that appear to be copy constructible but also look like stl containers
// (we specifically check for: has `value_type` and `reference` with `reference = value_type&amp;`): if
// so, copy constructability depends on whether the value_type is copy constructible.</doc>
<doc f='halide/build/_deps/pybind11-src/include/pybind11/cast.h' l='804'>// Likewise for std::pair
// (after C++17 it is mandatory that the copy constructor not exist when the two types aren&apos;t themselves
// copy constructible, but this can not be relied upon when T1 or T2 are themselves containers).</doc>
