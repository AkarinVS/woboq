<dec f='halide/build-apps/abseil-cpp/absl/random/internal/randen_detect.h' l='27' type='bool absl::lts_2020_02_25::random_internal::CPUSupportsRandenHwAes()'/>
<use f='halide/build-apps/abseil-cpp/absl/random/internal/randen.cc' l='58' u='c' c='_ZN4absl14lts_2020_02_2515random_internal12_GLOBAL__N_114GetRandenStateEv'/>
<doc f='halide/build-apps/abseil-cpp/absl/random/internal/randen_detect.h' l='24'>// Returns whether the current CPU supports RandenHwAes implementation.
// This typically involves supporting cryptographic extensions on whichever
// platform is currently running.</doc>
<def f='halide/build-apps/abseil-cpp/absl/random/internal/randen_detect.cc' l='127' ll='213' type='bool absl::lts_2020_02_25::random_internal::CPUSupportsRandenHwAes()'/>
<doc f='halide/build-apps/abseil-cpp/absl/random/internal/randen_detect.cc' l='108'>// CPUSupportsRandenHwAes returns whether the CPU is a microarchitecture
// which supports the crpyto/aes instructions or extensions necessary to use the
// accelerated RandenHwAes implementation.
//
// 1. For x86 it is sufficient to use the CPUID instruction to detect whether
//    the cpu supports AES instructions. Done.
//
// Fon non-x86 it is much more complicated.
//
// 2. When ABSL_INTERNAL_USE_GETAUXVAL is defined, use getauxval() (either
//    the direct c-library version, or the android probing version which loads
//    libc), and read the hardware capability bits.
//    This is based on the technique used by boringssl uses to detect
//    cpu capabilities, and should allow us to enable crypto in the android
//    builds where it is supported.
//
// 3. Use the default for the compiler architecture.
//</doc>
