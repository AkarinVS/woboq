<dec f='halide/halide-install/include/Halide.h' l='8025' type='Halide::Expr Halide::mod_round_to_zero(Halide::Expr x, Halide::Expr y)'/>
<doc f='halide/halide-install/include/Halide.h' l='8020'>/** Compute the remainder of dividing two integers, when division is
 * rounding toward zero. This is the typical behavior of most hardware
 * architectures, which differs from Halide&apos;s mod operator, which is
 * Euclidean (produces the remainder when division rounds towards
 * -infinity). Will throw a runtime error if y is zero. */</doc>
<dec f='halide/build/include/Halide.h' l='8025' type='Halide::Expr Halide::mod_round_to_zero(Halide::Expr x, Halide::Expr y)'/>
<doc f='halide/build/include/Halide.h' l='8020'>/** Compute the remainder of dividing two integers, when division is
 * rounding toward zero. This is the typical behavior of most hardware
 * architectures, which differs from Halide&apos;s mod operator, which is
 * Euclidean (produces the remainder when division rounds towards
 * -infinity). Will throw a runtime error if y is zero. */</doc>
<use f='halide/python_bindings/src/PyIROperator.cpp' l='171' u='a' c='_ZN6Halide14PythonBindings16define_operatorsERN8pybind117module_E'/>
<dec f='halide/src/IROperator.h' l='1220' type='Halide::Expr Halide::mod_round_to_zero(Halide::Expr x, Halide::Expr y)'/>
<doc f='halide/src/IROperator.h' l='1215'>/** Compute the remainder of dividing two integers, when division is
 * rounding toward zero. This is the typical behavior of most hardware
 * architectures, which differs from Halide&apos;s mod operator, which is
 * Euclidean (produces the remainder when division rounds towards
 * -infinity). Will throw a runtime error if y is zero. */</doc>
<def f='halide/src/IROperator.cpp' l='2510' ll='2523' type='Halide::Expr Halide::mod_round_to_zero(Halide::Expr x, Halide::Expr y)'/>
