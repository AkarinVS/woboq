<def f='halide/halide-install/include/Halide.h' l='6709' ll='6720'/>
<use f='halide/halide-install/include/Halide.h' l='6719' c='_ZNK6Halide8Internal20ExprWithCompareCacheltERKS1_'/>
<size>16</size>
<doc f='halide/halide-install/include/Halide.h' l='6686'>/** A wrapper about Exprs so that they can be deeply compared with a
 * cache for known-equal subexpressions. Useful for unsanitized Exprs
 * coming in from the front-end, which may be horrible graphs with
 * sub-expressions that are equal by value but not by identity. This
 * isn&apos;t a comparison object like IRDeepCompare above, because libc++
 * requires that comparison objects be stateless (and constructs a new
 * one for each comparison!), so they can&apos;t have a cache associated
 * with them. However, by sneakily making the cache a mutable member
 * of the objects being compared, we can dodge this issue.
 *
 * Clunky example usage:
 *
\code
Expr a, b, c, query;
std::set&lt;ExprWithCompareCache&gt; s;
IRCompareCache cache(8);
s.insert(ExprWithCompareCache(a, &amp;cache));
s.insert(ExprWithCompareCache(b, &amp;cache));
s.insert(ExprWithCompareCache(c, &amp;cache));
if (m.contains(ExprWithCompareCache(query, &amp;cache))) {...}
\endcode
 *
 */</doc>
<mbr r='Halide::Internal::ExprWithCompareCache::expr' o='0' t='Halide::Expr'/>
<mbr r='Halide::Internal::ExprWithCompareCache::cache' o='64' t='Halide::Internal::IRCompareCache *'/>
<fun r='_ZN6Halide8Internal20ExprWithCompareCacheC1Ev'/>
<fun r='_ZN6Halide8Internal20ExprWithCompareCacheC1ERKNS_4ExprEPNS0_14IRCompareCacheE'/>
<fun r='_ZNK6Halide8Internal20ExprWithCompareCacheltERKS1_'/>
<def f='halide/build/include/Halide.h' l='6709' ll='6720'/>
<use f='halide/build/include/Halide.h' l='6719' c='_ZNK6Halide8Internal20ExprWithCompareCacheltERKS1_'/>
<size>16</size>
<doc f='halide/build/include/Halide.h' l='6686'>/** A wrapper about Exprs so that they can be deeply compared with a
 * cache for known-equal subexpressions. Useful for unsanitized Exprs
 * coming in from the front-end, which may be horrible graphs with
 * sub-expressions that are equal by value but not by identity. This
 * isn&apos;t a comparison object like IRDeepCompare above, because libc++
 * requires that comparison objects be stateless (and constructs a new
 * one for each comparison!), so they can&apos;t have a cache associated
 * with them. However, by sneakily making the cache a mutable member
 * of the objects being compared, we can dodge this issue.
 *
 * Clunky example usage:
 *
\code
Expr a, b, c, query;
std::set&lt;ExprWithCompareCache&gt; s;
IRCompareCache cache(8);
s.insert(ExprWithCompareCache(a, &amp;cache));
s.insert(ExprWithCompareCache(b, &amp;cache));
s.insert(ExprWithCompareCache(c, &amp;cache));
if (m.contains(ExprWithCompareCache(query, &amp;cache))) {...}
\endcode
 *
 */</doc>
<mbr r='Halide::Internal::ExprWithCompareCache::expr' o='0' t='Halide::Expr'/>
<mbr r='Halide::Internal::ExprWithCompareCache::cache' o='64' t='Halide::Internal::IRCompareCache *'/>
<fun r='_ZN6Halide8Internal20ExprWithCompareCacheC1Ev'/>
<fun r='_ZN6Halide8Internal20ExprWithCompareCacheC1ERKNS_4ExprEPNS0_14IRCompareCacheE'/>
<fun r='_ZNK6Halide8Internal20ExprWithCompareCacheltERKS1_'/>
<def f='halide/src/IREquality.h' l='95' ll='106'/>
<use f='halide/src/IREquality.h' l='105' c='_ZNK6Halide8Internal20ExprWithCompareCacheltERKS1_'/>
<size>16</size>
<doc f='halide/src/IREquality.h' l='72'>/** A wrapper about Exprs so that they can be deeply compared with a
 * cache for known-equal subexpressions. Useful for unsanitized Exprs
 * coming in from the front-end, which may be horrible graphs with
 * sub-expressions that are equal by value but not by identity. This
 * isn&apos;t a comparison object like IRDeepCompare above, because libc++
 * requires that comparison objects be stateless (and constructs a new
 * one for each comparison!), so they can&apos;t have a cache associated
 * with them. However, by sneakily making the cache a mutable member
 * of the objects being compared, we can dodge this issue.
 *
 * Clunky example usage:
 *
\code
Expr a, b, c, query;
std::set&lt;ExprWithCompareCache&gt; s;
IRCompareCache cache(8);
s.insert(ExprWithCompareCache(a, &amp;cache));
s.insert(ExprWithCompareCache(b, &amp;cache));
s.insert(ExprWithCompareCache(c, &amp;cache));
if (m.contains(ExprWithCompareCache(query, &amp;cache))) {...}
\endcode
 *
 */</doc>
<mbr r='Halide::Internal::ExprWithCompareCache::expr' o='0' t='Halide::Expr'/>
<mbr r='Halide::Internal::ExprWithCompareCache::cache' o='64' t='Halide::Internal::IRCompareCache *'/>
<fun r='_ZN6Halide8Internal20ExprWithCompareCacheC1Ev'/>
<fun r='_ZN6Halide8Internal20ExprWithCompareCacheC1ERKNS_4ExprEPNS0_14IRCompareCacheE'/>
<fun r='_ZNK6Halide8Internal20ExprWithCompareCacheltERKS1_'/>
<use f='halide/src/CSE.cpp' l='79'/>
<use f='halide/src/CSE.cpp' l='87'/>
<use f='halide/src/CSE.cpp' l='102' c='_ZN6Halide8Internal12_GLOBAL__N_13GVN10with_cacheERKNS_4ExprE'/>
<use f='halide/src/CSE.cpp' l='103' c='_ZN6Halide8Internal12_GLOBAL__N_13GVN10with_cacheERKNS_4ExprE'/>
<size>16</size>
<use f='halide/src/IREquality.cpp' l='651' c='_ZNK6Halide8Internal20ExprWithCompareCacheltERKS1_'/>
<size>16</size>
<fun r='_ZNK6Halide8Internal20ExprWithCompareCacheltERKS1_'/>
