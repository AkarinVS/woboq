<dec f='halide/build-apps/eigen/Eigen/src/SparseCore/SparseMatrixBase.h' l='314' type='const Product&lt;Derived, OtherDerived, AliasFreeProduct&gt; Eigen::SparseMatrixBase::operator*(const SparseMatrixBase&lt;OtherDerived&gt; &amp; other) const'/>
<def f='halide/build-apps/eigen/Eigen/src/SparseCore/SparseProduct.h' l='26' ll='32' type='const Product&lt;Derived, OtherDerived, AliasFreeProduct&gt; Eigen::SparseMatrixBase::operator*(const SparseMatrixBase&lt;OtherDerived&gt; &amp; other) const'/>
<doc f='halide/build-apps/eigen/Eigen/src/SparseCore/SparseProduct.h' l='15'>/** \returns an expression of the product of two sparse matrices.
  * By default a conservative product preserving the symbolic non zeros is performed.
  * The automatic pruning of the small values can be achieved by calling the pruned() function
  * in which case a totally different product algorithm is employed:
  * \code
  * C = (A*B).pruned();             // suppress numerical zeros (exact)
  * C = (A*B).pruned(ref);
  * C = (A*B).pruned(ref,epsilon);
  * \endcode
  * where \c ref is a meaningful non zero reference value.
  * */</doc>
