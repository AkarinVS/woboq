<def f='halide/build-apps/ruy/ruy/blocking_counter.h' l='35' ll='62'/>
<size>96</size>
<doc f='halide/build-apps/ruy/ruy/blocking_counter.h' l='27'>// A BlockingCounter lets one thread to wait for N events to occur.
// This is how the master thread waits for all the worker threads
// to have finished working.
// The waiting is done using a naive spinlock waiting for the atomic
// count_ to hit the value 0. This is acceptable because in our usage
// pattern, BlockingCounter is used only to synchronize threads after
// short-lived tasks (performing parts of the same GEMM). It is not used
// for synchronizing longer waits (resuming work on the next GEMM).</doc>
<fun r='_ZN3ruy15BlockingCounterC1Ev'/>
<fun r='_ZN3ruy15BlockingCounter5ResetEi'/>
<fun r='_ZN3ruy15BlockingCounter14DecrementCountEv'/>
<fun r='_ZN3ruy15BlockingCounter4WaitENSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEE'/>
<mbr r='ruy::BlockingCounter::count_' o='0' t='std::atomic&lt;int&gt;'/>
<mbr r='ruy::BlockingCounter::count_cond_' o='64' t='std::condition_variable'/>
<mbr r='ruy::BlockingCounter::count_mutex_' o='448' t='std::mutex'/>
<fun r='_ZN3ruy15BlockingCounter5ResetEi'/>
<fun r='_ZN3ruy15BlockingCounter14DecrementCountEv'/>
<fun r='_ZN3ruy15BlockingCounter4WaitENSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEE'/>
<use f='halide/build-apps/ruy/ruy/thread_pool.h' l='106'/>
<size>96</size>
<use f='halide/build-apps/ruy/ruy/thread_pool.cc' l='44' c='_ZN3ruy6ThreadC1EPNS_15BlockingCounterENSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEE'/>
<use f='halide/build-apps/ruy/ruy/thread_pool.cc' l='165'/>
<size>96</size>
