<dec f='halide/halide-install/include/Halide.h' l='15805' type='static Halide::Var Halide::Var::implicit(int n)'/>
<use f='halide/halide-install/include/Halide.h' l='15857' u='c' c='_ZNK6Halide11ImplicitVar6to_varEv'/>
<doc f='halide/halide-install/include/Halide.h' l='15727'>/** Implicit var constructor. Implicit variables are injected
     * automatically into a function call if the number of arguments
     * to the function are fewer than its dimensionality and a
     * placeholder (&quot;_&quot;) appears in its argument list. Defining a
     * function to equal an expression containing implicit variables
     * similarly appends those implicit variables, in the same order,
     * to the left-hand-side of the definition where the placeholder
     * (&apos;_&apos;) appears.
     *
     * For example, consider the definition:
     *
     \code
     Func f, g;
     Var x, y;
     f(x, y) = 3;
     \endcode
     *
     * A call to f with the placeholder symbol _
     * will have implicit arguments injected automatically, so f(2, _)
     * is equivalent to f(2, _0), where _0 = ImplicitVar&lt;0&gt;(), and f(_)
     * (and indeed f when cast to an Expr) is equivalent to f(_0, _1).
     * The following definitions are all equivalent, differing only in the
     * variable names.
     *
     \code
     g(_) = f*3;
     g(_) = f(_)*3;
     g(x, _) = f(x, _)*3;
     g(x, y) = f(x, y)*3;
     \endcode
     *
     * These are expanded internally as follows:
     *
     \code
     g(_0, _1) = f(_0, _1)*3;
     g(_0, _1) = f(_0, _1)*3;
     g(x, _0) = f(x, _0)*3;
     g(x, y) = f(x, y)*3;
     \endcode
     *
     * The following, however, defines g as four dimensional:
     \code
     g(x, y, _) = f*3;
     \endcode
     *
     * It is equivalent to:
     *
     \code
     g(x, y, _0, _1) = f(_0, _1)*3;
     \endcode
     *
     * Expressions requiring differing numbers of implicit variables
     * can be combined. The left-hand-side of a definition injects
     * enough implicit variables to cover all of them:
     *
     \code
     Func h;
     h(x) = x*3;
     g(x) = h + (f + f(x)) * f(x, y);
     \endcode
     *
     * expands to:
     *
     \code
     Func h;
     h(x) = x*3;
     g(x, _0, _1) = h(_0) + (f(_0, _1) + f(x, _0)) * f(x, y);
     \endcode
     *
     * The first ten implicits, _0 through _9, are predeclared in this
     * header and can be used for scheduling. They should never be
     * used as arguments in a declaration or used in a call.
     *
     * While it is possible to use Var::implicit or the predeclared
     * implicits to create expressions that can be treated as small
     * anonymous functions (e.g. Func(_0 + _1)) this is considered
     * poor style. Instead use \ref lambda.
     */</doc>
<dec f='halide/build/include/Halide.h' l='15805' type='static Halide::Var Halide::Var::implicit(int n)'/>
<use f='halide/build/include/Halide.h' l='15857' u='c' c='_ZNK6Halide11ImplicitVar6to_varEv'/>
<doc f='halide/build/include/Halide.h' l='15727'>/** Implicit var constructor. Implicit variables are injected
     * automatically into a function call if the number of arguments
     * to the function are fewer than its dimensionality and a
     * placeholder (&quot;_&quot;) appears in its argument list. Defining a
     * function to equal an expression containing implicit variables
     * similarly appends those implicit variables, in the same order,
     * to the left-hand-side of the definition where the placeholder
     * (&apos;_&apos;) appears.
     *
     * For example, consider the definition:
     *
     \code
     Func f, g;
     Var x, y;
     f(x, y) = 3;
     \endcode
     *
     * A call to f with the placeholder symbol _
     * will have implicit arguments injected automatically, so f(2, _)
     * is equivalent to f(2, _0), where _0 = ImplicitVar&lt;0&gt;(), and f(_)
     * (and indeed f when cast to an Expr) is equivalent to f(_0, _1).
     * The following definitions are all equivalent, differing only in the
     * variable names.
     *
     \code
     g(_) = f*3;
     g(_) = f(_)*3;
     g(x, _) = f(x, _)*3;
     g(x, y) = f(x, y)*3;
     \endcode
     *
     * These are expanded internally as follows:
     *
     \code
     g(_0, _1) = f(_0, _1)*3;
     g(_0, _1) = f(_0, _1)*3;
     g(x, _0) = f(x, _0)*3;
     g(x, y) = f(x, y)*3;
     \endcode
     *
     * The following, however, defines g as four dimensional:
     \code
     g(x, y, _) = f*3;
     \endcode
     *
     * It is equivalent to:
     *
     \code
     g(x, y, _0, _1) = f(_0, _1)*3;
     \endcode
     *
     * Expressions requiring differing numbers of implicit variables
     * can be combined. The left-hand-side of a definition injects
     * enough implicit variables to cover all of them:
     *
     \code
     Func h;
     h(x) = x*3;
     g(x) = h + (f + f(x)) * f(x, y);
     \endcode
     *
     * expands to:
     *
     \code
     Func h;
     h(x) = x*3;
     g(x, _0, _1) = h(_0) + (f(_0, _1) + f(x, _0)) * f(x, y);
     \endcode
     *
     * The first ten implicits, _0 through _9, are predeclared in this
     * header and can be used for scheduling. They should never be
     * used as arguments in a declaration or used in a call.
     *
     * While it is possible to use Var::implicit or the predeclared
     * implicits to create expressions that can be treated as small
     * anonymous functions (e.g. Func(_0 + _1)) this is considered
     * poor style. Instead use \ref lambda.
     */</doc>
<use f='halide/python_bindings/src/PyVar.cpp' l='28' u='a' c='_ZN6Halide14PythonBindings10define_varERN8pybind117module_E'/>
<dec f='halide/src/Var.h' l='120' type='static Halide::Var Halide::Var::implicit(int n)'/>
<use f='halide/src/Var.h' l='172' u='c' c='_ZNK6Halide11ImplicitVar6to_varEv'/>
<doc f='halide/src/Var.h' l='42'>/** Implicit var constructor. Implicit variables are injected
     * automatically into a function call if the number of arguments
     * to the function are fewer than its dimensionality and a
     * placeholder (&quot;_&quot;) appears in its argument list. Defining a
     * function to equal an expression containing implicit variables
     * similarly appends those implicit variables, in the same order,
     * to the left-hand-side of the definition where the placeholder
     * (&apos;_&apos;) appears.
     *
     * For example, consider the definition:
     *
     \code
     Func f, g;
     Var x, y;
     f(x, y) = 3;
     \endcode
     *
     * A call to f with the placeholder symbol _
     * will have implicit arguments injected automatically, so f(2, _)
     * is equivalent to f(2, _0), where _0 = ImplicitVar&lt;0&gt;(), and f(_)
     * (and indeed f when cast to an Expr) is equivalent to f(_0, _1).
     * The following definitions are all equivalent, differing only in the
     * variable names.
     *
     \code
     g(_) = f*3;
     g(_) = f(_)*3;
     g(x, _) = f(x, _)*3;
     g(x, y) = f(x, y)*3;
     \endcode
     *
     * These are expanded internally as follows:
     *
     \code
     g(_0, _1) = f(_0, _1)*3;
     g(_0, _1) = f(_0, _1)*3;
     g(x, _0) = f(x, _0)*3;
     g(x, y) = f(x, y)*3;
     \endcode
     *
     * The following, however, defines g as four dimensional:
     \code
     g(x, y, _) = f*3;
     \endcode
     *
     * It is equivalent to:
     *
     \code
     g(x, y, _0, _1) = f(_0, _1)*3;
     \endcode
     *
     * Expressions requiring differing numbers of implicit variables
     * can be combined. The left-hand-side of a definition injects
     * enough implicit variables to cover all of them:
     *
     \code
     Func h;
     h(x) = x*3;
     g(x) = h + (f + f(x)) * f(x, y);
     \endcode
     *
     * expands to:
     *
     \code
     Func h;
     h(x) = x*3;
     g(x, _0, _1) = h(_0) + (f(_0, _1) + f(x, _0)) * f(x, y);
     \endcode
     *
     * The first ten implicits, _0 through _9, are predeclared in this
     * header and can be used for scheduling. They should never be
     * used as arguments in a declaration or used in a call.
     *
     * While it is possible to use Var::implicit or the predeclared
     * implicits to create expressions that can be treated as small
     * anonymous functions (e.g. Func(_0 + _1)) this is considered
     * poor style. Instead use \ref lambda.
     */</doc>
<use f='halide/src/Buffer.cpp' l='29' u='c' c='_ZN6Halide8Internal15buffer_accessorERKNS_6BufferIvEERKSt6vectorINS_4ExprESaIS6_EE'/>
<use f='halide/src/Func.cpp' l='239' u='c' c='_ZNK6Halide4Func17add_implicit_varsERSt6vectorINS_3VarESaIS2_EE'/>
<use f='halide/src/Func.cpp' l='270' u='c' c='_ZNK6Halide4Func17add_implicit_varsERSt6vectorINS_4ExprESaIS2_EE'/>
<use f='halide/src/Func.cpp' l='2811' u='c' c='_ZNK6Halide7FuncRef23args_with_implicit_varsERKSt6vectorINS_4ExprESaIS2_EE'/>
<use f='halide/src/Func.cpp' l='2819' u='c' c='_ZNK6Halide7FuncRef23args_with_implicit_varsERKSt6vectorINS_4ExprESaIS2_EE'/>
<use f='halide/src/Generator.cpp' l='112' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_115make_param_funcERKNS0_9ParameterERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE'/>
<use f='halide/src/Generator.cpp' l='1622' u='c' c='_ZN6Halide8Internal13GeneratorBase21build_gradient_moduleERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE'/>
<use f='halide/src/ImageParam.cpp' l='29' u='c' c='_ZNK6Halide10ImageParam11create_funcEv'/>
<use f='halide/src/ImageParam.cpp' l='30' u='c' c='_ZNK6Halide10ImageParam11create_funcEv'/>
<def f='halide/src/Var.cpp' l='15' ll='17' type='static Halide::Var Halide::Var::implicit(int n)'/>
<use f='halide/src/Var.cpp' l='32' u='c' c='_ZN6Halide8Internal18make_argument_listEi'/>
