<dec f='halide/build/include/Halide.h' l='6978' type='void Halide::Internal::match_types(Halide::Expr &amp; a, Halide::Expr &amp; b)'/>
<doc f='halide/build/include/Halide.h' l='6954'>/** Coerce the two expressions to have the same type, using C-style
 * casting rules. For the purposes of casting, a boolean type is
 * UInt(1). We use the following procedure:
 *
 * If the types already match, do nothing.
 *
 * Then, if one type is a vector and the other is a scalar, the scalar
 * is broadcast to match the vector width, and we continue.
 *
 * Then, if one type is floating-point and the other is not, the
 * non-float is cast to the floating-point type, and we&apos;re done.
 *
 * Then, if both types are unsigned ints, the one with fewer bits is
 * cast to match the one with more bits and we&apos;re done.
 *
 * Then, if both types are signed ints, the one with fewer bits is
 * cast to match the one with more bits and we&apos;re done.
 *
 * Finally, if one type is an unsigned int and the other type is a signed
 * int, both are cast to a signed int with the greater of the two
 * bit-widths. For example, matching an Int(8) with a UInt(16) results
 * in an Int(16).
 *
 */</doc>
<dec f='halide/src/IROperator.h' l='173' type='void Halide::Internal::match_types(Halide::Expr &amp; a, Halide::Expr &amp; b)'/>
<doc f='halide/src/IROperator.h' l='149'>/** Coerce the two expressions to have the same type, using C-style
 * casting rules. For the purposes of casting, a boolean type is
 * UInt(1). We use the following procedure:
 *
 * If the types already match, do nothing.
 *
 * Then, if one type is a vector and the other is a scalar, the scalar
 * is broadcast to match the vector width, and we continue.
 *
 * Then, if one type is floating-point and the other is not, the
 * non-float is cast to the floating-point type, and we&apos;re done.
 *
 * Then, if both types are unsigned ints, the one with fewer bits is
 * cast to match the one with more bits and we&apos;re done.
 *
 * Then, if both types are signed ints, the one with fewer bits is
 * cast to match the one with more bits and we&apos;re done.
 *
 * Finally, if one type is an unsigned int and the other type is a signed
 * int, both are cast to a signed int with the greater of the two
 * bit-widths. For example, matching an Int(8) with a UInt(16) results
 * in an Int(16).
 *
 */</doc>
<def f='halide/src/IROperator.cpp' l='621' ll='668' type='void Halide::Internal::match_types(Halide::Expr &amp; a, Halide::Expr &amp; b)'/>
<use f='halide/src/IROperator.cpp' l='1069' u='c' c='_ZN6Halide8Internal12widening_addENS_4ExprES1_'/>
<use f='halide/src/IROperator.cpp' l='1088' u='c' c='_ZN6Halide8Internal12widening_subENS_4ExprES1_'/>
<use f='halide/src/IROperator.cpp' l='1179' u='c' c='_ZN6Halide8Internal14saturating_addENS_4ExprES1_'/>
<use f='halide/src/IROperator.cpp' l='1186' u='c' c='_ZN6Halide8Internal14saturating_subENS_4ExprES1_'/>
<use f='halide/src/IROperator.cpp' l='1193' u='c' c='_ZN6Halide8Internal11halving_addENS_4ExprES1_'/>
<use f='halide/src/IROperator.cpp' l='1200' u='c' c='_ZN6Halide8Internal20rounding_halving_addENS_4ExprES1_'/>
<use f='halide/src/IROperator.cpp' l='1207' u='c' c='_ZN6Halide8Internal11halving_subENS_4ExprES1_'/>
<use f='halide/src/IROperator.cpp' l='1214' u='c' c='_ZN6Halide8Internal20rounding_halving_subENS_4ExprES1_'/>
<use f='halide/src/IROperator.cpp' l='1222' u='c' c='_ZN6Halide8Internal15mul_shift_rightENS_4ExprES1_S1_'/>
<use f='halide/src/IROperator.cpp' l='1226' u='c' c='_ZN6Halide8Internal15mul_shift_rightENS_4ExprES1_S1_'/>
<use f='halide/src/IROperator.cpp' l='1241' u='c' c='_ZN6Halide8Internal24rounding_mul_shift_rightENS_4ExprES1_S1_'/>
<use f='halide/src/IROperator.cpp' l='1245' u='c' c='_ZN6Halide8Internal24rounding_mul_shift_rightENS_4ExprES1_S1_'/>
<use f='halide/src/IROperator.cpp' l='1537' u='c' c='_ZN6HalideplENS_4ExprES0_'/>
<use f='halide/src/IROperator.cpp' l='1564' u='c' c='_ZN6HalidemiENS_4ExprES0_'/>
<use f='halide/src/IROperator.cpp' l='1597' u='c' c='_ZN6HalidemlENS_4ExprES0_'/>
<use f='halide/src/IROperator.cpp' l='1624' u='c' c='_ZN6HalidedvENS_4ExprES0_'/>
<use f='halide/src/IROperator.cpp' l='1651' u='c' c='_ZN6HalidermENS_4ExprES0_'/>
<use f='halide/src/IROperator.cpp' l='1671' u='c' c='_ZN6HalidegtENS_4ExprES0_'/>
<use f='halide/src/IROperator.cpp' l='1691' u='c' c='_ZN6HalideltENS_4ExprES0_'/>
<use f='halide/src/IROperator.cpp' l='1711' u='c' c='_ZN6HalideleENS_4ExprES0_'/>
<use f='halide/src/IROperator.cpp' l='1731' u='c' c='_ZN6HalidegeENS_4ExprES0_'/>
<use f='halide/src/IROperator.cpp' l='1751' u='c' c='_ZN6HalideeqENS_4ExprES0_'/>
<use f='halide/src/IROperator.cpp' l='1771' u='c' c='_ZN6HalideneENS_4ExprES0_'/>
<use f='halide/src/IROperator.cpp' l='1790' u='c' c='_ZN6HalideaaENS_4ExprES0_'/>
<use f='halide/src/IROperator.cpp' l='1809' u='c' c='_ZN6HalideooENS_4ExprES0_'/>
<use f='halide/src/IROperator.cpp' l='1834' u='c' c='_ZN6Halide3maxENS_4ExprES0_'/>
<use f='halide/src/IROperator.cpp' l='1855' u='c' c='_ZN6Halide3minENS_4ExprES0_'/>
<use f='halide/src/IROperator.cpp' l='1941' u='c' c='_ZN6Halide4absdENS_4ExprES0_'/>
<use f='halide/src/IROperator.cpp' l='2498' u='c' c='_ZN6Halide17div_round_to_zeroENS_4ExprES0_'/>
<use f='halide/src/IROperator.cpp' l='2513' u='c' c='_ZN6Halide17mod_round_to_zeroENS_4ExprES0_'/>
