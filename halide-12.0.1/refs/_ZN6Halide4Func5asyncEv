<dec f='halide/build/include/Halide.h' l='18129' type='Halide::Func &amp; Halide::Func::async()'/>
<doc f='halide/build/include/Halide.h' l='18112'>/** Produce this Func asynchronously in a separate
     * thread. Consumers will be run by the task system when the
     * production is complete. If this Func&apos;s store level is different
     * to its compute level, consumers will be run concurrently,
     * blocking as necessary to prevent reading ahead of what the
     * producer has computed. If storage is folded, then the producer
     * will additionally not be permitted to run too far ahead of the
     * consumer, to avoid clobbering data that has not yet been
     * used.
     *
     * Take special care when combining this with custom thread pool
     * implementations, as avoiding deadlock with producer-consumer
     * parallelism requires a much more sophisticated parallel runtime
     * than with data parallelism alone. It is strongly recommended
     * you just use Halide&apos;s default thread pool, which guarantees no
     * deadlock and a bound on the number of threads launched.
     */</doc>
<use f='halide/python_bindings/src/PyFunc.cpp' l='206' u='a' c='_ZN6Halide14PythonBindings11define_funcERN8pybind117module_E'/>
<dec f='halide/src/Func.h' l='2249' type='Halide::Func &amp; Halide::Func::async()'/>
<doc f='halide/src/Func.h' l='2232'>/** Produce this Func asynchronously in a separate
     * thread. Consumers will be run by the task system when the
     * production is complete. If this Func&apos;s store level is different
     * to its compute level, consumers will be run concurrently,
     * blocking as necessary to prevent reading ahead of what the
     * producer has computed. If storage is folded, then the producer
     * will additionally not be permitted to run too far ahead of the
     * consumer, to avoid clobbering data that has not yet been
     * used.
     *
     * Take special care when combining this with custom thread pool
     * implementations, as avoiding deadlock with producer-consumer
     * parallelism requires a much more sophisticated parallel runtime
     * than with data parallelism alone. It is strongly recommended
     * you just use Halide&apos;s default thread pool, which guarantees no
     * deadlock and a bound on the number of threads launched.
     */</doc>
<def f='halide/src/Func.cpp' l='2164' ll='2168' type='Halide::Func &amp; Halide::Func::async()'/>
<use f='halide/test/generator/async_parallel_generator.cpp' l='30' u='c' c='_ZN13AsyncParallel8generateEv'/>
<use f='halide/test/generator/async_parallel_generator.cpp' l='31' u='c' c='_ZN13AsyncParallel8generateEv'/>
<use f='halide/test/generator/async_parallel_generator.cpp' l='32' u='c' c='_ZN13AsyncParallel8generateEv'/>
