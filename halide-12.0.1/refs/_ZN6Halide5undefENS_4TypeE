<dec f='halide/halide-install/include/Halide.h' l='8144' type='Halide::Expr Halide::undef(Halide::Type t)'/>
<doc f='halide/halide-install/include/Halide.h' l='8126'>/** Return an undef value of the given type. Halide skips stores that
 * depend on undef values, so you can use this to mean &quot;do not modify
 * this memory location&quot;. This is an escape hatch that can be used for
 * several things:
 *
 * You can define a reduction with no pure step, by setting the pure
 * step to undef. Do this only if you&apos;re confident that the update
 * steps are sufficient to correctly fill in the domain.
 *
 * For a tuple-valued reduction, you can write an update step that
 * only updates some tuple elements.
 *
 * You can define single-stage pipeline that only has update steps,
 * and depends on the values already in the output buffer.
 *
 * Use this feature with great caution, as you can use it to load from
 * uninitialized memory.
 */</doc>
<use f='halide/apps/fft/fft.cpp' l='40' u='c' c='_ZN12_GLOBAL__N_17undef_zEN6Halide4TypeE'/>
<use f='halide/apps/fft/fft.cpp' l='40' u='c' c='_ZN12_GLOBAL__N_17undef_zEN6Halide4TypeE'/>
<use f='halide/apps/hannk/halide/elementwise_generator.cpp' l='124' u='c' c='_ZN5hannk11Elementwise5buildEv'/>
<dec f='halide/build/include/Halide.h' l='8144' type='Halide::Expr Halide::undef(Halide::Type t)'/>
<doc f='halide/build/include/Halide.h' l='8126'>/** Return an undef value of the given type. Halide skips stores that
 * depend on undef values, so you can use this to mean &quot;do not modify
 * this memory location&quot;. This is an escape hatch that can be used for
 * several things:
 *
 * You can define a reduction with no pure step, by setting the pure
 * step to undef. Do this only if you&apos;re confident that the update
 * steps are sufficient to correctly fill in the domain.
 *
 * For a tuple-valued reduction, you can write an update step that
 * only updates some tuple elements.
 *
 * You can define single-stage pipeline that only has update steps,
 * and depends on the values already in the output buffer.
 *
 * Use this feature with great caution, as you can use it to load from
 * uninitialized memory.
 */</doc>
<use f='halide/python_bindings/src/PyIROperator.cpp' l='178' u='a' c='_ZN6Halide14PythonBindings16define_operatorsERN8pybind117module_E'/>
<dec f='halide/src/IROperator.h' l='1339' type='Halide::Expr Halide::undef(Halide::Type t)'/>
<doc f='halide/src/IROperator.h' l='1321'>/** Return an undef value of the given type. Halide skips stores that
 * depend on undef values, so you can use this to mean &quot;do not modify
 * this memory location&quot;. This is an escape hatch that can be used for
 * several things:
 *
 * You can define a reduction with no pure step, by setting the pure
 * step to undef. Do this only if you&apos;re confident that the update
 * steps are sufficient to correctly fill in the domain.
 *
 * For a tuple-valued reduction, you can write an update step that
 * only updates some tuple elements.
 *
 * You can define single-stage pipeline that only has update steps,
 * and depends on the values already in the output buffer.
 *
 * Use this feature with great caution, as you can use it to load from
 * uninitialized memory.
 */</doc>
<use f='halide/src/Func.cpp' l='3054' u='c' c='_ZNK6Halide19FuncTupleElementRef18values_with_undefsERKNS_4ExprE'/>
<use f='halide/src/Function.cpp' l='739' u='c' c='_ZN6Halide8Internal8Function13define_externERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorINS_18ExternFuncArgumentESaISB_EERKSA_INS7911120'/>
<def f='halide/src/IROperator.cpp' l='2585' ll='2589' type='Halide::Expr Halide::undef(Halide::Type t)'/>
<use f='halide/src/RemoveUndef.cpp' l='396' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_111RemoveUndef5visitEPKNS0_7ProvideE'/>
<use f='halide/src/Simplify_Exprs.cpp' l='344' u='c' c='_ZN6Halide8Internal8Simplify5visitEPKNS0_4LoadEPNS1_8ExprInfoE'/>
