<dec f='halide/build/include/Halide.h' l='8116' type='Halide::Expr Halide::require(Halide::Expr condition, const std::vector&lt;Expr&gt; &amp; values)'/>
<use f='halide/build/include/Halide.h' l='8122' u='c' c='_ZN6Halide7requireENS_4ExprES0_DpOT_'/>
<doc f='halide/build/include/Halide.h' l='8094'>/** Create an Expr that that guarantees a precondition.
 * If &apos;condition&apos; is true, the return value is equal to the first Expr.
 * If &apos;condition&apos; is false, halide_error() is called, and the return value
 * is arbitrary. Any additional arguments after the first Expr are stringified
 * and passed as a user-facing message to halide_error(), similar to print().
 *
 * Note that this essentially *always* inserts a runtime check into the
 * generated code (except when the condition can be proven at compile time);
 * as such, it should be avoided inside inner loops, except for debugging
 * or testing purposes. Note also that it does not vectorize cleanly (vector
 * values will be scalarized for the check).
 *
 * However, using this to make assertions about (say) input values
 * can be useful, both in terms of correctness and (potentially) in terms
 * of code generation, e.g.
 \code
 Param&lt;int&gt; p;
 Expr y = require(p &gt; 0, p);
 \endcode
 * will allow the optimizer to assume positive, nonzero values for y.
 */
// @{</doc>
<use f='halide/python_bindings/src/PyIROperator.cpp' l='163' u='c' c='_ZN6Halide14PythonBindings16define_operatorsERN8pybind117module_E'/>
<dec f='halide/src/IROperator.h' l='1311' type='Halide::Expr Halide::require(Halide::Expr condition, const std::vector&lt;Expr&gt; &amp; values)'/>
<use f='halide/src/IROperator.h' l='1317' u='c' c='_ZN6Halide7requireENS_4ExprES0_DpOT_'/>
<doc f='halide/src/IROperator.h' l='1289'>/** Create an Expr that that guarantees a precondition.
 * If &apos;condition&apos; is true, the return value is equal to the first Expr.
 * If &apos;condition&apos; is false, halide_error() is called, and the return value
 * is arbitrary. Any additional arguments after the first Expr are stringified
 * and passed as a user-facing message to halide_error(), similar to print().
 *
 * Note that this essentially *always* inserts a runtime check into the
 * generated code (except when the condition can be proven at compile time);
 * as such, it should be avoided inside inner loops, except for debugging
 * or testing purposes. Note also that it does not vectorize cleanly (vector
 * values will be scalarized for the check).
 *
 * However, using this to make assertions about (say) input values
 * can be useful, both in terms of correctness and (potentially) in terms
 * of code generation, e.g.
 \code
 Param&lt;int&gt; p;
 Expr y = require(p &gt; 0, p);
 \endcode
 * will allow the optimizer to assume positive, nonzero values for y.
 */
// @{</doc>
<def f='halide/src/IROperator.cpp' l='1386' ll='1397' type='Halide::Expr Halide::require(Halide::Expr condition, const std::vector&lt;Expr&gt; &amp; args)'/>
