<dec f='halide/src/autoschedulers/adams2019/Cache.h' l='120' type='bool Halide::Internal::Autoscheduler::Cache::add_memoized_blocks(const Halide::Internal::Autoscheduler::State * state, std::function&lt;void (IntrusivePtr&lt;State&gt; &amp;&amp;)&gt; &amp; accept_child, const FunctionDAG::Node * node, int &amp; num_children, const Halide::Internal::Autoscheduler::FunctionDAG &amp; dag, const Halide::MachineParams &amp; params, Halide::CostModel * cost_model, int64_t memory_limit) const'/>
<doc f='halide/src/autoschedulers/adams2019/Cache.h' l='117'>// check if we generated tilings for the current func on a previous pass
    // if so, add them and return true.
    // otherwise, return false (also return false if memoization is turned off).</doc>
<def f='halide/src/autoschedulers/adams2019/Cache.cpp' l='17' ll='81' type='bool Halide::Internal::Autoscheduler::Cache::add_memoized_blocks(const Halide::Internal::Autoscheduler::State * state, std::function&lt;void (IntrusivePtr&lt;State&gt; &amp;&amp;)&gt; &amp; accept_child, const FunctionDAG::Node * node, int &amp; num_children, const Halide::Internal::Autoscheduler::FunctionDAG &amp; dag, const Halide::MachineParams &amp; params, Halide::CostModel * cost_model, int64_t memory_limit) const'/>
<use f='halide/src/autoschedulers/adams2019/State.cpp' l='387' u='c' c='_ZNK6Halide8Internal13Autoscheduler5State17generate_childrenERKNS1_11FunctionDAGERKNS_13MachineParamsEPNS_9CostModelElRSt8functionIFvONS0_12IntrusiveP11683623'/>
