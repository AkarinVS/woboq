<dec f='halide/build-apps/eigen/Eigen/src/SVD/BDCSVD.h' l='182' type='void Eigen::BDCSVD::computeSVDofM(Eigen::Index firstCol, Eigen::Index n, Eigen::BDCSVD::MatrixXr &amp; U, Eigen::BDCSVD::VectorType &amp; singVals, Eigen::BDCSVD::MatrixXr &amp; V)'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/BDCSVD.h' l='540' u='c' c='_ZN5Eigen6BDCSVD6divideElllll'/>
<def f='halide/build-apps/eigen/Eigen/src/SVD/BDCSVD.h' l='576' ll='702' type='void Eigen::BDCSVD::computeSVDofM(Eigen::Index firstCol, Eigen::Index n, Eigen::BDCSVD::MatrixXr &amp; U, Eigen::BDCSVD::VectorType &amp; singVals, Eigen::BDCSVD::MatrixXr &amp; V)'/>
<doc f='halide/build-apps/eigen/Eigen/src/SVD/BDCSVD.h' l='568'>// Compute SVD of m_computed.block(firstCol, firstCol, n + 1, n); this block only has non-zeros in
// the first column and on the diagonal and has undergone deflation, so diagonal is in increasing
// order except for possibly the (0,0) entry. The computed SVD is stored U, singVals and V, except
// that if m_compV is false, then V is not computed. Singular values are sorted in decreasing order.
//
// TODO Opportunities for optimization: better root finding algo, better stopping criterion, better
// handling of round-off errors, be consistent in ordering
// For instance, to solve the secular equation using FMM, see http://www.stat.uchicago.edu/~lekheng/courses/302/classics/greengard-rokhlin.pdf</doc>
