<dec f='halide/build-apps/abseil-cpp/absl/time/time.h' l='1316' type='bool absl::lts_2020_02_25::ParseTime(const std::string &amp; format, const std::string &amp; input, absl::lts_2020_02_25::Time * time, std::string * err)'/>
<doc f='halide/build-apps/abseil-cpp/absl/time/time.h' l='1268'>// ParseTime()
//
// Parses an input string according to the provided format string and
// returns the corresponding `absl::Time`. Uses strftime()-like formatting
// options, with the same extensions as FormatTime(), but with the
// exceptions that %E#S is interpreted as %E*S, and %E#f as %E*f.  %Ez
// and %E*z also accept the same inputs.
//
// %Y consumes as many numeric characters as it can, so the matching data
// should always be terminated with a non-numeric.  %E4Y always consumes
// exactly four characters, including any sign.
//
// Unspecified fields are taken from the default date and time of ...
//
//   &quot;1970-01-01 00:00:00.0 +0000&quot;
//
// For example, parsing a string of &quot;15:45&quot; (%H:%M) will return an absl::Time
// that represents &quot;1970-01-01 15:45:00.0 +0000&quot;.
//
// Note that since ParseTime() returns time instants, it makes the most sense
// to parse fully-specified date/time strings that include a UTC offset (%z,
// %Ez, or %E*z).
//
// Note also that `absl::ParseTime()` only heeds the fields year, month, day,
// hour, minute, (fractional) second, and UTC offset.  Other fields, like
// weekday (%a or %A), while parsed for syntactic validity, are ignored
// in the conversion.
//
// Date and time fields that are out-of-range will be treated as errors
// rather than normalizing them like `absl::CivilSecond` does.  For example,
// it is an error to parse the date &quot;Oct 32, 2013&quot; because 32 is out of range.
//
// A leap second of &quot;:60&quot; is normalized to &quot;:00&quot; of the following minute
// with fractional seconds discarded.  The following table shows how the
// given seconds and subseconds will be parsed:
//
//   &quot;59.x&quot; -&gt; 59.x  // exact
//   &quot;60.x&quot; -&gt; 00.0  // normalized
//   &quot;00.x&quot; -&gt; 00.x  // exact
//
// Errors are indicated by returning false and assigning an error message
// to the &quot;err&quot; out param if it is non-null.
//
// Note: If the input string is exactly &quot;infinite-future&quot;, the returned
// `absl::Time` will be `absl::InfiniteFuture()` and `true` will be returned.
// If the input string is &quot;infinite-past&quot;, the returned `absl::Time` will be
// `absl::InfinitePast()` and `true` will be returned.
//</doc>
<def f='halide/build-apps/abseil-cpp/absl/time/format.cc' l='91' ll='94' type='bool absl::lts_2020_02_25::ParseTime(const std::string &amp; format, const std::string &amp; input, absl::Time * time, std::string * err)'/>
