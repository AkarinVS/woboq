<use f='halide/build-apps/gemmlowp/internal/multi_thread_gemm.h' l='232' u='w' c='_ZN8gemmlowp6WorkerC1EPNS_15BlockingCounterE'/>
<use f='halide/build-apps/gemmlowp/internal/multi_thread_gemm.h' l='255' u='m' c='_ZN8gemmlowp6Worker11ChangeStateENS0_5StateEPNS_4TaskE'/>
<use f='halide/build-apps/gemmlowp/internal/multi_thread_gemm.h' l='288' u='m' c='_ZN8gemmlowp6Worker11ChangeStateENS0_5StateEPNS_4TaskE'/>
<use f='halide/build-apps/gemmlowp/internal/multi_thread_gemm.h' l='308' u='a' c='_ZN8gemmlowp6Worker10ThreadFuncEv'/>
<dec f='halide/build-apps/gemmlowp/internal/multi_thread_gemm.h' l='347' type='std::atomic&lt;State&gt;'/>
<offset>832</offset>
<doc f='halide/build-apps/gemmlowp/internal/multi_thread_gemm.h' l='343'>// The state enum tells if we&apos;re currently working, waiting for work, etc.
  // Its concurrent accesses by the worker and main threads are guarded by
  // state_mutex_, and can thus use memory_order_relaxed. This still needs
  // to be a std::atomic because we use WaitForVariableChange.</doc>
