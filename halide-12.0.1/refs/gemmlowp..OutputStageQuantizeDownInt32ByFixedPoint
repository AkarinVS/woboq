<def f='halide/build-apps/gemmlowp/public/output_stages.h' l='115' ll='119'/>
<use f='halide/build-apps/gemmlowp/public/output_stages.h' l='124'/>
<use f='halide/build-apps/gemmlowp/internal/output.h' l='123'/>
<use f='halide/build-apps/gemmlowp/internal/output.h' l='128'/>
<size>12</size>
<doc f='halide/build-apps/gemmlowp/public/output_stages.h' l='68'>// This output stage takes int32 values and returns still int32 values,
// but &quot;quantized down&quot; to a difference scale; for example, in a pipeline
// that outputs uint8 values in [0..255], the output of this stage would be
// int32 values ready to be clamped to [0..255] and casted to uint8
// (see OutputStageSaturatingCastToUint8).
//
// This &quot;quantization down&quot; process depends on 3 parameters,
//   result_offset, result_fixedpoint_multiplier, result_shift,
// and the result is:
//   ((FixedPointMul(input, result_fixedpoint_multiplier) +
//   rounding) &gt;&gt; result_shift) + result_offset_after_shift
// where
//   rounding = (result_shift &lt; 1) ? 0 : (1 &lt;&lt; (result_shift - 1));
// and where FixedPointMul(x, y) is the nearest integer to the following
// mathematical expression, evaluated without overflow or intermediate
// rounding:
//   (x * y) / 2^31
// In practice, it is expected that FixedPointMul will be implemented
// using hardware &quot;rounding doubling int32 multiply high&quot; instructions,
// such as VQRDMULH on ARM. See in fixedpoint.h the generic function,
// SaturatingRoundingDoublingHighMul.
//
// Notice that the other difference from
// OutputStageQuantizeDownInt32ToUint8Scale is that the result offset
// is applied after the multiplier and shift, not before. This ensures
// that no matter what the multiplier and shift are, the result offset
// is effectively integral: offsetting the final result by an integer.
// The motivation for this is to faithfully support quantization schemes
// where the formula linking quantized values to the real mathematical
// values that they represent, is of the form
//
//   real_value = scale * (quantized_value - zero_point)
//
// where scale is a real number (represented in quantized form by
// result_fixedpoint_multiplier and result_shift) and zero_point
// is an integer telling which quantized value correspond to the
// real value 0, and is represented here by (the opposite of)
// result_offset_after_shift.
// The motivation for such a quantization scheme, designed to
// ensure that 0 is always a representable value, is that in
// many applications, we need to 0-pad arrays and that can only be
// done for quantized arrays if 0 is a representable value in
// quantized form. In particular, convolution-like operations
// are often implemented using 0-padding, or &quot;im2col&quot;-like
// expansions that implicitly rely on 0-padding. If 0 were not
// a representable value, such operations would have to pad
// using a nonzero value, introducing bias in the computation.</doc>
<mbr r='gemmlowp::OutputStageQuantizeDownInt32ByFixedPoint::result_fixedpoint_multiplier' o='0' t='std::int32_t'/>
<mbr r='gemmlowp::OutputStageQuantizeDownInt32ByFixedPoint::result_shift' o='32' t='std::int32_t'/>
<mbr r='gemmlowp::OutputStageQuantizeDownInt32ByFixedPoint::result_offset_after_shift' o='64' t='std::int32_t'/>
