<dec f='halide/build-apps/ruy/ruy/wait.h' l='63' type='void ruy::Wait(const std::function&lt;bool ()&gt; &amp; condition, const ruy::Duration &amp; spin_duration, std::condition_variable * condvar, std::mutex * mutex)'/>
<use f='halide/build-apps/ruy/ruy/blocking_counter.cc' l='46' u='c' c='_ZN3ruy15BlockingCounter4WaitENSt6chrono8durationIlSt5ratioILl1ELl1000000000EEEE'/>
<doc f='halide/build-apps/ruy/ruy/wait.h' l='27'>// Waits until some evaluation of `condition` has returned true.
//
// There is no guarantee that calling `condition` again after this function
// has returned would still return true. The only
// contract is that at some point during the execution of that function,
// `condition` has returned true.
//
// First does some spin-waiting for the specified `spin_duration`,
// then falls back to passive waiting for the given condvar, guarded
// by the given mutex. At this point it will try to acquire the mutex lock,
// around the waiting on the condition variable.
// Therefore, this function expects that the calling thread hasn&apos;t already
// locked the mutex before calling it.
// This function will always release the mutex lock before returning.
//
// The idea of doing some initial spin-waiting is to help get
// better and more consistent multithreading benefits for small GEMM sizes.
// Spin-waiting help ensuring that if we need to wake up soon after having
// started waiting, then we can wake up quickly (as opposed to, say,
// having to wait to be scheduled again by the OS). On the other hand,
// we must still eventually revert to passive waiting for longer waits
// (e.g. worker threads having finished a GEMM and waiting until the next GEMM)
// so as to avoid permanently spinning.
//
// In situations where other threads might have more useful things to do with
// these CPU cores than our spin-waiting, it may be best to reduce the value
// of `spin_duration`. Setting it to zero disables the spin-waiting entirely.
//
// There is a risk that the std::function used here might use a heap allocation
// to store its context. The expected usage pattern is that these functions&apos;
// contexts will consist of a single pointer value (typically capturing only
// [this]), and that in this case the std::function implementation will use
// inline storage, avoiding a heap allocation. However, we can&apos;t effectively
// guard that assumption, and that&apos;s not a big concern anyway because the
// latency of a small heap allocation is probably low compared to the intrinsic
// latency of what this Wait function does.</doc>
<use f='halide/build-apps/ruy/ruy/thread_pool.cc' l='129' u='c' c='_ZN3ruy6Thread14ThreadFuncImplEv'/>
<def f='halide/build-apps/ruy/ruy/wait.cc' l='22' ll='42' type='void ruy::Wait(const std::function&lt;bool ()&gt; &amp; condition, const ruy::Duration &amp; spin_duration, std::condition_variable * condvar, std::mutex * mutex)'/>
