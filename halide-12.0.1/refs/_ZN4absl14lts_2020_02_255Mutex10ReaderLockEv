<dec f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='229' type='void absl::lts_2020_02_25::Mutex::ReaderLock()'/>
<use f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='563' u='c' c='_ZN4absl14lts_2020_02_2515ReaderMutexLockC1EPNS0_5MutexE'/>
<doc f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.h' l='190'>// ---------------------------------------------------------------------------
  // Reader-Writer Locking
  // ---------------------------------------------------------------------------

  // A Mutex can also be used as a starvation-free reader-writer lock.
  // Neither read-locks nor write-locks are reentrant/recursive to avoid
  // potential client programming errors.
  //
  // The Mutex API provides `Writer*()` aliases for the existing `Lock()`,
  // `Unlock()` and `TryLock()` methods for use within applications mixing
  // reader/writer locks. Using `Reader*()` and `Writer*()` operations in this
  // manner can make locking behavior clearer when mixing read and write modes.
  //
  // Introducing reader locks necessarily complicates the `Mutex` state
  // machine somewhat. The table below illustrates the allowed state transitions
  // of a mutex in such cases. Note that ReaderLock() may block even if the lock
  // is held in shared mode; this occurs when another thread is blocked on a
  // call to WriterLock().
  //
  // ---------------------------------------------------------------------------
  //     Operation: WriterLock() Unlock()  ReaderLock()           ReaderUnlock()
  // ---------------------------------------------------------------------------
  // State
  // ---------------------------------------------------------------------------
  // Free           Exclusive    invalid   Shared(1)              invalid
  // Shared(1)      blocks       invalid   Shared(2) or blocks    Free
  // Shared(n) n&gt;1  blocks       invalid   Shared(n+1) or blocks  Shared(n-1)
  // Exclusive      blocks       Free      blocks                 invalid
  // ---------------------------------------------------------------------------
  //
  // In comments below, &quot;shared&quot; refers to a state of Shared(n) for any n &gt; 0.

  // Mutex::ReaderLock()
  //
  // Blocks the calling thread, if necessary, until this `Mutex` is either free,
  // or in shared mode, and then acquires a share of it. Note that
  // `ReaderLock()` will block if some other thread has an exclusive/writer lock
  // on the mutex.</doc>
<def f='halide/build-apps/abseil-cpp/absl/synchronization/mutex.cc' l='1476' ll='1489' type='void absl::lts_2020_02_25::Mutex::ReaderLock()'/>
