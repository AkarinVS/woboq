<def f='halide/build/include/Halide.h' l='8485' ll='8528'/>
<use f='halide/build/include/Halide.h' l='8535' c='_ZN6Halide8Internal19prove_associativityERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorINS_4ExprESaISA_EESC_'/>
<use f='halide/build/include/Halide.h' l='18995' c='_ZN6Halide8InternallsERSoRKNS0_13AssociativeOpE'/>
<size>112</size>
<doc f='halide/build/include/Halide.h' l='8442'>/**
 * Represent the equivalent associative op of an update definition.
 * For example, the following associative Expr, min(f(x), g(r.x) + 2),
 * where f(x) is the self-recurrence term, is represented as:
 \code
 AssociativeOp assoc(
    AssociativePattern(min(x, y), +inf, true),
    {Replacement(&quot;x&quot;, f(x))},
    {Replacement(&quot;y&quot;, g(r.x) + 2)},
    true
 );
 \endcode
 *
 * &apos;pattern&apos; contains the list of equivalent binary/unary operators (+ identities)
 * for each Tuple element in the update definition. &apos;pattern&apos; also contains
 * a boolean that indicates if the op is also commutative. &apos;xs&apos; and &apos;ys&apos;
 * contain the corresponding definition of each variable in the list of
 * binary operators.
 *
 * For unary operator, &apos;xs&apos; is not set, i.e. it will be a pair of empty string
 * and undefined Expr: {&quot;&quot;, Expr()}. &apos;pattern&apos; will only contain the &apos;y&apos; term in
 * this case. For example, min(g(r.x), 4), will be represented as:
 \code
 AssociativeOp assoc(
    AssociativePattern(y, 0, false),
    {Replacement(&quot;&quot;, Expr())},
    {Replacement(&quot;y&quot;, min(g(r.x), 4))},
    true
 );
 \endcode
 *
 * Self-assignment, f(x) = f(x), will be represented as:
 \code
 AssociativeOp assoc(
    AssociativePattern(x, 0, true),
    {Replacement(&quot;x&quot;, f(x))},
    {Replacement(&quot;&quot;, Expr())},
    true
 );
 \endcode
 * For both unary operator and self-assignment cases, the identity does not
 * matter. It can be anything.
 */</doc>
<mbr r='Halide::Internal::AssociativeOp::pattern' o='0' t='Halide::Internal::AssociativePattern'/>
<mbr r='Halide::Internal::AssociativeOp::xs' o='448' t='std::vector&lt;Replacement&gt;'/>
<mbr r='Halide::Internal::AssociativeOp::ys' o='640' t='std::vector&lt;Replacement&gt;'/>
<mbr r='Halide::Internal::AssociativeOp::is_associative' o='832' t='bool'/>
<fun r='_ZN6Halide8Internal13AssociativeOpC1Ev'/>
<fun r='_ZN6Halide8Internal13AssociativeOpC1Em'/>
<fun r='_ZN6Halide8Internal13AssociativeOpC1ERKNS0_18AssociativePatternERKSt6vectorINS1_11ReplacementESaIS6_EESA_b'/>
<fun r='_ZNK6Halide8Internal13AssociativeOp11associativeEv'/>
<fun r='_ZNK6Halide8Internal13AssociativeOp11commutativeEv'/>
<fun r='_ZNK6Halide8Internal13AssociativeOp4sizeEv'/>
<use f='halide/src/IRPrinter.h' l='64' c='_ZN6Halide8InternallsERSoRKNS0_13AssociativeOpE'/>
<def f='halide/src/Associativity.h' l='61' ll='104'/>
<use f='halide/src/Associativity.h' l='111' c='_ZN6Halide8Internal19prove_associativityERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorINS_4ExprESaISA_EESC_'/>
<use f='halide/src/Associativity.cpp' l='162' c='_ZN6Halide8Internal12_GLOBAL__N_110find_matchERKSt6vectorINS0_18AssociativePatternESaIS3_EERKS2_INSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES5124669'/>
<use f='halide/src/Associativity.cpp' l='232' c='_ZN6Halide8Internal12_GLOBAL__N_122extract_associative_opERKSt6vectorINS_4ExprESaIS3_EERKS2_INSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISD16051797'/>
<use f='halide/src/Associativity.cpp' l='321' c='_ZN6Halide8Internal19prove_associativityERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorINS_4ExprESaISA_EESC_'/>
<use f='halide/src/Associativity.cpp' l='322' c='_ZN6Halide8Internal19prove_associativityERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorINS_4ExprESaISA_EESC_'/>
<use f='halide/src/Associativity.cpp' l='352' c='_ZN6Halide8Internal19prove_associativityERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorINS_4ExprESaISA_EESC_'/>
<use f='halide/src/Associativity.cpp' l='393' c='_ZN6Halide8Internal19prove_associativityERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorINS_4ExprESaISA_EESC_'/>
<use f='halide/src/Associativity.cpp' l='400' c='_ZN6Halide8Internal19prove_associativityERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorINS_4ExprESaISA_EESC_'/>
<use f='halide/src/Associativity.cpp' l='412' c='_ZN6Halide8Internal19prove_associativityERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorINS_4ExprESaISA_EESC_'/>
<use f='halide/src/Associativity.cpp' l='427' c='_ZN6Halide8Internal19prove_associativityERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorINS_4ExprESaISA_EESC_'/>
<use f='halide/src/Associativity.cpp' l='433' c='_ZN6Halide8Internal19prove_associativityERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorINS_4ExprESaISA_EESC_'/>
<use f='halide/src/Associativity.cpp' l='439' c='_ZN6Halide8Internal19prove_associativityERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorINS_4ExprESaISA_EESC_'/>
<use f='halide/src/Associativity.cpp' l='486' c='_ZN6Halide8Internal12_GLOBAL__N_119check_associativityERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorINS_4ExprESaISB_EESF_RKNS0_13AssociativeOpE'/>
<use f='halide/src/Associativity.cpp' l='551' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='559' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='567' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='575' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='592' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='600' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='619' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='627' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='635' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='643' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='650' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='654' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='662' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='670' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='679' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='710' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='720' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='730' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='741' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='752' c='_ZN6Halide8Internal18associativity_testEv'/>
<use f='halide/src/Associativity.cpp' l='793' c='_ZN6Halide8Internal18associativity_testEv'/>
<size>112</size>
<doc f='halide/src/Associativity.h' l='18'>/**
 * Represent the equivalent associative op of an update definition.
 * For example, the following associative Expr, min(f(x), g(r.x) + 2),
 * where f(x) is the self-recurrence term, is represented as:
 \code
 AssociativeOp assoc(
    AssociativePattern(min(x, y), +inf, true),
    {Replacement(&quot;x&quot;, f(x))},
    {Replacement(&quot;y&quot;, g(r.x) + 2)},
    true
 );
 \endcode
 *
 * &apos;pattern&apos; contains the list of equivalent binary/unary operators (+ identities)
 * for each Tuple element in the update definition. &apos;pattern&apos; also contains
 * a boolean that indicates if the op is also commutative. &apos;xs&apos; and &apos;ys&apos;
 * contain the corresponding definition of each variable in the list of
 * binary operators.
 *
 * For unary operator, &apos;xs&apos; is not set, i.e. it will be a pair of empty string
 * and undefined Expr: {&quot;&quot;, Expr()}. &apos;pattern&apos; will only contain the &apos;y&apos; term in
 * this case. For example, min(g(r.x), 4), will be represented as:
 \code
 AssociativeOp assoc(
    AssociativePattern(y, 0, false),
    {Replacement(&quot;&quot;, Expr())},
    {Replacement(&quot;y&quot;, min(g(r.x), 4))},
    true
 );
 \endcode
 *
 * Self-assignment, f(x) = f(x), will be represented as:
 \code
 AssociativeOp assoc(
    AssociativePattern(x, 0, true),
    {Replacement(&quot;x&quot;, f(x))},
    {Replacement(&quot;&quot;, Expr())},
    true
 );
 \endcode
 * For both unary operator and self-assignment cases, the identity does not
 * matter. It can be anything.
 */</doc>
<mbr r='Halide::Internal::AssociativeOp::pattern' o='0' t='Halide::Internal::AssociativePattern'/>
<mbr r='Halide::Internal::AssociativeOp::xs' o='448' t='std::vector&lt;Replacement&gt;'/>
<mbr r='Halide::Internal::AssociativeOp::ys' o='640' t='std::vector&lt;Replacement&gt;'/>
<mbr r='Halide::Internal::AssociativeOp::is_associative' o='832' t='bool'/>
<fun r='_ZN6Halide8Internal13AssociativeOpC1Ev'/>
<fun r='_ZN6Halide8Internal13AssociativeOpC1Em'/>
<fun r='_ZN6Halide8Internal13AssociativeOpC1ERKNS0_18AssociativePatternERKSt6vectorINS1_11ReplacementESaIS6_EESA_b'/>
<fun r='_ZNK6Halide8Internal13AssociativeOp11associativeEv'/>
<fun r='_ZNK6Halide8Internal13AssociativeOp11commutativeEv'/>
<fun r='_ZNK6Halide8Internal13AssociativeOp4sizeEv'/>
<use f='halide/src/Derivative.cpp' l='1528' c='_ZN6Halide8Internal12_GLOBAL__N_126ReverseAccumulationVisitor30propagate_halide_function_callENS_4ExprERKNSt7__cxx1112basic_stringIcSt11char_traitsIcE10448212'/>
<size>112</size>
<use f='halide/src/IRPrinter.cpp' l='238' c='_ZN6Halide8InternallsERSoRKNS0_13AssociativeOpE'/>
<size>112</size>
