<dec f='halide/halide-install/include/Halide.h' l='8056' type='Halide::Expr Halide::random_float(Halide::Expr seed = Halide::Expr())'/>
<doc f='halide/halide-install/include/Halide.h' l='8027'>/** Return a random variable representing a uniformly distributed
 * float in the half-open interval [0.0f, 1.0f). For random numbers of
 * other types, use lerp with a random float as the last parameter.
 *
 * Optionally takes a seed.
 *
 * Note that:
 \code
 Expr x = random_float();
 Expr y = x + x;
 \endcode
 *
 * is very different to
 *
 \code
 Expr y = random_float() + random_float();
 \endcode
 *
 * The first doubles a random variable, and the second adds two
 * independent random variables.
 *
 * A given random variable takes on a unique value that depends
 * deterministically on the pure variables of the function they belong
 * to, the identity of the function itself, and which definition of
 * the function it is used in. They are, however, shared across tuple
 * elements.
 *
 * This function vectorizes cleanly.
 */</doc>
<use f='halide/apps/lens_blur/lens_blur_generator.cpp' l='115' u='c' c='_ZN12_GLOBAL__N_18LensBlur8generateEv'/>
<use f='halide/apps/lens_blur/lens_blur_generator.cpp' l='116' u='c' c='_ZN12_GLOBAL__N_18LensBlur8generateEv'/>
<dec f='halide/build/include/Halide.h' l='8056' type='Halide::Expr Halide::random_float(Halide::Expr seed = Halide::Expr())'/>
<doc f='halide/build/include/Halide.h' l='8027'>/** Return a random variable representing a uniformly distributed
 * float in the half-open interval [0.0f, 1.0f). For random numbers of
 * other types, use lerp with a random float as the last parameter.
 *
 * Optionally takes a seed.
 *
 * Note that:
 \code
 Expr x = random_float();
 Expr y = x + x;
 \endcode
 *
 * is very different to
 *
 \code
 Expr y = random_float() + random_float();
 \endcode
 *
 * The first doubles a random variable, and the second adds two
 * independent random variables.
 *
 * A given random variable takes on a unique value that depends
 * deterministically on the pure variables of the function they belong
 * to, the identity of the function itself, and which definition of
 * the function it is used in. They are, however, shared across tuple
 * elements.
 *
 * This function vectorizes cleanly.
 */</doc>
<use f='halide/python_bindings/src/PyIROperator.cpp' l='172' u='a' c='_ZN6Halide14PythonBindings16define_operatorsERN8pybind117module_E'/>
<use f='halide/python_bindings/src/PyIROperator.cpp' l='175' u='a' c='_ZN6Halide14PythonBindings16define_operatorsERN8pybind117module_E'/>
<dec f='halide/src/IROperator.h' l='1251' type='Halide::Expr Halide::random_float(Halide::Expr seed = Halide::Expr())'/>
<doc f='halide/src/IROperator.h' l='1222'>/** Return a random variable representing a uniformly distributed
 * float in the half-open interval [0.0f, 1.0f). For random numbers of
 * other types, use lerp with a random float as the last parameter.
 *
 * Optionally takes a seed.
 *
 * Note that:
 \code
 Expr x = random_float();
 Expr y = x + x;
 \endcode
 *
 * is very different to
 *
 \code
 Expr y = random_float() + random_float();
 \endcode
 *
 * The first doubles a random variable, and the second adds two
 * independent random variables.
 *
 * A given random variable takes on a unique value that depends
 * deterministically on the pure variables of the function they belong
 * to, the identity of the function itself, and which definition of
 * the function it is used in. They are, however, shared across tuple
 * elements.
 *
 * This function vectorizes cleanly.
 */</doc>
<def f='halide/src/IROperator.cpp' l='2525' ll='2543' type='Halide::Expr Halide::random_float(Halide::Expr seed = Halide::Expr())'/>
