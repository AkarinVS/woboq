<dec f='halide/build/include/Halide.h' l='16214' type='Halide::Stage &amp; Halide::Stage::compute_with(Halide::LoopLevel loop_level, const std::vector&lt;std::pair&lt;VarOrRVar, LoopAlignStrategy&gt; &gt; &amp; align)'/>
<doc f='halide/build/include/Halide.h' l='16073'>/** Schedule the iteration over this stage to be fused with another
     * stage &apos;s&apos; from outermost loop to a given LoopLevel. &apos;this&apos; stage will
     * be computed AFTER &apos;s&apos; in the innermost fused dimension. There should not
     * be any dependencies between those two fused stages. If either of the
     * stages being fused is a stage of an extern Func, this will throw an error.
     *
     * Note that the two stages that are fused together should have the same
     * exact schedule from the outermost to the innermost fused dimension, and
     * the stage we are calling compute_with on should not have specializations,
     * e.g. f2.compute_with(f1, x) is allowed only if f2 has no specializations.
     *
     * Also, if a producer is desired to be computed at the fused loop level,
     * the function passed to the compute_at() needs to be the &quot;parent&quot;. Consider
     * the following code:
     \code
     input(x, y) = x + y;
     f(x, y) = input(x, y);
     f(x, y) += 5;
     g(x, y) = x - y;
     g(x, y) += 10;
     f.compute_with(g, y);
     f.update().compute_with(g.update(), y);
     \endcode
     *
     * To compute &apos;input&apos; at the fused loop level at dimension y, we specify
     * input.compute_at(g, y) instead of input.compute_at(f, y) since &apos;g&apos; is
     * the &quot;parent&quot; for this fused loop (i.e. &apos;g&apos; is computed first before &apos;f&apos;
     * is computed). On the other hand, to compute &apos;input&apos; at the innermost
     * dimension of &apos;f&apos;, we specify input.compute_at(f, x) instead of
     * input.compute_at(g, x) since the x dimension of &apos;f&apos; is not fused
     * (only the y dimension is).
     *
     * Given the constraints, this has a variety of uses. Consider the
     * following code:
     \code
     f(x, y) = x + y;
     g(x, y) = x - y;
     h(x, y) = f(x, y) + g(x, y);
     f.compute_root();
     g.compute_root();
     f.split(x, xo, xi, 8);
     g.split(x, xo, xi, 8);
     g.compute_with(f, xo);
     \endcode
     *
     * This is equivalent to:
     \code
     for y:
       for xo:
         for xi:
           f(8*xo + xi) = (8*xo + xi) + y
         for xi:
           g(8*xo + xi) = (8*xo + xi) - y
     for y:
       for x:
         h(x, y) = f(x, y) + g(x, y)
     \endcode
     *
     * The size of the dimensions of the stages computed_with do not have
     * to match. Consider the following code where &apos;g&apos; is half the size of &apos;f&apos;:
     \code
     Image&lt;int&gt; f_im(size, size), g_im(size/2, size/2);
     input(x, y) = x + y;
     f(x, y) = input(x, y);
     g(x, y) = input(2*x, 2*y);
     g.compute_with(f, y);
     input.compute_at(f, y);
     Pipeline({f, g}).realize({f_im, g_im});
     \endcode
     *
     * This is equivalent to:
     \code
     for y = 0 to size-1:
       for x = 0 to size-1:
         input(x, y) = x + y;
       for x = 0 to size-1:
         f(x, y) = input(x, y)
       for x = 0 to size/2-1:
         if (y &lt; size/2-1):
           g(x, y) = input(2*x, 2*y)
     \endcode
     *
     * &apos;align&apos; specifies how the loop iteration of each dimension of the
     * two stages being fused should be aligned in the fused loop nests
     * (see LoopAlignStrategy for options). Consider the following loop nests:
     \code
     for z = f_min_z to f_max_z:
       for y = f_min_y to f_max_y:
         for x = f_min_x to f_max_x:
           f(x, y, z) = x + y + z
     for z = g_min_z to g_max_z:
       for y = g_min_y to g_max_y:
         for x = g_min_x to g_max_x:
           g(x, y, z) = x - y - z
     \endcode
     *
     * If no alignment strategy is specified, the following loop nest will be
     * generated:
     \code
     for z = min(f_min_z, g_min_z) to max(f_max_z, g_max_z):
       for y = min(f_min_y, g_min_y) to max(f_max_y, g_max_y):
         for x = f_min_x to f_max_x:
           if (f_min_z &lt;= z &lt;= f_max_z):
             if (f_min_y &lt;= y &lt;= f_max_y):
               f(x, y, z) = x + y + z
         for x = g_min_x to g_max_x:
           if (g_min_z &lt;= z &lt;= g_max_z):
             if (g_min_y &lt;= y &lt;= g_max_y):
               g(x, y, z) = x - y - z
     \endcode
     *
     * Instead, these alignment strategies:
     \code
     g.compute_with(f, y, {{z, LoopAlignStrategy::AlignStart}, {y, LoopAlignStrategy::AlignEnd}});
     \endcode
     * will produce the following loop nest:
     \code
     f_loop_min_z = f_min_z
     f_loop_max_z = max(f_max_z, (f_min_z - g_min_z) + g_max_z)
     for z = f_min_z to f_loop_max_z:
       f_loop_min_y = min(f_min_y, (f_max_y - g_max_y) + g_min_y)
       f_loop_max_y = f_max_y
       for y = f_loop_min_y to f_loop_max_y:
         for x = f_min_x to f_max_x:
           if (f_loop_min_z &lt;= z &lt;= f_loop_max_z):
             if (f_loop_min_y &lt;= y &lt;= f_loop_max_y):
               f(x, y, z) = x + y + z
         for x = g_min_x to g_max_x:
           g_shift_z = g_min_z - f_loop_min_z
           g_shift_y = g_max_y - f_loop_max_y
           if (g_min_z &lt;= (z + g_shift_z) &lt;= g_max_z):
             if (g_min_y &lt;= (y + g_shift_y) &lt;= g_max_y):
               g(x, y + g_shift_y, z + g_shift_z) = x - (y + g_shift_y) - (z + g_shift_z)
     \endcode
     *
     * LoopAlignStrategy::AlignStart on dimension z will shift the loop iteration
     * of &apos;g&apos; at dimension z so that its starting value matches that of &apos;f&apos;.
     * Likewise, LoopAlignStrategy::AlignEnd on dimension y will shift the loop
     * iteration of &apos;g&apos; at dimension y so that its end value matches that of &apos;f&apos;.
     */
    // @{</doc>
<use f='halide/python_bindings/src/PyStage.cpp' l='20' u='a' c='_ZN6Halide14PythonBindings12define_stageERN8pybind117module_E'/>
<dec f='halide/src/Func.h' l='334' type='Halide::Stage &amp; Halide::Stage::compute_with(Halide::LoopLevel loop_level, const std::vector&lt;std::pair&lt;VarOrRVar, LoopAlignStrategy&gt; &gt; &amp; align)'/>
<doc f='halide/src/Func.h' l='193'>/** Schedule the iteration over this stage to be fused with another
     * stage &apos;s&apos; from outermost loop to a given LoopLevel. &apos;this&apos; stage will
     * be computed AFTER &apos;s&apos; in the innermost fused dimension. There should not
     * be any dependencies between those two fused stages. If either of the
     * stages being fused is a stage of an extern Func, this will throw an error.
     *
     * Note that the two stages that are fused together should have the same
     * exact schedule from the outermost to the innermost fused dimension, and
     * the stage we are calling compute_with on should not have specializations,
     * e.g. f2.compute_with(f1, x) is allowed only if f2 has no specializations.
     *
     * Also, if a producer is desired to be computed at the fused loop level,
     * the function passed to the compute_at() needs to be the &quot;parent&quot;. Consider
     * the following code:
     \code
     input(x, y) = x + y;
     f(x, y) = input(x, y);
     f(x, y) += 5;
     g(x, y) = x - y;
     g(x, y) += 10;
     f.compute_with(g, y);
     f.update().compute_with(g.update(), y);
     \endcode
     *
     * To compute &apos;input&apos; at the fused loop level at dimension y, we specify
     * input.compute_at(g, y) instead of input.compute_at(f, y) since &apos;g&apos; is
     * the &quot;parent&quot; for this fused loop (i.e. &apos;g&apos; is computed first before &apos;f&apos;
     * is computed). On the other hand, to compute &apos;input&apos; at the innermost
     * dimension of &apos;f&apos;, we specify input.compute_at(f, x) instead of
     * input.compute_at(g, x) since the x dimension of &apos;f&apos; is not fused
     * (only the y dimension is).
     *
     * Given the constraints, this has a variety of uses. Consider the
     * following code:
     \code
     f(x, y) = x + y;
     g(x, y) = x - y;
     h(x, y) = f(x, y) + g(x, y);
     f.compute_root();
     g.compute_root();
     f.split(x, xo, xi, 8);
     g.split(x, xo, xi, 8);
     g.compute_with(f, xo);
     \endcode
     *
     * This is equivalent to:
     \code
     for y:
       for xo:
         for xi:
           f(8*xo + xi) = (8*xo + xi) + y
         for xi:
           g(8*xo + xi) = (8*xo + xi) - y
     for y:
       for x:
         h(x, y) = f(x, y) + g(x, y)
     \endcode
     *
     * The size of the dimensions of the stages computed_with do not have
     * to match. Consider the following code where &apos;g&apos; is half the size of &apos;f&apos;:
     \code
     Image&lt;int&gt; f_im(size, size), g_im(size/2, size/2);
     input(x, y) = x + y;
     f(x, y) = input(x, y);
     g(x, y) = input(2*x, 2*y);
     g.compute_with(f, y);
     input.compute_at(f, y);
     Pipeline({f, g}).realize({f_im, g_im});
     \endcode
     *
     * This is equivalent to:
     \code
     for y = 0 to size-1:
       for x = 0 to size-1:
         input(x, y) = x + y;
       for x = 0 to size-1:
         f(x, y) = input(x, y)
       for x = 0 to size/2-1:
         if (y &lt; size/2-1):
           g(x, y) = input(2*x, 2*y)
     \endcode
     *
     * &apos;align&apos; specifies how the loop iteration of each dimension of the
     * two stages being fused should be aligned in the fused loop nests
     * (see LoopAlignStrategy for options). Consider the following loop nests:
     \code
     for z = f_min_z to f_max_z:
       for y = f_min_y to f_max_y:
         for x = f_min_x to f_max_x:
           f(x, y, z) = x + y + z
     for z = g_min_z to g_max_z:
       for y = g_min_y to g_max_y:
         for x = g_min_x to g_max_x:
           g(x, y, z) = x - y - z
     \endcode
     *
     * If no alignment strategy is specified, the following loop nest will be
     * generated:
     \code
     for z = min(f_min_z, g_min_z) to max(f_max_z, g_max_z):
       for y = min(f_min_y, g_min_y) to max(f_max_y, g_max_y):
         for x = f_min_x to f_max_x:
           if (f_min_z &lt;= z &lt;= f_max_z):
             if (f_min_y &lt;= y &lt;= f_max_y):
               f(x, y, z) = x + y + z
         for x = g_min_x to g_max_x:
           if (g_min_z &lt;= z &lt;= g_max_z):
             if (g_min_y &lt;= y &lt;= g_max_y):
               g(x, y, z) = x - y - z
     \endcode
     *
     * Instead, these alignment strategies:
     \code
     g.compute_with(f, y, {{z, LoopAlignStrategy::AlignStart}, {y, LoopAlignStrategy::AlignEnd}});
     \endcode
     * will produce the following loop nest:
     \code
     f_loop_min_z = f_min_z
     f_loop_max_z = max(f_max_z, (f_min_z - g_min_z) + g_max_z)
     for z = f_min_z to f_loop_max_z:
       f_loop_min_y = min(f_min_y, (f_max_y - g_max_y) + g_min_y)
       f_loop_max_y = f_max_y
       for y = f_loop_min_y to f_loop_max_y:
         for x = f_min_x to f_max_x:
           if (f_loop_min_z &lt;= z &lt;= f_loop_max_z):
             if (f_loop_min_y &lt;= y &lt;= f_loop_max_y):
               f(x, y, z) = x + y + z
         for x = g_min_x to g_max_x:
           g_shift_z = g_min_z - f_loop_min_z
           g_shift_y = g_max_y - f_loop_max_y
           if (g_min_z &lt;= (z + g_shift_z) &lt;= g_max_z):
             if (g_min_y &lt;= (y + g_shift_y) &lt;= g_max_y):
               g(x, y + g_shift_y, z + g_shift_z) = x - (y + g_shift_y) - (z + g_shift_z)
     \endcode
     *
     * LoopAlignStrategy::AlignStart on dimension z will shift the loop iteration
     * of &apos;g&apos; at dimension z so that its starting value matches that of &apos;f&apos;.
     * Likewise, LoopAlignStrategy::AlignEnd on dimension y will shift the loop
     * iteration of &apos;g&apos; at dimension y so that its end value matches that of &apos;f&apos;.
     */
    // @{</doc>
<def f='halide/src/Func.cpp' l='1882' ll='1888' type='Halide::Stage &amp; Halide::Stage::compute_with(Halide::LoopLevel loop_level, const vector&lt;pair&lt;Halide::VarOrRVar, Halide::LoopAlignStrategy&gt; &gt; &amp; align)'/>
<use f='halide/src/Func.cpp' l='1896' u='c' c='_ZN6Halide5Stage12compute_withERKS0_RKNS_9VarOrRVarERKSt6vectorISt4pairIS3_NS_17LoopAlignStrategyEESaIS9_EE'/>
<use f='halide/src/Func.cpp' l='2658' u='c' c='_ZN6Halide4Func12compute_withENS_9LoopLevelERKSt6vectorISt4pairINS_9VarOrRVarENS_17LoopAlignStrategyEESaIS6_EE'/>
