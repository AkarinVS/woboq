<def f='halide/build-apps/gemmlowp/internal/multi_thread_gemm.h' l='147' ll='210'/>
<use f='halide/build-apps/gemmlowp/internal/multi_thread_gemm.h' l='230' c='_ZN8gemmlowp6WorkerC1EPNS_15BlockingCounterE'/>
<use f='halide/build-apps/gemmlowp/internal/multi_thread_gemm.h' l='355'/>
<use f='halide/build-apps/gemmlowp/internal/multi_thread_gemm.h' l='447'/>
<size>8</size>
<doc f='halide/build-apps/gemmlowp/internal/multi_thread_gemm.h' l='139'>// A BlockingCounter lets one thread to wait for N events to occur.
// This is how the master thread waits for all the worker threads
// to have finished working.
// The waiting is done using a naive spinlock waiting for the atomic
// count_ to hit the value 0. This is acceptable because in our usage
// pattern, BlockingCounter is used only to synchronize threads after
// short-lived tasks (performing parts of the same GEMM). It is not used
// for synchronizing longer waits (resuming work on the next GEMM).</doc>
<fun r='_ZN8gemmlowp15BlockingCounterC1Ev'/>
<fun r='_ZN8gemmlowp15BlockingCounter5ResetEm'/>
<fun r='_ZN8gemmlowp15BlockingCounter14DecrementCountEv'/>
<fun r='_ZN8gemmlowp15BlockingCounter4WaitEv'/>
<mbr r='gemmlowp::BlockingCounter::count_' o='0' t='std::atomic&lt;std::size_t&gt;'/>
