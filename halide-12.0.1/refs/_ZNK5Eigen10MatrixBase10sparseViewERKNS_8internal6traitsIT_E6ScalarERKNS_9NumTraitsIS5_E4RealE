<dec f='halide/build-apps/eigen/Eigen/src/Core/MatrixBase.h' l='252' type='const SparseView&lt;Derived&gt; Eigen::MatrixBase::sparseView(const Eigen::MatrixBase::Scalar &amp; m_reference = Eigen::MatrixBase::Scalar(0), const typename NumTraits&lt;Scalar&gt;::Real &amp; m_epsilon = NumTraits&lt;Scalar&gt;::dummy_precision()) const'/>
<def f='halide/build-apps/eigen/Eigen/src/SparseCore/SparseView.h' l='225' ll='230' type='const SparseView&lt;Derived&gt; Eigen::MatrixBase::sparseView(const Eigen::MatrixBase::Scalar &amp; reference = Eigen::MatrixBase::Scalar(0), const typename NumTraits&lt;Scalar&gt;::Real &amp; epsilon = NumTraits&lt;Scalar&gt;::dummy_precision()) const'/>
<doc f='halide/build-apps/eigen/Eigen/src/SparseCore/SparseView.h' l='208'>/** \ingroup SparseCore_Module
  *
  * \returns a sparse expression of the dense expression \c *this with values smaller than
  * \a reference * \a epsilon removed.
  *
  * This method is typically used when prototyping to convert a quickly assembled dense Matrix \c D to a SparseMatrix \c S:
  * \code
  * MatrixXd D(n,m);
  * SparseMatrix&lt;double&gt; S;
  * S = D.sparseView();             // suppress numerical zeros (exact)
  * S = D.sparseView(reference);
  * S = D.sparseView(reference,epsilon);
  * \endcode
  * where \a reference is a meaningful non zero reference value,
  * and \a epsilon is a tolerance factor defaulting to NumTraits&lt;Scalar&gt;::dummy_precision().
  *
  * \sa SparseMatrixBase::pruned(), class SparseView */</doc>
