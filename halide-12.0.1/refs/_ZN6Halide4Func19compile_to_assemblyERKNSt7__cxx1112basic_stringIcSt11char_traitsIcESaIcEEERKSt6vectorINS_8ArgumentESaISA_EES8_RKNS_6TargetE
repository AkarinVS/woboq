<dec f='halide/build/include/Halide.h' l='16806' type='void Halide::Func::compile_to_assembly(const std::string &amp; filename, const std::vector&lt;Argument&gt; &amp; , const std::string &amp; fn_name, const Halide::Target &amp; target = get_target_from_environment())'/>
<doc f='halide/build/include/Halide.h' l='16800'>/** Statically compile this function to text assembly equivalent
     * to the object file generated by compile_to_object. This is
     * useful for checking what Halide is producing without having to
     * disassemble anything, or if you need to feed the assembly into
     * some custom toolchain to produce an object file (e.g. iOS) */
    //@{</doc>
<use f='halide/python_bindings/src/PyFunc.cpp' l='227' u='a' c='_ZN6Halide14PythonBindings11define_funcERN8pybind117module_E'/>
<dec f='halide/src/Func.h' l='926' type='void Halide::Func::compile_to_assembly(const std::string &amp; filename, const std::vector&lt;Argument&gt; &amp; , const std::string &amp; fn_name, const Halide::Target &amp; target = get_target_from_environment())'/>
<doc f='halide/src/Func.h' l='920'>/** Statically compile this function to text assembly equivalent
     * to the object file generated by compile_to_object. This is
     * useful for checking what Halide is producing without having to
     * disassemble anything, or if you need to feed the assembly into
     * some custom toolchain to produce an object file (e.g. iOS) */
    //@{</doc>
<def f='halide/src/Func.cpp' l='3252' ll='3255' type='void Halide::Func::compile_to_assembly(const std::string &amp; filename, const vector&lt;Halide::Argument&gt; &amp; args, const std::string &amp; fn_name, const Halide::Target &amp; target = get_target_from_environment())'/>
