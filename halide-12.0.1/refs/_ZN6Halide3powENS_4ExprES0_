<dec f='halide/halide-install/include/Halide.h' l='7767' type='Halide::Expr Halide::pow(Halide::Expr x, Halide::Expr y)'/>
<doc f='halide/halide-install/include/Halide.h' l='7761'>/** Return one floating point expression raised to the power of
 * another. The type of the result is given by the type of the first
 * argument. If the first argument is not a floating-point type, it is
 * cast to Float(32). For Float(32), cleanly vectorizable, and
 * accurate up to the last few bits of the mantissa. Gets worse when
 * approaching overflow. Vectorizes cleanly. */</doc>
<use f='halide/apps/camera_pipe/camera_pipe_generator.cpp' l='315' u='c' c='_ZN12_GLOBAL__N_110CameraPipe11apply_curveEN6Halide4FuncE'/>
<use f='halide/apps/camera_pipe/camera_pipe_generator.cpp' l='321' u='c' c='_ZN12_GLOBAL__N_110CameraPipe11apply_curveEN6Halide4FuncE'/>
<use f='halide/apps/hannk/halide/normalizations_generator.cpp' l='28' u='c' c='_ZN5hannk15L2Normalization8generateEv'/>
<use f='halide/apps/lens_blur/lens_blur_generator.cpp' l='37' u='c' c='_ZN12_GLOBAL__N_18LensBlur8generateEv'/>
<use f='halide/apps/lens_blur/lens_blur_generator.cpp' l='38' u='c' c='_ZN12_GLOBAL__N_18LensBlur8generateEv'/>
<use f='halide/apps/lens_blur/lens_blur_generator.cpp' l='39' u='c' c='_ZN12_GLOBAL__N_18LensBlur8generateEv'/>
<use f='halide/apps/lens_blur/lens_blur_generator.cpp' l='46' u='c' c='_ZN12_GLOBAL__N_18LensBlur8generateEv'/>
<use f='halide/apps/lens_blur/lens_blur_generator.cpp' l='47' u='c' c='_ZN12_GLOBAL__N_18LensBlur8generateEv'/>
<use f='halide/apps/lens_blur/lens_blur_generator.cpp' l='89' u='c' c='_ZN12_GLOBAL__N_18LensBlur8generateEv'/>
<use f='halide/apps/nl_means/nl_means_generator.cpp' l='32' u='c' c='_ZN12_GLOBAL__N_113NonLocalMeans8generateEv'/>
<dec f='halide/build/include/Halide.h' l='7767' type='Halide::Expr Halide::pow(Halide::Expr x, Halide::Expr y)'/>
<doc f='halide/build/include/Halide.h' l='7761'>/** Return one floating point expression raised to the power of
 * another. The type of the result is given by the type of the first
 * argument. If the first argument is not a floating-point type, it is
 * cast to Float(32). For Float(32), cleanly vectorizable, and
 * accurate up to the last few bits of the mantissa. Gets worse when
 * approaching overflow. Vectorizes cleanly. */</doc>
<use f='halide/python_bindings/src/PyBinaryOperators.h' l='176' u='c' c='_ZN6Halide14PythonBindings20add_binary_operatorsERT_'/>
<use f='halide/python_bindings/src/PyBinaryOperators.h' l='177' u='c' c='_ZN6Halide14PythonBindings20add_binary_operatorsERT_'/>
<use f='halide/python_bindings/src/PyIROperator.cpp' l='134' u='a' c='_ZN6Halide14PythonBindings16define_operatorsERN8pybind117module_E'/>
<dec f='halide/src/IROperator.h' l='962' type='Halide::Expr Halide::pow(Halide::Expr x, Halide::Expr y)'/>
<doc f='halide/src/IROperator.h' l='956'>/** Return one floating point expression raised to the power of
 * another. The type of the result is given by the type of the first
 * argument. If the first argument is not a floating-point type, it is
 * cast to Float(32). For Float(32), cleanly vectorizable, and
 * accurate up to the last few bits of the mantissa. Gets worse when
 * approaching overflow. Vectorizes cleanly. */</doc>
<use f='halide/src/Derivative.cpp' l='1136' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_126ReverseAccumulationVisitor5visitEPKNS0_4CallE'/>
<use f='halide/src/Derivative.cpp' l='1138' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_126ReverseAccumulationVisitor5visitEPKNS0_4CallE'/>
<use f='halide/src/IROperator.cpp' l='847' u='c' c='_ZN6Halide8Internal10halide_erfERKNS_4ExprE'/>
<def f='halide/src/IROperator.cpp' l='2140' ll='2158' type='Halide::Expr Halide::pow(Halide::Expr x, Halide::Expr y)'/>
<use f='halide/src/Solve.cpp' l='1393' u='c' c='_ZN6Halide8Internal10solve_testEv'/>
<use f='halide/src/Solve.cpp' l='1393' u='c' c='_ZN6Halide8Internal10solve_testEv'/>
<use f='halide/src/autoschedulers/adams2019/cost_model_generator.cpp' l='75' u='c' c='_ZN11ModelWeightILb1EE8backpropERKN6Halide10DerivativeERKNS1_4ExprES7_'/>
<use f='halide/src/autoschedulers/adams2019/cost_model_generator.cpp' l='79' u='c' c='_ZN11ModelWeightILb1EE8backpropERKN6Halide10DerivativeERKNS1_4ExprES7_'/>
<use f='halide/src/autoschedulers/adams2019/cost_model_generator.cpp' l='80' u='c' c='_ZN11ModelWeightILb1EE8backpropERKN6Halide10DerivativeERKNS1_4ExprES7_'/>
<use f='halide/src/autoschedulers/adams2019/cost_model_generator.cpp' l='437' u='c' c='_ZN9CostModel8generateEv'/>
<use f='halide/src/autoschedulers/adams2019/test.cpp' l='280' u='c' c='main'/>
<use f='halide/test/generator/autograd_generator.cpp' l='24' u='c' c='_ZN12_GLOBAL__N_18Autograd8generateEv'/>
<use f='halide/test/generator/autograd_generator.cpp' l='25' u='c' c='_ZN12_GLOBAL__N_18Autograd8generateEv'/>
<use f='halide/tutorial/lesson_12_using_the_gpu.cpp' l='52' u='c' c='_ZN10MyPipelineC1EN6Halide6BufferIhEE'/>
