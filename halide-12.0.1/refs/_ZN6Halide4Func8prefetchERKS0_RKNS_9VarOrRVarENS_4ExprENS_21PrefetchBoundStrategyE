<dec f='halide/build/include/Halide.h' l='17892' type='Halide::Func &amp; Halide::Func::prefetch(const Halide::Func &amp; f, const Halide::VarOrRVar &amp; var, Halide::Expr offset = 1, Halide::PrefetchBoundStrategy strategy = PrefetchBoundStrategy::GuardWithIf)'/>
<doc f='halide/build/include/Halide.h' l='17861'>/** Prefetch data written to or read from a Func or an ImageParam by a
     * subsequent loop iteration, at an optionally specified iteration offset.
     * &apos;var&apos; specifies at which loop level the prefetch calls should be inserted.
     * The final argument specifies how prefetch of region outside bounds
     * should be handled.
     *
     * For example, consider this pipeline:
     \code
     Func f, g;
     Var x, y;
     f(x, y) = x + y;
     g(x, y) = 2 * f(x, y);
     \endcode
     *
     * The following schedule:
     \code
     f.compute_root();
     g.prefetch(f, x, 2, PrefetchBoundStrategy::NonFaulting);
     \endcode
     *
     * will inject prefetch call at the innermost loop of &apos;g&apos; and generate
     * the following loop nest:
     * for y = ...
     *   for x = ...
     *     f(x, y) = x + y
     * for y = ..
     *   for x = ...
     *     prefetch(&amp;f[x + 2, y], 1, 16);
     *     g(x, y) = 2 * f(x, y)
     */
    // @{</doc>
<dec f='halide/src/Func.h' l='2012' type='Halide::Func &amp; Halide::Func::prefetch(const Halide::Func &amp; f, const Halide::VarOrRVar &amp; var, Halide::Expr offset = 1, Halide::PrefetchBoundStrategy strategy = PrefetchBoundStrategy::GuardWithIf)'/>
<doc f='halide/src/Func.h' l='1981'>/** Prefetch data written to or read from a Func or an ImageParam by a
     * subsequent loop iteration, at an optionally specified iteration offset.
     * &apos;var&apos; specifies at which loop level the prefetch calls should be inserted.
     * The final argument specifies how prefetch of region outside bounds
     * should be handled.
     *
     * For example, consider this pipeline:
     \code
     Func f, g;
     Var x, y;
     f(x, y) = x + y;
     g(x, y) = 2 * f(x, y);
     \endcode
     *
     * The following schedule:
     \code
     f.compute_root();
     g.prefetch(f, x, 2, PrefetchBoundStrategy::NonFaulting);
     \endcode
     *
     * will inject prefetch call at the innermost loop of &apos;g&apos; and generate
     * the following loop nest:
     * for y = ...
     *   for x = ...
     *     f(x, y) = x + y
     * for y = ..
     *   for x = ...
     *     prefetch(&amp;f[x + 2, y], 1, 16);
     *     g(x, y) = 2 * f(x, y)
     */
    // @{</doc>
<def f='halide/src/Func.cpp' l='2531' ll='2535' type='Halide::Func &amp; Halide::Func::prefetch(const Halide::Func &amp; f, const Halide::VarOrRVar &amp; var, Halide::Expr offset = 1, Halide::PrefetchBoundStrategy strategy = PrefetchBoundStrategy::GuardWithIf)'/>
