<dec f='halide/build/include/Halide.h' l='27165' type='bool Halide::Internal::expr_match(const Halide::Expr &amp; pattern, const Halide::Expr &amp; expr, std::map&lt;std::string, Expr&gt; &amp; result)'/>
<doc f='halide/build/include/Halide.h' l='27153'>/** Does the first expression have the same structure as the second?
 * Variables are matched consistently. The first time a variable is
 * matched, it assumes the value of the matching part of the second
 * expression. Subsequent matches must be equal to the first match.
 *
 * For example:
 \code
 Var x(&quot;x&quot;), y(&quot;y&quot;);
 match(x*(x + y), a*(a + b), result)
 \endcode
 * should return true, and set result[&quot;x&quot;] = a, and result[&quot;y&quot;] = b.
 */</doc>
<dec f='halide/src/IRMatch.h' l='51' type='bool Halide::Internal::expr_match(const Halide::Expr &amp; pattern, const Halide::Expr &amp; expr, std::map&lt;std::string, Expr&gt; &amp; result)'/>
<use f='halide/src/Associativity.cpp' l='105' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_128associative_op_pattern_matchERKNS_4ExprES4_RKSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISB_EE11937847'/>
<doc f='halide/src/IRMatch.h' l='39'>/** Does the first expression have the same structure as the second?
 * Variables are matched consistently. The first time a variable is
 * matched, it assumes the value of the matching part of the second
 * expression. Subsequent matches must be equal to the first match.
 *
 * For example:
 \code
 Var x(&quot;x&quot;), y(&quot;y&quot;);
 match(x*(x + y), a*(a + b), result)
 \endcode
 * should return true, and set result[&quot;x&quot;] = a, and result[&quot;y&quot;] = b.
 */</doc>
<def f='halide/src/IRMatch.cpp' l='321' ll='340' type='bool Halide::Internal::expr_match(const Halide::Expr &amp; pattern, const Halide::Expr &amp; expr, map&lt;std::string, Halide::Expr&gt; &amp; matches)'/>
