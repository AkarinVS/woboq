<dec f='halide/halide-install/include/Halide.h' l='17971' type='Halide::Func &amp; Halide::Func::fold_storage(const Halide::Var &amp; dim, const Halide::Expr &amp; extent, bool fold_forward = true)'/>
<use f='halide/halide-install/include/Halide.h' l='25184' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase12fold_storageEDpOT_'/>
<use f='halide/halide-install/include/Halide.h' l='25184' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase12fold_storageEDpOT_'/>
<doc f='halide/halide-install/include/Halide.h' l='17941'>/** Store realizations of this function in a circular buffer of a
     * given extent. This is more efficient when the extent of the
     * circular buffer is a power of 2. If the fold factor is too
     * small, or the dimension is not accessed monotonically, the
     * pipeline will generate an error at runtime.
     *
     * The fold_forward option indicates that the new values of the
     * producer are accessed by the consumer in a monotonically
     * increasing order. Folding storage of producers is also
     * supported if the new values are accessed in a monotonically
     * decreasing order by setting fold_forward to false.
     *
     * For example, consider the pipeline:
     \code
     Func f, g;
     Var x, y;
     g(x, y) = x*y;
     f(x, y) = g(x, y) + g(x, y+1);
     \endcode
     *
     * If we schedule f like so:
     *
     \code
     g.compute_at(f, y).store_root().fold_storage(y, 2);
     \endcode
     *
     * Then g will be computed at each row of f and stored in a buffer
     * with an extent in y of 2, alternately storing each computed row
     * of g in row y=0 or y=1.
     */</doc>
<use f='halide/apps/camera_pipe/camera_pipe_generator.cpp' l='174' u='c' c='_ZN12_GLOBAL__N_18Demosaic8scheduleEv'/>
<use f='halide/apps/camera_pipe/camera_pipe_generator.cpp' l='533' u='c' c='_ZN12_GLOBAL__N_110CameraPipe8generateEv'/>
<use f='halide/apps/camera_pipe/camera_pipe_generator.cpp' l='541' u='c' c='_ZN12_GLOBAL__N_110CameraPipe8generateEv'/>
<use f='halide/apps/local_laplacian/local_laplacian_generator.cpp' l='151' u='c' c='_ZN12_GLOBAL__N_114LocalLaplacian8generateEv'/>
<dec f='halide/build/include/Halide.h' l='17971' type='Halide::Func &amp; Halide::Func::fold_storage(const Halide::Var &amp; dim, const Halide::Expr &amp; extent, bool fold_forward = true)'/>
<use f='halide/build/include/Halide.h' l='25184' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase12fold_storageEDpOT_'/>
<use f='halide/build/include/Halide.h' l='25184' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase12fold_storageEDpOT_'/>
<doc f='halide/build/include/Halide.h' l='17941'>/** Store realizations of this function in a circular buffer of a
     * given extent. This is more efficient when the extent of the
     * circular buffer is a power of 2. If the fold factor is too
     * small, or the dimension is not accessed monotonically, the
     * pipeline will generate an error at runtime.
     *
     * The fold_forward option indicates that the new values of the
     * producer are accessed by the consumer in a monotonically
     * increasing order. Folding storage of producers is also
     * supported if the new values are accessed in a monotonically
     * decreasing order by setting fold_forward to false.
     *
     * For example, consider the pipeline:
     \code
     Func f, g;
     Var x, y;
     g(x, y) = x*y;
     f(x, y) = g(x, y) + g(x, y+1);
     \endcode
     *
     * If we schedule f like so:
     *
     \code
     g.compute_at(f, y).store_root().fold_storage(y, 2);
     \endcode
     *
     * Then g will be computed at each row of f and stored in a buffer
     * with an extent in y of 2, alternately storing each computed row
     * of g in row y=0 or y=1.
     */</doc>
<use f='halide/python_bindings/src/PyFunc.cpp' l='334' u='a' c='_ZN6Halide14PythonBindings11define_funcERN8pybind117module_E'/>
<dec f='halide/src/Func.h' l='2091' type='Halide::Func &amp; Halide::Func::fold_storage(const Halide::Var &amp; dim, const Halide::Expr &amp; extent, bool fold_forward = true)'/>
<doc f='halide/src/Func.h' l='2061'>/** Store realizations of this function in a circular buffer of a
     * given extent. This is more efficient when the extent of the
     * circular buffer is a power of 2. If the fold factor is too
     * small, or the dimension is not accessed monotonically, the
     * pipeline will generate an error at runtime.
     *
     * The fold_forward option indicates that the new values of the
     * producer are accessed by the consumer in a monotonically
     * increasing order. Folding storage of producers is also
     * supported if the new values are accessed in a monotonically
     * decreasing order by setting fold_forward to false.
     *
     * For example, consider the pipeline:
     \code
     Func f, g;
     Var x, y;
     g(x, y) = x*y;
     f(x, y) = g(x, y) + g(x, y+1);
     \endcode
     *
     * If we schedule f like so:
     *
     \code
     g.compute_at(f, y).store_root().fold_storage(y, 2);
     \endcode
     *
     * Then g will be computed at each row of f and stored in a buffer
     * with an extent in y of 2, alternately storing each computed row
     * of g in row y=0 or y=1.
     */</doc>
<def f='halide/src/Func.cpp' l='2607' ll='2623' type='Halide::Func &amp; Halide::Func::fold_storage(const Halide::Var &amp; dim, const Halide::Expr &amp; factor, bool fold_forward = true)'/>
<use f='halide/src/Generator.h' l='2250' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase12fold_storageEDpOT_'/>
<use f='halide/src/Generator.h' l='2250' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase12fold_storageEDpOT_'/>
