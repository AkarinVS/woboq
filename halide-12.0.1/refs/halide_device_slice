<dec f='halide/build/include/HalideRuntime.h' l='818' type='int halide_device_slice(void * user_context, const struct halide_buffer_t * src, int slice_dim, int slice_pos, struct halide_buffer_t * dst)'/>
<doc f='halide/build/include/HalideRuntime.h' l='806'>/** Give the destination buffer a device allocation which is an alias
 * for a similar coordinate range in the source buffer, but with one dimension
 * sliced away in the dst. Modifies the device, device_interface, and the
 * device_dirty flag only. Only supported by some device APIs (others will return
 * halide_error_code_device_crop_unsupported). Call
 * halide_device_release_crop instead of halide_device_free to clean
 * up resources associated with the sliced view. Do not free the
 * device allocation on the source buffer while the destination buffer
 * still lives. Note that the two buffers do not share dirty flags, so
 * care must be taken to update them together as needed. Note that the dst buffer
 * must have exactly one fewer dimension than the src buffer, and that slice_dim
 * and slice_pos must be valid within src. */</doc>
<dec f='halide/build/include/Halide.h' l='916' type='int halide_device_slice(void * user_context, const struct halide_buffer_t * src, int slice_dim, int slice_pos, struct halide_buffer_t * dst)'/>
<doc f='halide/build/include/Halide.h' l='904'>/** Give the destination buffer a device allocation which is an alias
 * for a similar coordinate range in the source buffer, but with one dimension
 * sliced away in the dst. Modifies the device, device_interface, and the
 * device_dirty flag only. Only supported by some device APIs (others will return
 * halide_error_code_device_crop_unsupported). Call
 * halide_device_release_crop instead of halide_device_free to clean
 * up resources associated with the sliced view. Do not free the
 * device allocation on the source buffer while the destination buffer
 * still lives. Note that the two buffers do not share dirty flags, so
 * care must be taken to update them together as needed. Note that the dst buffer
 * must have exactly one fewer dimension than the src buffer, and that slice_dim
 * and slice_pos must be valid within src. */</doc>
<dec f='halide/src/runtime/HalideRuntime.h' l='818' type='int halide_device_slice(void * user_context, const struct halide_buffer_t * src, int slice_dim, int slice_pos, struct halide_buffer_t * dst)'/>
<doc f='halide/src/runtime/HalideRuntime.h' l='806'>/** Give the destination buffer a device allocation which is an alias
 * for a similar coordinate range in the source buffer, but with one dimension
 * sliced away in the dst. Modifies the device, device_interface, and the
 * device_dirty flag only. Only supported by some device APIs (others will return
 * halide_error_code_device_crop_unsupported). Call
 * halide_device_release_crop instead of halide_device_free to clean
 * up resources associated with the sliced view. Do not free the
 * device allocation on the source buffer while the destination buffer
 * still lives. Note that the two buffers do not share dirty flags, so
 * care must be taken to update them together as needed. Note that the dst buffer
 * must have exactly one fewer dimension than the src buffer, and that slice_dim
 * and slice_pos must be valid within src. */</doc>
<dec f='halide/build/tutorial/lesson_10_halide.h' l='890' type='int halide_device_slice(void * user_context, const struct halide_buffer_t * src, int slice_dim, int slice_pos, struct halide_buffer_t * dst)'/>
<doc f='halide/build/tutorial/lesson_10_halide.h' l='878'>/** Give the destination buffer a device allocation which is an alias
 * for a similar coordinate range in the source buffer, but with one dimension
 * sliced away in the dst. Modifies the device, device_interface, and the
 * device_dirty flag only. Only supported by some device APIs (others will return
 * halide_error_code_device_crop_unsupported). Call
 * halide_device_release_crop instead of halide_device_free to clean
 * up resources associated with the sliced view. Do not free the
 * device allocation on the source buffer while the destination buffer
 * still lives. Note that the two buffers do not share dirty flags, so
 * care must be taken to update them together as needed. Note that the dst buffer
 * must have exactly one fewer dimension than the src buffer, and that slice_dim
 * and slice_pos must be valid within src. */</doc>
