<dec f='halide/build/include/Halide.h' l='27028' type='Halide::Expr Halide::sum(Halide::Expr , const std::string &amp; s = &quot;sum&quot;)'/>
<doc f='halide/build/include/Halide.h' l='27005'>/** An inline reduction. This is suitable for convolution-type
 * operations - the reduction will be computed in the innermost loop
 * that it is used in. The argument may contain free or implicit
 * variables, and must refer to some reduction domain. The free
 * variables are still free in the return value, but the reduction
 * domain is captured - the result expression does not refer to a
 * reduction domain and can be used in a pure function definition.
 *
 * An example using \ref sum :
 *
 \code
 Func f, g;
 Var x;
 RDom r(0, 10);
 f(x) = x*x;
 g(x) = sum(f(x + r));
 \endcode
 *
 * Here g computes some blur of x, but g is still a pure function. The
 * sum is being computed by an anonymous reduction function that is
 * scheduled innermost within g.
 */
//@{</doc>
<use f='halide/python_bindings/src/PyInlineReductions.cpp' l='9' u='a' c='_ZN6Halide14PythonBindings24define_inline_reductionsERN8pybind117module_E'/>
<dec f='halide/src/InlineReductions.h' l='40' type='Halide::Expr Halide::sum(Halide::Expr , const std::string &amp; s = &quot;sum&quot;)'/>
<use f='halide/src/Bounds.cpp' l='3062' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_119constant_bound_testEv'/>
<use f='halide/src/Bounds.cpp' l='3066' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_119constant_bound_testEv'/>
<doc f='halide/src/InlineReductions.h' l='17'>/** An inline reduction. This is suitable for convolution-type
 * operations - the reduction will be computed in the innermost loop
 * that it is used in. The argument may contain free or implicit
 * variables, and must refer to some reduction domain. The free
 * variables are still free in the return value, but the reduction
 * domain is captured - the result expression does not refer to a
 * reduction domain and can be used in a pure function definition.
 *
 * An example using \ref sum :
 *
 \code
 Func f, g;
 Var x;
 RDom r(0, 10);
 f(x) = x*x;
 g(x) = sum(f(x + r));
 \endcode
 *
 * Here g computes some blur of x, but g is still a pure function. The
 * sum is being computed by an anonymous reduction function that is
 * scheduled innermost within g.
 */
//@{</doc>
<def f='halide/src/InlineReductions.cpp' l='111' ll='113' type='Halide::Expr Halide::sum(Halide::Expr e, const std::string &amp; name = &quot;sum&quot;)'/>
<use f='halide/src/autoschedulers/adams2019/cost_model_generator.cpp' l='424' u='c' c='_ZN9CostModel8generateEv'/>
<use f='halide/src/autoschedulers/adams2019/cost_model_generator.cpp' l='443' u='c' c='_ZN9CostModel8generateEv'/>
<use f='halide/src/autoschedulers/adams2019/test_function_dag.cpp' l='136' u='c' c='_Z11test_matmulRKN6Halide13MachineParamsERKNS_6TargetE'/>
<use f='halide/src/autoschedulers/adams2019/test_function_dag.cpp' l='150' u='c' c='_Z11test_matmulRKN6Halide13MachineParamsERKNS_6TargetE'/>
<use f='halide/test/generator/embed_image_generator.cpp' l='23' u='c' c='_ZN12_GLOBAL__N_110EmbedImage8generateEv'/>
<use f='halide/test/generator/msan_generator.cpp' l='18' u='c' c='_ZN12_GLOBAL__N_14MSAN8generateEv'/>
<use f='halide/tutorial/lesson_09_update_definitions.cpp' l='710' u='c' c='main'/>
