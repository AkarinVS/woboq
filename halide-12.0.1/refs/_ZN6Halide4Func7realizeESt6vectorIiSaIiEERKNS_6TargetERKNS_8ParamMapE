<dec f='halide/build/include/Halide.h' l='16693' type='Halide::Realization Halide::Func::realize(std::vector&lt;int32_t&gt; sizes = {}, const Halide::Target &amp; target = Halide::Target(), const Halide::ParamMap &amp; param_map = ParamMap::empty_map())'/>
<use f='halide/build/include/Halide.h' l='16711' u='c' c='_ZN6Halide4Func7realizeET_RKNS_6TargetERKNS_8ParamMapE'/>
<use f='halide/build/include/Halide.h' l='18383' u='c' c='_ZN6Halide8evaluateERKNS_4ExprE'/>
<use f='halide/build/include/Halide.h' l='18394' u='c' c='_ZN6Halide8evaluateENS_5TupleET_DpOT0_'/>
<use f='halide/build/include/Halide.h' l='18426' u='c' c='_ZN6Halide16evaluate_may_gpuERKNS_4ExprE'/>
<use f='halide/build/include/Halide.h' l='18440' u='c' c='_ZN6Halide16evaluate_may_gpuENS_5TupleET_DpOT0_'/>
<doc f='halide/build/include/Halide.h' l='16612'>/** Evaluate this function over some rectangular domain and return
     * the resulting buffer or buffers. Performs compilation if the
     * Func has not previously been realized and compile_jit has not
     * been called. If the final stage of the pipeline is on the GPU,
     * data is copied back to the host before being returned. The
     * returned Realization should probably be instantly converted to
     * a Buffer class of the appropriate type. That is, do this:
     *
     \code
     f(x) = sin(x);
     Buffer&lt;float&gt; im = f.realize(...);
     \endcode
     *
     * If your Func has multiple values, because you defined it using
     * a Tuple, then casting the result of a realize call to a buffer
     * or image will produce a run-time error. Instead you should do the
     * following:
     *
     \code
     f(x) = Tuple(x, sin(x));
     Realization r = f.realize(...);
     Buffer&lt;int&gt; im0 = r[0];
     Buffer&lt;float&gt; im1 = r[1];
     \endcode
     *
     * In Halide formal arguments of a computation are specified using
     * Param&lt;T&gt; and ImageParam objects in the expressions defining the
     * computation. The param_map argument to realize allows
     * specifying a set of per-call parameters to be used for a
     * specific computation. This method is thread-safe where the
     * globals used by Param&lt;T&gt; and ImageParam are not. Any parameters
     * that are not in the param_map are taken from the global values,
     * so those can continue to be used if they are not changing
     * per-thread.
     *
     * One can explicitly construct a ParamMap and
     * use its set method to insert Parameter to scalar or Buffer
     * value mappings:
     *
     \code
     Param&lt;int32&gt; p(42);
     ImageParam img(Int(32), 1);
     f(x) = img(x) + p;

     Buffer&lt;int32_t) arg_img(10, 10);
     &lt;fill in arg_img...&gt;
     ParamMap params;
     params.set(p, 17);
     params.set(img, arg_img);

     Target t = get_jit_target_from_environment();
     Buffer&lt;int32_t&gt; result = f.realize({10, 10}, t, params);
     \endcode
     *
     * Alternatively, an initializer list can be used
     * directly in the realize call to pass this information:
     *
     \code
     Param&lt;int32&gt; p(42);
     ImageParam img(Int(32), 1);
     f(x) = img(x) + p;

     Buffer&lt;int32_t) arg_img(10, 10);
     &lt;fill in arg_img...&gt;

     Target t = get_jit_target_from_environment();
     Buffer&lt;int32_t&gt; result = f.realize({10, 10}, t, { { p, 17 }, { img, arg_img } });
     \endcode
     *
     * If the Func cannot be realized into a buffer of the given size
     * due to scheduling constraints on scattering update definitions,
     * it will be realized into a larger buffer of the minimum size
     * possible, and a cropped view at the requested size will be
     * returned. It is thus not safe to assume the returned buffers
     * are contiguous in memory. This behavior can be disabled with
     * the NoBoundsQuery target flag, in which case an error about
     * writing out of bounds on the output buffer will trigger
     * instead.
     *
     */
    // @{</doc>
<use f='halide/python_bindings/src/PyFunc.cpp' l='135' u='c' c='_ZN6Halide14PythonBindings11define_funcERN8pybind117module_E'/>
<use f='halide/python_bindings/src/PyFunc.cpp' l='145' u='c' c='_ZN6Halide14PythonBindings11define_funcERN8pybind117module_E'/>
<use f='halide/python_bindings/src/PyFunc.cpp' l='155' u='c' c='_ZN6Halide14PythonBindings11define_funcERN8pybind117module_E'/>
<use f='halide/python_bindings/src/PyFunc.cpp' l='165' u='c' c='_ZN6Halide14PythonBindings11define_funcERN8pybind117module_E'/>
<use f='halide/python_bindings/src/PyFunc.cpp' l='175' u='c' c='_ZN6Halide14PythonBindings11define_funcERN8pybind117module_E'/>
<dec f='halide/src/Func.h' l='813' type='Halide::Realization Halide::Func::realize(std::vector&lt;int32_t&gt; sizes = {}, const Halide::Target &amp; target = Halide::Target(), const Halide::ParamMap &amp; param_map = ParamMap::empty_map())'/>
<use f='halide/src/Func.h' l='831' u='c' c='_ZN6Halide4Func7realizeET_RKNS_6TargetERKNS_8ParamMapE'/>
<use f='halide/src/Func.h' l='2503' u='c' c='_ZN6Halide8evaluateERKNS_4ExprE'/>
<use f='halide/src/Func.h' l='2514' u='c' c='_ZN6Halide8evaluateENS_5TupleET_DpOT0_'/>
<use f='halide/src/Func.h' l='2546' u='c' c='_ZN6Halide16evaluate_may_gpuERKNS_4ExprE'/>
<use f='halide/src/Func.h' l='2560' u='c' c='_ZN6Halide16evaluate_may_gpuENS_5TupleET_DpOT0_'/>
<doc f='halide/src/Func.h' l='732'>/** Evaluate this function over some rectangular domain and return
     * the resulting buffer or buffers. Performs compilation if the
     * Func has not previously been realized and compile_jit has not
     * been called. If the final stage of the pipeline is on the GPU,
     * data is copied back to the host before being returned. The
     * returned Realization should probably be instantly converted to
     * a Buffer class of the appropriate type. That is, do this:
     *
     \code
     f(x) = sin(x);
     Buffer&lt;float&gt; im = f.realize(...);
     \endcode
     *
     * If your Func has multiple values, because you defined it using
     * a Tuple, then casting the result of a realize call to a buffer
     * or image will produce a run-time error. Instead you should do the
     * following:
     *
     \code
     f(x) = Tuple(x, sin(x));
     Realization r = f.realize(...);
     Buffer&lt;int&gt; im0 = r[0];
     Buffer&lt;float&gt; im1 = r[1];
     \endcode
     *
     * In Halide formal arguments of a computation are specified using
     * Param&lt;T&gt; and ImageParam objects in the expressions defining the
     * computation. The param_map argument to realize allows
     * specifying a set of per-call parameters to be used for a
     * specific computation. This method is thread-safe where the
     * globals used by Param&lt;T&gt; and ImageParam are not. Any parameters
     * that are not in the param_map are taken from the global values,
     * so those can continue to be used if they are not changing
     * per-thread.
     *
     * One can explicitly construct a ParamMap and
     * use its set method to insert Parameter to scalar or Buffer
     * value mappings:
     *
     \code
     Param&lt;int32&gt; p(42);
     ImageParam img(Int(32), 1);
     f(x) = img(x) + p;

     Buffer&lt;int32_t) arg_img(10, 10);
     &lt;fill in arg_img...&gt;
     ParamMap params;
     params.set(p, 17);
     params.set(img, arg_img);

     Target t = get_jit_target_from_environment();
     Buffer&lt;int32_t&gt; result = f.realize({10, 10}, t, params);
     \endcode
     *
     * Alternatively, an initializer list can be used
     * directly in the realize call to pass this information:
     *
     \code
     Param&lt;int32&gt; p(42);
     ImageParam img(Int(32), 1);
     f(x) = img(x) + p;

     Buffer&lt;int32_t) arg_img(10, 10);
     &lt;fill in arg_img...&gt;

     Target t = get_jit_target_from_environment();
     Buffer&lt;int32_t&gt; result = f.realize({10, 10}, t, { { p, 17 }, { img, arg_img } });
     \endcode
     *
     * If the Func cannot be realized into a buffer of the given size
     * due to scheduling constraints on scattering update definitions,
     * it will be realized into a larger buffer of the minimum size
     * possible, and a cropped view at the requested size will be
     * returned. It is thus not safe to assume the returned buffers
     * are contiguous in memory. This behavior can be disabled with
     * the NoBoundsQuery target flag, in which case an error about
     * writing out of bounds on the output buffer will trigger
     * instead.
     *
     */
    // @{</doc>
<def f='halide/src/Func.cpp' l='3088' ll='3092' type='Halide::Realization Halide::Func::realize(std::vector&lt;int32_t&gt; sizes = {}, const Halide::Target &amp; target = Halide::Target(), const Halide::ParamMap &amp; param_map = ParamMap::empty_map())'/>
<use f='halide/src/Func.cpp' l='3096' u='c' c='_ZN6Halide4Func7realizeEiiiiRKNS_6TargetERKNS_8ParamMapE'/>
<use f='halide/src/Func.cpp' l='3101' u='c' c='_ZN6Halide4Func7realizeEiiiRKNS_6TargetERKNS_8ParamMapE'/>
<use f='halide/src/Func.cpp' l='3106' u='c' c='_ZN6Halide4Func7realizeEiiRKNS_6TargetERKNS_8ParamMapE'/>
<use f='halide/src/Generator.cpp' l='2070' u='c' c='_ZN6Halide8Internal20StubOutputBufferBase7realizeESt6vectorIiSaIiEE'/>
<use f='halide/tutorial/lesson_01_basics.cpp' l='78' u='c' c='main'/>
<use f='halide/tutorial/lesson_02_input_image.cpp' l='95' u='c' c='main'/>
<use f='halide/tutorial/lesson_03_debugging_1.cpp' l='41' u='c' c='main'/>
<use f='halide/tutorial/lesson_04_debugging_2.cpp' l='39' u='c' c='main'/>
<use f='halide/tutorial/lesson_04_debugging_2.cpp' l='70' u='c' c='main'/>
<use f='halide/tutorial/lesson_04_debugging_2.cpp' l='91' u='c' c='main'/>
<use f='halide/tutorial/lesson_04_debugging_2.cpp' l='104' u='c' c='main'/>
<use f='halide/tutorial/lesson_04_debugging_2.cpp' l='114' u='c' c='main'/>
<use f='halide/tutorial/lesson_04_debugging_2.cpp' l='134' u='c' c='main'/>
<use f='halide/tutorial/lesson_04_debugging_2.cpp' l='142' u='c' c='main'/>
<use f='halide/tutorial/lesson_05_scheduling_1.cpp' l='45' u='c' c='main'/>
<use f='halide/tutorial/lesson_05_scheduling_1.cpp' l='91' u='c' c='main'/>
<use f='halide/tutorial/lesson_05_scheduling_1.cpp' l='133' u='c' c='main'/>
<use f='halide/tutorial/lesson_05_scheduling_1.cpp' l='171' u='c' c='main'/>
<use f='halide/tutorial/lesson_05_scheduling_1.cpp' l='211' u='c' c='main'/>
<use f='halide/tutorial/lesson_05_scheduling_1.cpp' l='270' u='c' c='main'/>
<use f='halide/tutorial/lesson_05_scheduling_1.cpp' l='323' u='c' c='main'/>
<use f='halide/tutorial/lesson_05_scheduling_1.cpp' l='365' u='c' c='main'/>
<use f='halide/tutorial/lesson_05_scheduling_1.cpp' l='451' u='c' c='main'/>
<use f='halide/tutorial/lesson_05_scheduling_1.cpp' l='512' u='c' c='main'/>
<use f='halide/tutorial/lesson_07_multi_stage_pipelines.cpp' l='161' u='c' c='main'/>
<use f='halide/tutorial/lesson_08_scheduling_2.cpp' l='49' u='c' c='main'/>
<use f='halide/tutorial/lesson_08_scheduling_2.cpp' l='105' u='c' c='main'/>
<use f='halide/tutorial/lesson_08_scheduling_2.cpp' l='212' u='c' c='main'/>
<use f='halide/tutorial/lesson_08_scheduling_2.cpp' l='288' u='c' c='main'/>
<use f='halide/tutorial/lesson_08_scheduling_2.cpp' l='398' u='c' c='main'/>
<use f='halide/tutorial/lesson_08_scheduling_2.cpp' l='501' u='c' c='main'/>
<use f='halide/tutorial/lesson_08_scheduling_2.cpp' l='589' u='c' c='main'/>
<use f='halide/tutorial/lesson_09_update_definitions.cpp' l='95' u='c' c='main'/>
<use f='halide/tutorial/lesson_09_update_definitions.cpp' l='108' u='c' c='main'/>
<use f='halide/tutorial/lesson_09_update_definitions.cpp' l='154' u='c' c='main'/>
<use f='halide/tutorial/lesson_09_update_definitions.cpp' l='208' u='c' c='main'/>
<use f='halide/tutorial/lesson_09_update_definitions.cpp' l='266' u='c' c='main'/>
<use f='halide/tutorial/lesson_09_update_definitions.cpp' l='327' u='c' c='main'/>
<use f='halide/tutorial/lesson_09_update_definitions.cpp' l='386' u='c' c='main'/>
<use f='halide/tutorial/lesson_09_update_definitions.cpp' l='438' u='c' c='main'/>
<use f='halide/tutorial/lesson_09_update_definitions.cpp' l='481' u='c' c='main'/>
<use f='halide/tutorial/lesson_09_update_definitions.cpp' l='548' u='c' c='main'/>
<use f='halide/tutorial/lesson_09_update_definitions.cpp' l='604' u='c' c='main'/>
<use f='halide/tutorial/lesson_09_update_definitions.cpp' l='661' u='c' c='main'/>
<use f='halide/tutorial/lesson_09_update_definitions.cpp' l='723' u='c' c='main'/>
<use f='halide/tutorial/lesson_09_update_definitions.cpp' l='724' u='c' c='main'/>
<use f='halide/tutorial/lesson_09_update_definitions.cpp' l='786' u='c' c='main'/>
<use f='halide/tutorial/lesson_12_using_the_gpu.cpp' l='231' u='c' c='_ZN10MyPipeline16test_correctnessEN6Halide6BufferIhEE'/>
<use f='halide/tutorial/lesson_13_tuples.cpp' l='94' u='c' c='main'/>
<use f='halide/tutorial/lesson_13_tuples.cpp' l='150' u='c' c='main'/>
<use f='halide/tutorial/lesson_13_tuples.cpp' l='186' u='c' c='main'/>
<use f='halide/tutorial/lesson_13_tuples.cpp' l='287' u='c' c='main'/>
<use f='halide/tutorial/lesson_17_predicated_rdom.cpp' l='63' u='c' c='main'/>
<use f='halide/tutorial/lesson_17_predicated_rdom.cpp' l='119' u='c' c='main'/>
<use f='halide/tutorial/lesson_17_predicated_rdom.cpp' l='175' u='c' c='main'/>
<use f='halide/tutorial/lesson_18_parallel_associative_reductions.cpp' l='49' u='c' c='main'/>
<use f='halide/tutorial/lesson_18_parallel_associative_reductions.cpp' l='95' u='c' c='main'/>
<use f='halide/tutorial/lesson_18_parallel_associative_reductions.cpp' l='159' u='c' c='main'/>
<use f='halide/tutorial/lesson_18_parallel_associative_reductions.cpp' l='226' u='c' c='main'/>
<use f='halide/tutorial/lesson_18_parallel_associative_reductions.cpp' l='297' u='c' c='main'/>
<use f='halide/tutorial/lesson_19_wrapper_funcs.cpp' l='69' u='c' c='main'/>
<use f='halide/tutorial/lesson_19_wrapper_funcs.cpp' l='125' u='c' c='main'/>
<use f='halide/tutorial/lesson_19_wrapper_funcs.cpp' l='164' u='c' c='main'/>
<use f='halide/tutorial/lesson_19_wrapper_funcs.cpp' l='208' u='c' c='main'/>
<use f='halide/tutorial/lesson_19_wrapper_funcs.cpp' l='261' u='c' c='main'/>
<use f='halide/tutorial/lesson_19_wrapper_funcs.cpp' l='319' u='c' c='main'/>
<use f='halide/tutorial/lesson_19_wrapper_funcs.cpp' l='406' u='c' c='main'/>
<use f='halide/tutorial/lesson_20_cloning_funcs.cpp' l='77' u='c' c='main'/>
<use f='halide/tutorial/lesson_20_cloning_funcs.cpp' l='137' u='c' c='main'/>
