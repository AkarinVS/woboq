<dec f='halide/build/include/Halide.h' l='11774' type='Halide::Internal::ModulusRemainder Halide::Internal::modulus_remainder(const Halide::Expr &amp; e)'/>
<doc f='halide/build/include/Halide.h' l='11762'>/** For things like alignment analysis, often it&apos;s helpful to know
 * if an integer expression is some multiple of a constant plus
 * some other constant. For example, it is straight-forward to
 * deduce that ((10*x + 2)*(6*y - 3) - 1) is congruent to five
 * modulo six.
 *
 * We get the most information when the modulus is large. E.g. if
 * something is congruent to 208 modulo 384, then we also know it&apos;s
 * congruent to 0 mod 8, and we can possibly use it as an index for an
 * aligned load. If all else fails, we can just say that an integer is
 * congruent to zero modulo one.
 */</doc>
<dec f='halide/src/ModulusRemainder.h' l='76' type='Halide::Internal::ModulusRemainder Halide::Internal::modulus_remainder(const Halide::Expr &amp; e)'/>
<doc f='halide/src/ModulusRemainder.h' l='64'>/** For things like alignment analysis, often it&apos;s helpful to know
 * if an integer expression is some multiple of a constant plus
 * some other constant. For example, it is straight-forward to
 * deduce that ((10*x + 2)*(6*y - 3) - 1) is congruent to five
 * modulo six.
 *
 * We get the most information when the modulus is large. E.g. if
 * something is congruent to 208 modulo 384, then we also know it&apos;s
 * congruent to 0 mod 8, and we can possibly use it as an index for an
 * aligned load. If all else fails, we can just say that an integer is
 * congruent to zero modulo one.
 */</doc>
<def f='halide/src/ModulusRemainder.cpp' l='282' ll='285' type='Halide::Internal::ModulusRemainder Halide::Internal::modulus_remainder(const Halide::Expr &amp; e)'/>
<use f='halide/src/ModulusRemainder.cpp' l='293' u='c' c='_ZN6Halide8Internal18reduce_expr_moduloERKNS_4ExprElPl'/>
<use f='halide/src/ModulusRemainder.cpp' l='327' u='c' c='_ZN6Halide8Internal12_GLOBAL__N_15checkERKNS_4ExprEll'/>
