<dec f='halide/build/include/Halide.h' l='7663' type='Halide::Expr Halide::mux(const Halide::Expr &amp; id, const std::initializer_list&lt;Expr&gt; &amp; values)'/>
<doc f='halide/build/include/Halide.h' l='7650'>/** Oftentimes we want to pack a list of expressions with the same type
 * into a channel dimension, e.g.,
 * img(x, y, c) = select(c == 0, 100, // Red
 *                       c == 1, 50,  // Green
 *                               25); // Blue
 * This is tedious when the list is long. The following function
 * provide convinent syntax that allow one to write:
 * img(x, y, c) = mux(c, {100, 50, 25});
 *
 * As with the select equivalent, if the first argument (the index) is
 * out of range, the expression evaluates to the last value.
 */
// @{</doc>
<dec f='halide/src/IROperator.h' l='858' type='Halide::Expr Halide::mux(const Halide::Expr &amp; id, const std::initializer_list&lt;Expr&gt; &amp; values)'/>
<doc f='halide/src/IROperator.h' l='845'>/** Oftentimes we want to pack a list of expressions with the same type
 * into a channel dimension, e.g.,
 * img(x, y, c) = select(c == 0, 100, // Red
 *                       c == 1, 50,  // Green
 *                               25); // Blue
 * This is tedious when the list is long. The following function
 * provide convinent syntax that allow one to write:
 * img(x, y, c) = mux(c, {100, 50, 25});
 *
 * As with the select equivalent, if the first argument (the index) is
 * out of range, the expression evaluates to the last value.
 */
// @{</doc>
<def f='halide/src/IROperator.cpp' l='1504' ll='1506' type='Halide::Expr Halide::mux(const Halide::Expr &amp; id, const std::initializer_list&lt;Expr&gt; &amp; values)'/>
