<def f='halide/build-apps/abseil-cpp/absl/synchronization/blocking_counter.h' l='61' ll='94'/>
<use f='halide/build-apps/abseil-cpp/absl/synchronization/blocking_counter.h' l='66' c='_ZN4absl14lts_2020_02_2515BlockingCounterC1ERKS1_'/>
<use f='halide/build-apps/abseil-cpp/absl/synchronization/blocking_counter.h' l='67' c='_ZN4absl14lts_2020_02_2515BlockingCounteraSERKS1_'/>
<use f='halide/build-apps/abseil-cpp/absl/synchronization/blocking_counter.h' l='67' c='_ZN4absl14lts_2020_02_2515BlockingCounteraSERKS1_'/>
<size>16</size>
<doc f='halide/build-apps/abseil-cpp/absl/synchronization/blocking_counter.h' l='29'>// BlockingCounter
//
// This class allows a thread to block for a pre-specified number of actions.
// `BlockingCounter` maintains a single non-negative abstract integer &quot;count&quot;
// with an initial value `initial_count`. A thread can then call `Wait()` on
// this blocking counter to block until the specified number of events occur;
// worker threads then call &apos;DecrementCount()` on the counter upon completion of
// their work. Once the counter&apos;s internal &quot;count&quot; reaches zero, the blocked
// thread unblocks.
//
// A `BlockingCounter` requires the following:
//     - its `initial_count` is non-negative.
//     - the number of calls to `DecrementCount()` on it is at most
//       `initial_count`.
//     - `Wait()` is called at most once on it.
//
// Given the above requirements, a `BlockingCounter` provides the following
// guarantees:
//     - Once its internal &quot;count&quot; reaches zero, no legal action on the object
//       can further change the value of &quot;count&quot;.
//     - When `Wait()` returns, it is legal to destroy the `BlockingCounter`.
//     - When `Wait()` returns, the number of calls to `DecrementCount()` on
//       this blocking counter exactly equals `initial_count`.
//
// Example:
//     BlockingCounter bcount(N);         // there are N items of work
//     ... Allow worker threads to start.
//     ... On completing each work item, workers do:
//     ... bcount.DecrementCount();      // an item of work has been completed
//
//     bcount.Wait();                    // wait for all work to be complete
//</doc>
<fun r='_ZN4absl14lts_2020_02_2515BlockingCounterC1Ei'/>
<fun r='_ZN4absl14lts_2020_02_2515BlockingCounterC1ERKS1_'/>
<fun r='_ZN4absl14lts_2020_02_2515BlockingCounteraSERKS1_'/>
<fun r='_ZN4absl14lts_2020_02_2515BlockingCounter14DecrementCountEv'/>
<fun r='_ZN4absl14lts_2020_02_2515BlockingCounter4WaitEv'/>
<mbr r='absl::lts_2020_02_25::BlockingCounter::lock_' o='0' t='absl::lts_2020_02_25::Mutex'/>
<mbr r='absl::lts_2020_02_25::BlockingCounter::count_' o='64' t='int'/>
<mbr r='absl::lts_2020_02_25::BlockingCounter::num_waiting_' o='96' t='int'/>
<fun r='_ZN4absl14lts_2020_02_2515BlockingCounter14DecrementCountEv'/>
<fun r='_ZN4absl14lts_2020_02_2515BlockingCounter4WaitEv'/>
