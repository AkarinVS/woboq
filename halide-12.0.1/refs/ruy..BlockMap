<def f='halide/build-apps/ruy/ruy/block_map.h' l='82' ll='104'/>
<use f='halide/build-apps/ruy/ruy/block_map.h' l='121' c='_ZN3ruy12MakeBlockMapEiiiiiiiiRKNS_14CpuCacheParamsEPNS_8BlockMapE'/>
<use f='halide/build-apps/ruy/ruy/block_map.h' l='124' c='_ZN3ruy15GetBlockByIndexERKNS_8BlockMapEiPNS_8SidePairIiEE'/>
<use f='halide/build-apps/ruy/ruy/block_map.h' l='131' c='_ZN3ruy20GetBlockMatrixCoordsENS_4SideERKNS_8BlockMapEiPiS4_'/>
<use f='halide/build-apps/ruy/ruy/block_map.h' l='137' c='_ZN3ruy20GetBlockMatrixCoordsERKNS_8BlockMapERKNS_8SidePairIiEEPS4_S7_'/>
<use f='halide/build-apps/ruy/ruy/block_map.h' l='142' c='_ZN3ruy16NumBlocksPerSideENS_4SideERKNS_8BlockMapE'/>
<use f='halide/build-apps/ruy/ruy/block_map.h' l='154' c='_ZN3ruy9NumBlocksERKNS_8BlockMapE'/>
<use f='halide/build-apps/ruy/ruy/block_map.cc' l='93' c='_ZN3ruy15GetBlockByIndexERKNS_8BlockMapEiPNS_8SidePairIiEE'/>
<use f='halide/build-apps/ruy/ruy/block_map.cc' l='342' c='_ZN3ruy12MakeBlockMapEiiiiiiiiRKNS_14CpuCacheParamsEPNS_8BlockMapE'/>
<use f='halide/build-apps/ruy/ruy/block_map.cc' l='473' c='_ZN3ruy20GetBlockMatrixCoordsENS_4SideERKNS_8BlockMapEiPiS4_'/>
<use f='halide/build-apps/ruy/ruy/block_map.cc' l='490' c='_ZN3ruy20GetBlockMatrixCoordsERKNS_8BlockMapERKNS_8SidePairIiEEPS4_S7_'/>
<size>52</size>
<doc f='halide/build-apps/ruy/ruy/block_map.h' l='35'>// A BlockMap describes a tiling of a matrix, typically the destination matrix
// of a matrix multiplication computation. As is standard in matrix
// multiplication, a tile is called a &quot;block&quot;.
//
// Ruy subdivides work by blocks of the destination matrix: each thread fully
// computes a block at once, then moves on to another block; each block is
// produced by a single thread.
//
// This ensures that the workloads for each block are mutually independent,
// which reduces synchronization requirements.
//
// Typically, a matrix multiplication will early on create a BlockMap by
// calling MakeBlockMap. It will then query the number of blocks in that
// BlockMap by calling NumBlocks. It will then create a single atomic integer
// counter indexing these blocks, called the &apos;index&apos;, and will distribute
// work to its N threads by ensuring that each thread works on disjoint sets
// of index values. For a given index value, the thread will call
// GetBlockByIndex to get the corresponding block, then GetBlockMatrixCoords
// to find the actual row and column numbers of this block.
//
// There are two nested levels of subdivision. On a local level, the matrix is
// tiled into a square NxN grid where N is a power of two, specifically:
//   N = 2^num_blocks_base_log2.
//
// At a larger scale, around these blocks, there may be one further
// level of subdivision, in only one dimension: either along rows or along
// columns. That is used to handle arbitrarily rectangular matrices. The
// aforementioned high-level block grid is square, so it does not readily fit
// well very rectangular matrices.
//
// Taking together these two nested levels of subdivision, the effective
// tiling is by
//   2^(num_blocks_base_log2 + rows_rectangularness_log2)
// blocks in the row dimension, and by
//   2^(num_blocks_base_log2 + cols_rectangularness_log2)
// blocks in the column dimension. See NumBlocksOfRows, NumBlocksOfCols.
//
// Either rows_rectangularness_log2 or cols_rectangularness_log2 must be zero.
//
// Finally, this BlockMap is designed to operate under alignment constraints:
// two fields, kernel_rows and kernel_cols, describe the requested alignment
// of the effective grid in both dimensions. The idea is to feed matrix
// multiplication kernels with tiles that fit their width as much as possible.
// Of course, if rows (resp. cols) is not a multiple of kernel_rows (resp.
// kernel_cols) then some tile will have to have unaligned size. BlockMap
// will only allow that to happen in the last position along each axis, so
// as to minimize the overhead incurred onto the matrix multiplication kernels.</doc>
<mbr r='ruy::BlockMap::thread_count' o='0' t='int'/>
<mbr r='ruy::BlockMap::traversal_order' o='32' t='ruy::BlockMapTraversalOrder'/>
<mbr r='ruy::BlockMap::dims' o='64' t='SidePair&lt;int&gt;'/>
<mbr r='ruy::BlockMap::num_blocks_base_log2' o='128' t='int'/>
<mbr r='ruy::BlockMap::rectangularness_log2' o='160' t='SidePair&lt;int&gt;'/>
<mbr r='ruy::BlockMap::kernel_dims' o='224' t='SidePair&lt;int&gt;'/>
<mbr r='ruy::BlockMap::small_block_dims' o='288' t='SidePair&lt;int&gt;'/>
<mbr r='ruy::BlockMap::large_blocks' o='352' t='SidePair&lt;int&gt;'/>
<use f='halide/build-apps/ruy/ruy/trmul.cc' l='59' c='_ZN3ruy12_GLOBAL__N_19TrMulTaskC1EPNS_11TrMulParamsERKNS_8BlockMapEPSt6atomicIiEibNS_8SidePairIPS7_INS0_13PackingStatusEEEEPNS_14TuningResolverEPNS_9A5522035'/>
<use f='halide/build-apps/ruy/ruy/trmul.cc' l='236'/>
<use f='halide/build-apps/ruy/ruy/trmul.cc' l='345' c='_ZN3ruy5TrMulEPNS_3CtxEPNS_11TrMulParamsE'/>
<size>52</size>
