<def f='halide/build/include/Halide.h' l='9920' ll='9922' type='Buffer&lt;T, D&gt; Halide::Runtime::Buffer::alias() const'/>
<doc f='halide/build/include/Halide.h' l='9911'>/** Make a copy of the Buffer which shares the underlying host and/or device
     * allocations as the existing Buffer. This is purely syntactic sugar for
     * cases where you have a const reference to a Buffer but need a temporary
     * non-const copy (e.g. to make a call into AOT-generated Halide code), and want a terse
     * inline way to create a temporary. \code
     * void call_my_func(const Buffer&lt;const uint8_t&gt;&amp; input) {
     *     my_func(input.alias(), output);
     * }\endcode
     */</doc>
<def f='halide/src/runtime/HalideBuffer.h' l='1158' ll='1160' type='Buffer&lt;T, D&gt; Halide::Runtime::Buffer::alias() const'/>
<doc f='halide/src/runtime/HalideBuffer.h' l='1149'>/** Make a copy of the Buffer which shares the underlying host and/or device
     * allocations as the existing Buffer. This is purely syntactic sugar for
     * cases where you have a const reference to a Buffer but need a temporary
     * non-const copy (e.g. to make a call into AOT-generated Halide code), and want a terse
     * inline way to create a temporary. \code
     * void call_my_func(const Buffer&lt;const uint8_t&gt;&amp; input) {
     *     my_func(input.alias(), output);
     * }\endcode
     */</doc>
<use f='halide/src/autoschedulers/adams2019/DefaultCostModel.cpp' l='220' u='c' c='_ZN6Halide16DefaultCostModel8backpropERKNS_7Runtime6BufferIKfLi4EEEf'/>
