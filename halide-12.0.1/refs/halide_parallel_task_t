<def f='halide/build/include/HalideRuntime.h' l='201' ll='244'/>
<use f='halide/build/include/HalideRuntime.h' l='253' c='halide_do_parallel_tasks'/>
<use f='halide/build/include/HalideRuntime.h' l='281'/>
<use f='halide/build/include/HalideRuntime.h' l='300' c='halide_default_do_parallel_tasks'/>
<size>56</size>
<doc f='halide/build/include/HalideRuntime.h' l='195'>/** A parallel task to be passed to halide_do_parallel_tasks. This
 * task may recursively call halide_do_parallel_tasks, and there may
 * be complex dependencies between seemingly unrelated tasks expressed
 * using semaphores. If you are using a custom task system, care must
 * be taken to avoid potential deadlock. This can be done by carefully
 * respecting the static metadata at the end of the task struct.*/</doc>
<mbr r='halide_parallel_task_t::fn' o='0' t='halide_loop_task_t'/>
<mbr r='halide_parallel_task_t::closure' o='64' t='uint8_t *'/>
<mbr r='halide_parallel_task_t::name' o='128' t='const char *'/>
<mbr r='halide_parallel_task_t::semaphores' o='192' t='struct halide_semaphore_acquire_t *'/>
<mbr r='halide_parallel_task_t::num_semaphores' o='256' t='int'/>
<mbr r='halide_parallel_task_t::min' o='288' t='int'/>
<mbr r='halide_parallel_task_t::extent' o='320' t='int'/>
<mbr r='halide_parallel_task_t::min_threads' o='352' t='int'/>
<mbr r='halide_parallel_task_t::serial' o='384' t='bool'/>
<def f='halide/build/include/Halide.h' l='299' ll='342'/>
<use f='halide/build/include/Halide.h' l='351' c='halide_do_parallel_tasks'/>
<use f='halide/build/include/Halide.h' l='379'/>
<use f='halide/build/include/Halide.h' l='398' c='halide_default_do_parallel_tasks'/>
<use f='halide/build/include/Halide.h' l='3398'/>
<size>56</size>
<doc f='halide/build/include/Halide.h' l='293'>/** A parallel task to be passed to halide_do_parallel_tasks. This
 * task may recursively call halide_do_parallel_tasks, and there may
 * be complex dependencies between seemingly unrelated tasks expressed
 * using semaphores. If you are using a custom task system, care must
 * be taken to avoid potential deadlock. This can be done by carefully
 * respecting the static metadata at the end of the task struct.*/</doc>
<mbr r='halide_parallel_task_t::fn' o='0' t='halide_loop_task_t'/>
<mbr r='halide_parallel_task_t::closure' o='64' t='uint8_t *'/>
<mbr r='halide_parallel_task_t::name' o='128' t='const char *'/>
<mbr r='halide_parallel_task_t::semaphores' o='192' t='struct halide_semaphore_acquire_t *'/>
<mbr r='halide_parallel_task_t::num_semaphores' o='256' t='int'/>
<mbr r='halide_parallel_task_t::min' o='288' t='int'/>
<mbr r='halide_parallel_task_t::extent' o='320' t='int'/>
<mbr r='halide_parallel_task_t::min_threads' o='352' t='int'/>
<mbr r='halide_parallel_task_t::serial' o='384' t='bool'/>
<def f='halide/src/runtime/HalideRuntime.h' l='201' ll='244'/>
<use f='halide/src/runtime/HalideRuntime.h' l='253' c='halide_do_parallel_tasks'/>
<use f='halide/src/runtime/HalideRuntime.h' l='281'/>
<use f='halide/src/runtime/HalideRuntime.h' l='300' c='halide_default_do_parallel_tasks'/>
<use f='halide/src/Type.h' l='177'/>
<size>56</size>
<doc f='halide/src/runtime/HalideRuntime.h' l='195'>/** A parallel task to be passed to halide_do_parallel_tasks. This
 * task may recursively call halide_do_parallel_tasks, and there may
 * be complex dependencies between seemingly unrelated tasks expressed
 * using semaphores. If you are using a custom task system, care must
 * be taken to avoid potential deadlock. This can be done by carefully
 * respecting the static metadata at the end of the task struct.*/</doc>
<mbr r='halide_parallel_task_t::fn' o='0' t='halide_loop_task_t'/>
<mbr r='halide_parallel_task_t::closure' o='64' t='uint8_t *'/>
<mbr r='halide_parallel_task_t::name' o='128' t='const char *'/>
<mbr r='halide_parallel_task_t::semaphores' o='192' t='struct halide_semaphore_acquire_t *'/>
<mbr r='halide_parallel_task_t::num_semaphores' o='256' t='int'/>
<mbr r='halide_parallel_task_t::min' o='288' t='int'/>
<mbr r='halide_parallel_task_t::extent' o='320' t='int'/>
<mbr r='halide_parallel_task_t::min_threads' o='352' t='int'/>
<mbr r='halide_parallel_task_t::serial' o='384' t='bool'/>
<def f='halide/build/tutorial/lesson_10_halide.h' l='273' ll='316'/>
<use f='halide/build/tutorial/lesson_10_halide.h' l='325' c='halide_do_parallel_tasks'/>
<use f='halide/build/tutorial/lesson_10_halide.h' l='353'/>
<use f='halide/build/tutorial/lesson_10_halide.h' l='372' c='halide_default_do_parallel_tasks'/>
<size>56</size>
<doc f='halide/build/tutorial/lesson_10_halide.h' l='267'>/** A parallel task to be passed to halide_do_parallel_tasks. This
 * task may recursively call halide_do_parallel_tasks, and there may
 * be complex dependencies between seemingly unrelated tasks expressed
 * using semaphores. If you are using a custom task system, care must
 * be taken to avoid potential deadlock. This can be done by carefully
 * respecting the static metadata at the end of the task struct.*/</doc>
<mbr r='halide_parallel_task_t::fn' o='0' t='halide_loop_task_t'/>
<mbr r='halide_parallel_task_t::closure' o='64' t='uint8_t *'/>
<mbr r='halide_parallel_task_t::name' o='128' t='const char *'/>
<mbr r='halide_parallel_task_t::semaphores' o='192' t='struct halide_semaphore_acquire_t *'/>
<mbr r='halide_parallel_task_t::num_semaphores' o='256' t='int'/>
<mbr r='halide_parallel_task_t::min' o='288' t='int'/>
<mbr r='halide_parallel_task_t::extent' o='320' t='int'/>
<mbr r='halide_parallel_task_t::min_threads' o='352' t='int'/>
<mbr r='halide_parallel_task_t::serial' o='384' t='bool'/>
