<def f='halide/build/include/Halide.h' l='3038' ll='3067'/>
<use f='halide/build/include/Halide.h' l='3063' c='_ZN6Halide8Internal13TemporaryFileC1ERKS1_'/>
<use f='halide/build/include/Halide.h' l='3064' c='_ZN6Halide8Internal13TemporaryFileaSERKS1_'/>
<use f='halide/build/include/Halide.h' l='3064' c='_ZN6Halide8Internal13TemporaryFileaSERKS1_'/>
<use f='halide/build/include/Halide.h' l='3065' c='_ZN6Halide8Internal13TemporaryFileC1EOS1_'/>
<use f='halide/build/include/Halide.h' l='3066' c='_ZN6Halide8Internal13TemporaryFileaSEOS1_'/>
<use f='halide/build/include/Halide.h' l='3066' c='_ZN6Halide8Internal13TemporaryFileaSEOS1_'/>
<size>40</size>
<doc f='halide/build/include/Halide.h' l='3032'>/** A simple utility class that creates a temporary file in its ctor and
 * deletes that file in its dtor; this is useful for temporary files that you
 * want to ensure are deleted when exiting a certain scope. Since this is essentially
 * just an RAII wrapper around file_make_temp() and file_unlink(), it has the same
 * failure modes (i.e.: assertion upon error).
 */</doc>
<fun r='_ZN6Halide8Internal13TemporaryFileC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_'/>
<fun r='_ZNK6Halide8Internal13TemporaryFile8pathnameB5cxx11Ev'/>
<fun r='_ZN6Halide8Internal13TemporaryFileD1Ev'/>
<fun r='_ZN6Halide8Internal13TemporaryFile6detachEv'/>
<mbr r='Halide::Internal::TemporaryFile::temp_path' o='0' t='const std::string'/>
<mbr r='Halide::Internal::TemporaryFile::do_unlink' o='256' t='bool'/>
<fun r='_ZN6Halide8Internal13TemporaryFileC1ERKS1_'/>
<fun r='_ZN6Halide8Internal13TemporaryFileaSERKS1_'/>
<fun r='_ZN6Halide8Internal13TemporaryFileC1EOS1_'/>
<fun r='_ZN6Halide8Internal13TemporaryFileaSEOS1_'/>
<def f='halide/src/Util.h' l='286' ll='315'/>
<use f='halide/src/Util.h' l='311' c='_ZN6Halide8Internal13TemporaryFileC1ERKS1_'/>
<use f='halide/src/Util.h' l='312' c='_ZN6Halide8Internal13TemporaryFileaSERKS1_'/>
<use f='halide/src/Util.h' l='312' c='_ZN6Halide8Internal13TemporaryFileaSERKS1_'/>
<use f='halide/src/Util.h' l='313' c='_ZN6Halide8Internal13TemporaryFileC1EOS1_'/>
<use f='halide/src/Util.h' l='314' c='_ZN6Halide8Internal13TemporaryFileaSEOS1_'/>
<use f='halide/src/Util.h' l='314' c='_ZN6Halide8Internal13TemporaryFileaSEOS1_'/>
<size>40</size>
<doc f='halide/src/Util.h' l='280'>/** A simple utility class that creates a temporary file in its ctor and
 * deletes that file in its dtor; this is useful for temporary files that you
 * want to ensure are deleted when exiting a certain scope. Since this is essentially
 * just an RAII wrapper around file_make_temp() and file_unlink(), it has the same
 * failure modes (i.e.: assertion upon error).
 */</doc>
<fun r='_ZN6Halide8Internal13TemporaryFileC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_'/>
<fun r='_ZNK6Halide8Internal13TemporaryFile8pathnameB5cxx11Ev'/>
<fun r='_ZN6Halide8Internal13TemporaryFileD1Ev'/>
<fun r='_ZN6Halide8Internal13TemporaryFile6detachEv'/>
<mbr r='Halide::Internal::TemporaryFile::temp_path' o='0' t='const std::string'/>
<mbr r='Halide::Internal::TemporaryFile::do_unlink' o='256' t='bool'/>
<fun r='_ZN6Halide8Internal13TemporaryFileC1ERKS1_'/>
<fun r='_ZN6Halide8Internal13TemporaryFileaSERKS1_'/>
<fun r='_ZN6Halide8Internal13TemporaryFileC1EOS1_'/>
<fun r='_ZN6Halide8Internal13TemporaryFileaSEOS1_'/>
<use f='halide/src/CodeGen_PTX_Dev.cpp' l='722' c='_ZN6Halide8Internal12_GLOBAL__N_115CodeGen_PTX_Dev14compile_to_srcEv'/>
<use f='halide/src/CodeGen_PTX_Dev.cpp' l='723' c='_ZN6Halide8Internal12_GLOBAL__N_115CodeGen_PTX_Dev14compile_to_srcEv'/>
<size>40</size>
<use f='halide/src/HexagonOffload.cpp' l='1083' c='_ZN6Halide8Internal39compile_module_to_hexagon_shared_objectERKNS_6ModuleE'/>
<use f='halide/src/HexagonOffload.cpp' l='1084' c='_ZN6Halide8Internal39compile_module_to_hexagon_shared_objectERKNS_6ModuleE'/>
<size>40</size>
