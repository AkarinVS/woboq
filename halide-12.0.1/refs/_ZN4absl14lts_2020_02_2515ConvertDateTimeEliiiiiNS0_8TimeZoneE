<dec f='halide/build-apps/abseil-cpp/absl/time/time.h' l='1156' type='absl::lts_2020_02_25::TimeConversion absl::lts_2020_02_25::ConvertDateTime(int64_t year, int mon, int day, int hour, int min, int sec, absl::lts_2020_02_25::TimeZone tz)'/>
<use f='halide/build-apps/abseil-cpp/absl/time/time.h' l='1176' u='c' c='_ZN4absl14lts_2020_02_2512FromDateTimeEliiiiiNS0_8TimeZoneE'/>
<doc f='halide/build-apps/abseil-cpp/absl/time/time.h' l='1137'>// ConvertDateTime()
//
// Legacy version of `absl::TimeZone::At(absl::CivilSecond)` that takes
// the civil time as six, separate values (YMDHMS).
//
// The input month, day, hour, minute, and second values can be outside
// of their valid ranges, in which case they will be &quot;normalized&quot; during
// the conversion.
//
// Example:
//
//   // &quot;October 32&quot; normalizes to &quot;November 1&quot;.
//   absl::TimeConversion tc =
//       absl::ConvertDateTime(2013, 10, 32, 8, 30, 0, lax);
//   // tc.kind == TimeConversion::UNIQUE &amp;&amp; tc.normalized == true
//   // absl::ToCivilDay(tc.pre, tz).month() == 11
//   // absl::ToCivilDay(tc.pre, tz).day() == 1
//
// Deprecated. Use `absl::TimeZone::At(CivilSecond)`.</doc>
<def f='halide/build-apps/abseil-cpp/absl/time/time.cc' l='401' ll='431' type='absl::TimeConversion absl::lts_2020_02_25::ConvertDateTime(int64_t year, int mon, int day, int hour, int min, int sec, absl::lts_2020_02_25::TimeZone tz)'/>
<doc f='halide/build-apps/abseil-cpp/absl/time/time.cc' l='397'>//
// Conversions involving time zones.
//</doc>
