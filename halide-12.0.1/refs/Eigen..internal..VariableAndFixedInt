<use f='halide/build-apps/eigen/Eigen/src/Core/util/IntegralConstant.h' l='57' c='_ZN5Eigen8internal8FixedIntC1ENS0_19VariableAndFixedIntIXT_EEE'/>
<def f='halide/build-apps/eigen/Eigen/src/Core/util/IntegralConstant.h' l='123' ll='131'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/util/IntegralConstant.h' l='147'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/util/IntegralConstant.h' l='175'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/util/IntegralConstant.h' l='177'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/util/IntegralConstant.h' l='197' c='_ZN5Eigen3fixET0_'/>
<use f='halide/build-apps/eigen/Eigen/src/Core/util/IntegralConstant.h' l='197' c='_ZN5Eigen3fixET0_'/>
<doc f='halide/build-apps/eigen/Eigen/src/Core/util/IntegralConstant.h' l='94'>/** \internal
  * \class VariableAndFixedInt
  *
  * This class embeds both a compile-time integer \c N and a runtime integer.
  * Both values are supposed to be equal unless the compile-time value \c N has a special
  * value meaning that the runtime-value should be used. Depending on the context, this special
  * value can be either Eigen::Dynamic (for positive quantities) or Eigen::DynamicIndex (for
  * quantities that can be negative).
  *
  * It is the return-type of the function Eigen::fix&lt;N&gt;(int), and most of the time this is the only
  * way it is used. It is strongly discouraged to directly deal with instances of VariableAndFixedInt.
  * Indeed, in order to write generic code, it is the responsibility of the callee to properly convert
  * it to either a true compile-time quantity (i.e. a FixedInt&lt;N&gt;), or to a runtime quantity (e.g., an Index)
  * using the following generic helper:
  * \code
  * internal::cleanup_index_type&lt;T&gt;::type
  * internal::cleanup_index_type&lt;T,DynamicKey&gt;::type
  * \endcode
  * where T can be a template instantiation of VariableAndFixedInt or numerous other integer-like representations.
  * \c DynamicKey is either Dynamic (default) or DynamicIndex and used to identify true compile-time values.
  *
  * For convenience, you can also extract the compile-time value \c N using the following helper:
  * \code
  * internal::get_fixed_value&lt;T,DefaultVal&gt;::value
  * \endcode
  * that will give you \c N if T equals VariableAndFixedInt&lt;N&gt;, and \c DefaultVal if T does not embed any compile-time value (e.g., T==int).
  *
  * \sa fix&lt;N&gt;(int), class FixedInt
  */</doc>
<smbr r='Eigen::internal::VariableAndFixedInt::value' t='const int'/>
<fun r='_ZNK5Eigen8internal19VariableAndFixedIntcviEv'/>
<fun r='_ZN5Eigen8internal19VariableAndFixedIntC1Ei'/>
<mbr r='Eigen::internal::VariableAndFixedInt::m_value' t='int'/>
