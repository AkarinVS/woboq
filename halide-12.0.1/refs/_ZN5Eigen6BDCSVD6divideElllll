<dec f='halide/build-apps/eigen/Eigen/src/SVD/BDCSVD.h' l='181' type='void Eigen::BDCSVD::divide(Eigen::Index firstCol, Eigen::Index lastCol, Eigen::Index firstRowW, Eigen::Index firstColW, Eigen::Index shift)'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/BDCSVD.h' l='284' u='c' c='_ZN5Eigen6BDCSVD7computeERKT_j'/>
<def f='halide/build-apps/eigen/Eigen/src/SVD/BDCSVD.h' l='396' ll='566' type='void Eigen::BDCSVD::divide(Eigen::Index firstCol, Eigen::Index lastCol, Eigen::Index firstRowW, Eigen::Index firstColW, Eigen::Index shift)'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/BDCSVD.h' l='435' u='c' c='_ZN5Eigen6BDCSVD6divideElllll'/>
<use f='halide/build-apps/eigen/Eigen/src/SVD/BDCSVD.h' l='436' u='c' c='_ZN5Eigen6BDCSVD6divideElllll'/>
<doc f='halide/build-apps/eigen/Eigen/src/SVD/BDCSVD.h' l='386'>// The divide algorithm is done &quot;in place&quot;, we are always working on subsets of the same matrix. The divide methods takes as argument the 
// place of the submatrix we are currently working on.

//@param firstCol : The Index of the first column of the submatrix of m_computed and for m_naiveU;
//@param lastCol : The Index of the last column of the submatrix of m_computed and for m_naiveU; 
// lastCol + 1 - firstCol is the size of the submatrix.
//@param firstRowW : The Index of the first row of the matrix W that we are to change. (see the reference paper section 1 for more information on W)
//@param firstRowW : Same as firstRowW with the column.
//@param shift : Each time one takes the left submatrix, one must add 1 to the shift. Why? Because! We actually want the last column of the U submatrix 
// to become the first column (*coeff) and to shift all the other columns to the right. There are more details on the reference paper.</doc>
