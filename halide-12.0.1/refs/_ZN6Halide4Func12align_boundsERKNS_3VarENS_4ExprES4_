<dec f='halide/halide-install/include/Halide.h' l='17436' type='Halide::Func &amp; Halide::Func::align_bounds(const Halide::Var &amp; var, Halide::Expr modulus, Halide::Expr remainder = 0)'/>
<use f='halide/halide-install/include/Halide.h' l='25170' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase12align_boundsEDpOT_'/>
<use f='halide/halide-install/include/Halide.h' l='25170' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase12align_boundsEDpOT_'/>
<doc f='halide/halide-install/include/Halide.h' l='17427'>/** Expand the region computed so that the min coordinates is
     * congruent to &apos;remainder&apos; modulo &apos;modulus&apos;, and the extent is a
     * multiple of &apos;modulus&apos;. For example, f.align_bounds(x, 2) forces
     * the min and extent realized to be even, and calling
     * f.align_bounds(x, 2, 1) forces the min to be odd and the extent
     * to be even. The region computed always contains the region that
     * would have been computed without this directive, so no
     * assertions are injected.
     */</doc>
<dec f='halide/build/include/Halide.h' l='17436' type='Halide::Func &amp; Halide::Func::align_bounds(const Halide::Var &amp; var, Halide::Expr modulus, Halide::Expr remainder = 0)'/>
<use f='halide/build/include/Halide.h' l='25170' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase12align_boundsEDpOT_'/>
<use f='halide/build/include/Halide.h' l='25170' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase12align_boundsEDpOT_'/>
<doc f='halide/build/include/Halide.h' l='17427'>/** Expand the region computed so that the min coordinates is
     * congruent to &apos;remainder&apos; modulo &apos;modulus&apos;, and the extent is a
     * multiple of &apos;modulus&apos;. For example, f.align_bounds(x, 2) forces
     * the min and extent realized to be even, and calling
     * f.align_bounds(x, 2, 1) forces the min to be odd and the extent
     * to be even. The region computed always contains the region that
     * would have been computed without this directive, so no
     * assertions are injected.
     */</doc>
<use f='halide/python_bindings/src/PyFunc.cpp' l='327' u='a' c='_ZN6Halide14PythonBindings11define_funcERN8pybind117module_E'/>
<dec f='halide/src/Func.h' l='1556' type='Halide::Func &amp; Halide::Func::align_bounds(const Halide::Var &amp; var, Halide::Expr modulus, Halide::Expr remainder = 0)'/>
<doc f='halide/src/Func.h' l='1547'>/** Expand the region computed so that the min coordinates is
     * congruent to &apos;remainder&apos; modulo &apos;modulus&apos;, and the extent is a
     * multiple of &apos;modulus&apos;. For example, f.align_bounds(x, 2) forces
     * the min and extent realized to be even, and calling
     * f.align_bounds(x, 2, 1) forces the min to be odd and the extent
     * to be even. The region computed always contains the region that
     * would have been computed without this directive, so no
     * assertions are injected.
     */</doc>
<def f='halide/src/Func.cpp' l='2305' ll='2328' type='Halide::Func &amp; Halide::Func::align_bounds(const Halide::Var &amp; var, Halide::Expr modulus, Halide::Expr remainder = 0)'/>
<use f='halide/src/Generator.h' l='2236' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase12align_boundsEDpOT_'/>
<use f='halide/src/Generator.h' l='2236' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase12align_boundsEDpOT_'/>
