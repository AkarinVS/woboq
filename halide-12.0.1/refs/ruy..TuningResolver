<use f='halide/build-apps/ruy/ruy/ctx.h' l='76' c='_ZNK3ruy3Ctx31GetThreadSpecificTuningResolverEi'/>
<def f='halide/build-apps/ruy/ruy/tune.h' l='90' ll='119'/>
<use f='halide/build-apps/ruy/ruy/tune.h' l='102' c='_ZN3ruy14TuningResolverC1ERKS0_'/>
<size>24</size>
<doc f='halide/build-apps/ruy/ruy/tune.h' l='81'>// Why a TuningResolver class?
//
// Ideally, this Library would offer a single function,
//   Tuning GetCurrentCPUTuning();
//
// However, determining information about the current CPU is not necessarily
// cheap, so we currently cache that and only invalidate/reevaluate after
// a fixed amount of time. This need to store state is why this library
// has to expose a class, TuningResolver, not just a function.</doc>
<fun r='_ZN3ruy14TuningResolverC1Ev'/>
<fun r='_ZN3ruy14TuningResolver9SetTuningENS_6TuningE'/>
<fun r='_ZN3ruy14TuningResolver7ResolveEPNS_7CpuInfoE'/>
<fun r='_ZN3ruy14TuningResolverC1ERKS0_'/>
<fun r='_ZN3ruy14TuningResolver10ResolveNowEPNS_7CpuInfoE'/>
<mbr r='ruy::TuningResolver::unresolved_tuning_' o='0' t='ruy::Tuning'/>
<mbr r='ruy::TuningResolver::last_resolved_tuning_' o='32' t='ruy::Tuning'/>
<mbr r='ruy::TuningResolver::last_resolved_timepoint_' o='64' t='ruy::TimePoint'/>
<mbr r='ruy::TuningResolver::expiry_duration_' o='128' t='const ruy::Duration'/>
<use f='halide/build-apps/ruy/ruy/ctx_impl.h' l='42'/>
<size>24</size>
<use f='halide/build-apps/ruy/ruy/ctx.cc' l='181' c='_ZNK3ruy3Ctx31GetThreadSpecificTuningResolverEi'/>
<use f='halide/build-apps/ruy/ruy/ctx.cc' l='209' c='_ZN3ruy3Ctx19GetMainThreadTuningEv'/>
<size>24</size>
<use f='halide/build-apps/ruy/ruy/trmul.cc' l='62' c='_ZN3ruy12_GLOBAL__N_19TrMulTaskC1EPNS_11TrMulParamsERKNS_8BlockMapEPSt6atomicIiEibNS_8SidePairIPS7_INS0_13PackingStatusEEEEPNS_14TuningResolverEPNS_9A5522035'/>
<use f='halide/build-apps/ruy/ruy/trmul.cc' l='241'/>
<size>24</size>
