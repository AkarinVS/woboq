<dec f='halide/halide-install/include/Halide.h' l='18264' type='Halide::Func &amp; Halide::Func::compute_inline()'/>
<use f='halide/halide-install/include/Halide.h' l='25177' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase14compute_inlineEDpOT_'/>
<use f='halide/halide-install/include/Halide.h' l='25177' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase14compute_inlineEDpOT_'/>
<doc f='halide/halide-install/include/Halide.h' l='18239'>/** Aggressively inline all uses of this function. This is the
     * default schedule, so you&apos;re unlikely to need to call this. For
     * a Func with an update definition, that means it gets computed
     * as close to the innermost loop as possible.
     *
     * Consider once more the pipeline from \ref Func::compute_at :
     *
     \code
     Func f, g;
     Var x, y;
     g(x, y) = x*y;
     f(x, y) = g(x, y) + g(x+1, y) + g(x, y+1) + g(x+1, y+1);
     \endcode
     *
     * Leaving g as inline, this compiles to code equivalent to the following C:
     *
     \code
     int f[height][width];
     for (int y = 0; y &lt; height; y++) {
         for (int x = 0; x &lt; width; x++) {
             f[y][x] = x*y + x*(y+1) + (x+1)*y + (x+1)*(y+1);
         }
     }
     \endcode
     */</doc>
<dec f='halide/build/include/Halide.h' l='18264' type='Halide::Func &amp; Halide::Func::compute_inline()'/>
<use f='halide/build/include/Halide.h' l='25177' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase14compute_inlineEDpOT_'/>
<use f='halide/build/include/Halide.h' l='25177' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase14compute_inlineEDpOT_'/>
<doc f='halide/build/include/Halide.h' l='18239'>/** Aggressively inline all uses of this function. This is the
     * default schedule, so you&apos;re unlikely to need to call this. For
     * a Func with an update definition, that means it gets computed
     * as close to the innermost loop as possible.
     *
     * Consider once more the pipeline from \ref Func::compute_at :
     *
     \code
     Func f, g;
     Var x, y;
     g(x, y) = x*y;
     f(x, y) = g(x, y) + g(x+1, y) + g(x, y+1) + g(x+1, y+1);
     \endcode
     *
     * Leaving g as inline, this compiles to code equivalent to the following C:
     *
     \code
     int f[height][width];
     for (int y = 0; y &lt; height; y++) {
         for (int x = 0; x &lt; width; x++) {
             f[y][x] = x*y + x*(y+1) + (x+1)*y + (x+1)*(y+1);
         }
     }
     \endcode
     */</doc>
<use f='halide/python_bindings/src/PyFunc.cpp' l='208' u='a' c='_ZN6Halide14PythonBindings11define_funcERN8pybind117module_E'/>
<dec f='halide/src/Func.h' l='2384' type='Halide::Func &amp; Halide::Func::compute_inline()'/>
<doc f='halide/src/Func.h' l='2359'>/** Aggressively inline all uses of this function. This is the
     * default schedule, so you&apos;re unlikely to need to call this. For
     * a Func with an update definition, that means it gets computed
     * as close to the innermost loop as possible.
     *
     * Consider once more the pipeline from \ref Func::compute_at :
     *
     \code
     Func f, g;
     Var x, y;
     g(x, y) = x*y;
     f(x, y) = g(x, y) + g(x+1, y) + g(x, y+1) + g(x+1, y+1);
     \endcode
     *
     * Leaving g as inline, this compiles to code equivalent to the following C:
     *
     \code
     int f[height][width];
     for (int y = 0; y &lt; height; y++) {
         for (int x = 0; x &lt; width; x++) {
             f[y][x] = x*y + x*(y+1) + (x+1)*y + (x+1)*(y+1);
         }
     }
     \endcode
     */</doc>
<def f='halide/src/Func.cpp' l='2690' ll='2692' type='Halide::Func &amp; Halide::Func::compute_inline()'/>
<use f='halide/src/Generator.h' l='2243' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase14compute_inlineEDpOT_'/>
<use f='halide/src/Generator.h' l='2243' u='c' c='_ZN6Halide8Internal19GeneratorOutputBase14compute_inlineEDpOT_'/>
