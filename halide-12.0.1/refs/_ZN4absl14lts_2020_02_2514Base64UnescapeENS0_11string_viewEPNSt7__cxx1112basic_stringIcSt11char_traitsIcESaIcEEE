<dec f='halide/build-apps/abseil-cpp/absl/strings/escaping.h' l='125' type='bool absl::lts_2020_02_25::Base64Unescape(absl::string_view src, std::string * dest)'/>
<doc f='halide/build-apps/abseil-cpp/absl/strings/escaping.h' l='120'>// Base64Unescape()
//
// Converts a `src` string encoded in Base64 to its binary equivalent, writing
// it to a `dest` buffer, returning `true` on success. If `src` contains invalid
// characters, `dest` is cleared and returns `false`.</doc>
<def f='halide/build-apps/abseil-cpp/absl/strings/escaping.cc' l='896' ll='898' type='bool absl::lts_2020_02_25::Base64Unescape(absl::string_view src, std::string * dest)'/>
<doc f='halide/build-apps/abseil-cpp/absl/strings/escaping.cc' l='872'>// ----------------------------------------------------------------------
// Base64Unescape() - base64 decoder
// Base64Escape() - base64 encoder
// WebSafeBase64Unescape() - Google&apos;s variation of base64 decoder
// WebSafeBase64Escape() - Google&apos;s variation of base64 encoder
//
// Check out
// http://tools.ietf.org/html/rfc2045 for formal description, but what we
// care about is that...
//   Take the encoded stuff in groups of 4 characters and turn each
//   character into a code 0 to 63 thus:
//           A-Z map to 0 to 25
//           a-z map to 26 to 51
//           0-9 map to 52 to 61
//           +(- for WebSafe) maps to 62
//           /(_ for WebSafe) maps to 63
//   There will be four numbers, all less than 64 which can be represented
//   by a 6 digit binary number (aaaaaa, bbbbbb, cccccc, dddddd respectively).
//   Arrange the 6 digit binary numbers into three bytes as such:
//   aaaaaabb bbbbcccc ccdddddd
//   Equals signs (one or two) are used at the end of the encoded block to
//   indicate that the text was not an integer multiple of three bytes long.
// ----------------------------------------------------------------------</doc>
