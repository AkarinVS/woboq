<dec f='halide/build/include/Halide.h' l='6077' type='1'/>
<use f='halide/build/include/Halide.h' l='6125' u='r' c='_ZNK6Halide8Internal3Dim7is_pureEv'/>
<use f='halide/build/include/Halide.h' l='6131' u='r' c='_ZNK6Halide8Internal3Dim7is_rvarEv'/>
<doc f='halide/build/include/Halide.h' l='6027'>/** The dim originated from an RVar. You can evaluate a Func at
     * distinct values of this RVar in any order (including in
     * parallel) over exactly the interval specified in the
     * RDom. PureRVars can also be reordered arbitrarily in the dims
     * list, as there are no data hazards between the evaluation of
     * the Func at distinct values of the RVar.
     *
     * The most common case where an RVar is considered pure is RVars
     * that are used in a way which obeys all the syntactic
     * constraints that a Var does, e.g:
     *
     \code
     RDom r(0, 100);
     f(r.x) = f(r.x) + 5;
     \endcode
     *
     * Other cases where RVars are pure are where the sites being
     * written to by the Func evaluated at one value of the RVar
     * couldn&apos;t possibly collide with the sites being written or read
     * by the Func at a distinct value of the RVar. For example, r.x
     * is pure in the following three definitions:
     *
     \code

     // This definition writes to even coordinates and reads from the
     // same site (which no other value of r.x is writing to) and odd
     // sites (which no other value of r.x is writing to):
     f(2*r.x) = max(f(2*r.x), f(2*r.x + 7));

     // This definition writes to scanline zero and reads from the the
     // same site and scanline one:
     f(r.x, 0) += f(r.x, 1);

     // This definition reads and writes over non-overlapping ranges:
     f(r.x + 100) += f(r.x);
     \endcode
     *
     * To give two counterexamples, r.x is not pure in the following
     * definitions:
     *
     \code
     // The same site is written by distinct values of the RVar
     // (write-after-write hazard):
     f(r.x / 2) += f(r.x);

     // One value of r.x reads from a site that another value of r.x
     // is writing to (read-after-write hazard):
     f(r.x) += f(r.x + 1);
     \endcode
     */</doc>
<dec f='halide/src/Schedule.h' l='360' type='1'/>
<use f='halide/src/Schedule.h' l='408' u='r' c='_ZNK6Halide8Internal3Dim7is_pureEv'/>
<use f='halide/src/Schedule.h' l='414' u='r' c='_ZNK6Halide8Internal3Dim7is_rvarEv'/>
<doc f='halide/src/Schedule.h' l='310'>/** The dim originated from an RVar. You can evaluate a Func at
     * distinct values of this RVar in any order (including in
     * parallel) over exactly the interval specified in the
     * RDom. PureRVars can also be reordered arbitrarily in the dims
     * list, as there are no data hazards between the evaluation of
     * the Func at distinct values of the RVar.
     *
     * The most common case where an RVar is considered pure is RVars
     * that are used in a way which obeys all the syntactic
     * constraints that a Var does, e.g:
     *
     \code
     RDom r(0, 100);
     f(r.x) = f(r.x) + 5;
     \endcode
     *
     * Other cases where RVars are pure are where the sites being
     * written to by the Func evaluated at one value of the RVar
     * couldn&apos;t possibly collide with the sites being written or read
     * by the Func at a distinct value of the RVar. For example, r.x
     * is pure in the following three definitions:
     *
     \code

     // This definition writes to even coordinates and reads from the
     // same site (which no other value of r.x is writing to) and odd
     // sites (which no other value of r.x is writing to):
     f(2*r.x) = max(f(2*r.x), f(2*r.x + 7));

     // This definition writes to scanline zero and reads from the the
     // same site and scanline one:
     f(r.x, 0) += f(r.x, 1);

     // This definition reads and writes over non-overlapping ranges:
     f(r.x + 100) += f(r.x);
     \endcode
     *
     * To give two counterexamples, r.x is not pure in the following
     * definitions:
     *
     \code
     // The same site is written by distinct values of the RVar
     // (write-after-write hazard):
     f(r.x / 2) += f(r.x);

     // One value of r.x reads from a site that another value of r.x
     // is writing to (read-after-write hazard):
     f(r.x) += f(r.x + 1);
     \endcode
     */</doc>
<use f='halide/src/Func.cpp' l='1148' u='r' c='_ZN6Halide5Stage4fuseERKNS_9VarOrRVarES3_S3_'/>
<use f='halide/src/Func.cpp' l='1175' u='r' c='_ZN6Halide5Stage4fuseERKNS_9VarOrRVarES3_S3_'/>
<use f='halide/src/Func.cpp' l='1176' u='r' c='_ZN6Halide5Stage4fuseERKNS_9VarOrRVarES3_S3_'/>
<use f='halide/src/Func.cpp' l='1177' u='r' c='_ZN6Halide5Stage4fuseERKNS_9VarOrRVarES3_S3_'/>
<use f='halide/src/Function.cpp' l='665' u='r' c='_ZN6Halide8Internal8Function13define_updateERKSt6vectorINS_4ExprESaIS3_EES5_'/>
<use f='halide/src/IRPrinter.cpp' l='373' c='_ZN6Halide8InternallsERSoRKNS0_7DimTypeE'/>
