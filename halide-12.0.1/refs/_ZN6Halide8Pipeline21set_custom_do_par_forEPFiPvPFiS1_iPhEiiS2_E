<dec f='halide/build/include/Halide.h' l='15078' type='void Halide::Pipeline::set_custom_do_par_for(int (*)(void *, int (*)(void *, int, uint8_t *), int, int, uint8_t *) custom_do_par_for)'/>
<doc f='halide/build/include/Halide.h' l='15054'>/** Set a custom parallel for loop launcher. Useful if your app
     * already manages a thread pool. The default implementation is
     * equivalent to this:
     \code
     extern &quot;C&quot; int halide_do_par_for(void *user_context,
                                      int (*f)(void *, int, uint8_t *),
                                      int min, int extent, uint8_t *state) {
         int exit_status = 0;
         parallel for (int idx = min; idx &lt; min+extent; idx++) {
             int job_status = halide_do_task(user_context, f, idx, state);
             if (job_status) exit_status = job_status;
         }
         return exit_status;
     }
     \endcode
     *
     * However, notwithstanding the above example code, if one task
     * fails, we may skip over other tasks, and if two tasks return
     * different error codes, we may select one arbitrarily to return.
     *
     * If you are statically compiling, you can also just define your
     * own version of the above function, and it will clobber Halide&apos;s
     * version.
     */</doc>
<dec f='halide/src/Pipeline.h' l='422' type='void Halide::Pipeline::set_custom_do_par_for(int (*)(void *, int (*)(void *, int, uint8_t *), int, int, uint8_t *) custom_do_par_for)'/>
<doc f='halide/src/Pipeline.h' l='398'>/** Set a custom parallel for loop launcher. Useful if your app
     * already manages a thread pool. The default implementation is
     * equivalent to this:
     \code
     extern &quot;C&quot; int halide_do_par_for(void *user_context,
                                      int (*f)(void *, int, uint8_t *),
                                      int min, int extent, uint8_t *state) {
         int exit_status = 0;
         parallel for (int idx = min; idx &lt; min+extent; idx++) {
             int job_status = halide_do_task(user_context, f, idx, state);
             if (job_status) exit_status = job_status;
         }
         return exit_status;
     }
     \endcode
     *
     * However, notwithstanding the above example code, if one task
     * fails, we may skip over other tasks, and if two tasks return
     * different error codes, we may select one arbitrarily to return.
     *
     * If you are statically compiling, you can also just define your
     * own version of the above function, and it will clobber Halide&apos;s
     * version.
     */</doc>
<use f='halide/src/Func.cpp' l='3273' u='c' c='_ZN6Halide4Func21set_custom_do_par_forEPFiPvPFiS1_iPhEiiS2_E'/>
<def f='halide/src/Pipeline.cpp' l='655' ll='658' type='void Halide::Pipeline::set_custom_do_par_for(int (*)(void *, int (*)(void *, int, uint8_t *), int, int, uint8_t *) cust_do_par_for)'/>
